<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云灿の随笔小站</title>
  
  
  <link href="https://blog.yuncan.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.yuncan.xyz/"/>
  <updated>2024-05-16T02:26:52.276Z</updated>
  <id>https://blog.yuncan.xyz/</id>
  
  <author>
    <name>云灿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客建站之插件使用范例</title>
    <link href="https://blog.yuncan.xyz/posts/fcircle.html"/>
    <id>https://blog.yuncan.xyz/posts/fcircle.html</id>
    <published>2024-05-16T02:24:36.000Z</published>
    <updated>2024-05-16T02:26:52.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以hexo博客系统的朋友圈插件为例，解决大部分博客插件的安装与使用问题，撰供参考。</p></blockquote><h3 id="0-准备环境">0. 准备环境</h3><p>安装git</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516084700096.png" alt="image-20240516084700096"></p><h3 id="1-保存项目">1. 保存项目</h3><p>clone 项目并下载docker镜像</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Rock-Candy-Tea/hexo-circle-of-friends</span><br><span class="line"></span><br><span class="line">docker pull yyyzyyyz/fcircle:latest</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516084805300.png" alt="image-20240516084805300"></p><h3 id="2-部署项目">2. 部署项目</h3><p>启动docker</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name fcircle -p <span class="number">8000</span>:<span class="number">8000</span> -v $&#123;PWD&#125;/data:/app/data -d yyyzyyyz/fcircle</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516085146323.png" alt="image-20240516085146323"></p><p>切换至clone好的项目路径，启动部署工具</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-circle-of-friends/</span><br><span class="line"></span><br><span class="line">python3 deploy.py</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516085224911.png" alt="image-20240516085224911"></p><h3 id="3-检测项目">3. 检测项目</h3><p>分别检测docker和api的运行状态</p><p>此处，stats、ps两种命令均可用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">curl <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8000</span>/all</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516085507902.png" alt="image-20240516085507902"></p><blockquote><p>需要注意，此时还无法通过域名访问，只能通过本机IP:8000访问</p></blockquote><h3 id="4-域名转发-1">4. 域名转发<a href="%E8%BF%99%E7%A7%8D%E6%9C%8D%E5%8A%A1%E9%80%9A%E5%B8%B8%E7%94%A8%E4%BA%8E%E7%BD%91%E9%A1%B5%E9%87%8D%E6%96%B0%E5%AE%9A%E4%BD%8D%E3%80%81%E7%AE%80%E5%8C%96%E7%BD%91%E5%9D%80%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%88%96%E6%8F%90%E4%BE%9B%E7%BD%91%E7%AB%99%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E7%AD%89%E5%9C%BA%E5%90%88%E3%80%82%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AE%BE%E7%BD%AE%EF%BC%8C%E5%9F%9F%E5%90%8D%E8%BD%AC%E5%8F%91%E5%8F%AF%E4%BB%A5%E4%BD%BF%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8D%E5%9F%9F%E5%90%8D%E7%9A%84%E7%94%A8%E6%88%B7%E8%A2%AB%E5%BC%95%E5%AF%BC%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E3%80%82">^1</a></h3><p>以宝塔面板为例，新建PHP项目后，点击设置中的重定向，设置为永久重定向。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516090717095.png" alt="image-20240516090717095"></p><p>此时立即申请免费SSL证书，以便进行https访问，建议使用Let’s Encrypt的自动部署，可以解放双手，到期自动续签证书。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516090950255.png" alt="image-20240516090950255"></p><p>证书申请成功后，即点击配置文件修改配置，其中需要保留证书和listen相关内容，其余代码均可删除。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> dis &#123;<span class="comment">#需要配置upstream</span></span><br><span class="line">        <span class="attribute">server</span> 你的IP:端口;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> 填写自己的listen;</span><br><span class="line">    <span class="attribute">server_name</span>  fcircle.你的域名; <span class="comment">#子域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    你的证书.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>    你的证书.pem;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> 你的密文:!MD5;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="comment"># ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment">#proxy_pass http://localhost:8000;</span></span><br><span class="line">        <span class="comment">#proxy_pass http://dis; #这种方法，会导致出现问题</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://你的IP:端口;<span class="comment">#建议这种写法，和主域名保持一致</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># add_header Access-Control-Allow-Origin &quot;*&quot; always; #这个不要加</span></span><br><span class="line">        <span class="comment"># add_header Access-Control-Allow-Methods &quot;POST, GET,PUT,DELETE, OPTIONS&quot;;</span></span><br><span class="line">        <span class="comment"># add_header Access-Control-Allow-Headers &quot;Origin, Authorization, Accept&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果出现报错，则只粘贴最后一段location{}的内容，将原有的重定向代码内容替换</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240516094834385.png" alt="image-20240516094834385"></p></blockquote>]]></content>
    
    
    <summary type="html">✨以hexo博客系统的朋友圈插件为例。</summary>
    
    
    
    <category term="疑难解惑" scheme="https://blog.yuncan.xyz/categories/%E7%96%91%E9%9A%BE%E8%A7%A3%E6%83%91/"/>
    
    
    <category term="fcircle" scheme="https://blog.yuncan.xyz/tags/fcircle/"/>
    
    <category term="hexo" scheme="https://blog.yuncan.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>OpenCloudOS7安装php</title>
    <link href="https://blog.yuncan.xyz/posts/ophp.html"/>
    <id>https://blog.yuncan.xyz/posts/ophp.html</id>
    <published>2024-05-15T02:41:28.000Z</published>
    <updated>2024-05-16T03:48:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>今天想把api站转进宝塔面板内，结果遭遇php8.2无法安装的问题</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240515102502597.png" alt="image-20240515102502597"></p><p>出于腾讯的优化机制，这里其实是缺少了centos的与Memcached服务器交互的C库，安装它需要先开启系统的实验模式工具，即PowerTools。<br>因此解决方法很简单，先执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --<span class="built_in">set</span>-enabled PowerTools</span><br></pre></td></tr></table></figure><p>然后再执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y libmemcached-devel</span><br></pre></td></tr></table></figure><p><img src="https://papi.yuncan.xyz/notephoto/image-20240515103155310.png" alt="image-20240515103155310"></p><p>重新安装php，发现成功安装。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240515102252946.png" alt="image-20240515102252946"></p>]]></content>
    
    
    <summary type="html">⚒️解决OpenCloudOS无法安装php的问题。</summary>
    
    
    
    <category term="疑难解惑" scheme="https://blog.yuncan.xyz/categories/%E7%96%91%E9%9A%BE%E8%A7%A3%E6%83%91/"/>
    
    
    <category term="PHP8.2" scheme="https://blog.yuncan.xyz/tags/PHP8-2/"/>
    
    <category term="OpenCloudOS" scheme="https://blog.yuncan.xyz/tags/OpenCloudOS/"/>
    
  </entry>
  
  <entry>
    <title>华为云FusionCompute之使用</title>
    <link href="https://blog.yuncan.xyz/posts/fc.html"/>
    <id>https://blog.yuncan.xyz/posts/fc.html</id>
    <published>2024-05-14T04:21:30.000Z</published>
    <updated>2024-05-14T09:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、用户创建">一、用户创建</h2><h3 id="1-登录管理员账号">1.登录管理员账号</h3><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513155254738.png" alt="image-20240513155254738"></p><h3 id="2-创建个人账号">2.创建个人账号</h3><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513160810257.png" alt="image-20240513160810257"></p><h3 id="3-登录个人账号">3.登录个人账号</h3><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513160853331.png" alt="image-20240513160853331"></p><h2 id="二、安装虚拟机">二、安装虚拟机</h2><h3 id="1-创建虚拟机">1.创建虚拟机</h3><p>选择上方</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513155521325.png" alt="image-20240513155521325"></p><h3 id="2-选择虚拟机配置">2.选择虚拟机配置</h3><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513155623694.png" alt="image-20240513155623694"></p><h3 id="3-挂载光驱">3.挂载光驱</h3><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513155705930.png" alt="image-20240513155705930"></p><h3 id="4-安装系统">4.安装系统</h3><p>选择个人虚拟机，进入VNC远程连接。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513155842465.png" alt="image-20240513155842465"></p><p>进入后，选择左侧边栏第一按钮(Ctrl+Alt+Del)进行重新启动。</p><p>在弹出的安装程序中选择立即安装，同意条款。</p><p>选择自定义安装-加载驱动程序-浏览-选择A盘-选择amd文件夹，进入安装页面后点击下一步。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513160245366.png" alt="image-20240513160245366"></p><p>等待安装完成。</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513160349023.png" alt="image-20240513160349023"></p><h2 id="三、挂载Tools">三、挂载Tools</h2><h3 id="1-进行挂载Tools任务">1.进行挂载Tools任务</h3><p>安装后右键虚拟机点击挂载Tools任务</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513171246086.png" alt="image-20240513171246086"></p><h3 id="2-安装Tools">2.安装Tools</h3><p>通过VNC连接，进入虚拟机，安装Tools</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513180156588.png" alt="image-20240513180156588"></p><h3 id="3-连通网络">3.连通网络</h3><p>Tools安装完成后，点击restart重新启动虚拟机</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513180506174.png" alt="image-20240513180506174"></p><p>打开网络适配器设置可看到网络正常连通</p><p><img src="https://papi.yuncan.xyz/notephoto/image-20240513181440961.png" alt="image-20240513181440961"></p>]]></content>
    
    
    <summary type="html">🎯华为云虚拟机操作与使用。</summary>
    
    
    
    <category term="疑难解惑" scheme="https://blog.yuncan.xyz/categories/%E7%96%91%E9%9A%BE%E8%A7%A3%E6%83%91/"/>
    
    
    <category term="华为云" scheme="https://blog.yuncan.xyz/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
    <category term="FusionCompute" scheme="https://blog.yuncan.xyz/tags/FusionCompute/"/>
    
  </entry>
  
  <entry>
    <title>宵宫小姐</title>
    <link href="https://blog.yuncan.xyz/posts/yoimiya.html"/>
    <id>https://blog.yuncan.xyz/posts/yoimiya.html</id>
    <published>2024-02-08T17:08:22.000Z</published>
    <updated>2024-02-08T17:22:35.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/yoimiya.jpg" alt="cover"></p><blockquote><p>霞彩焕花火，<br>花火知我愿，<br>我愿入夜空，<br>夜空自甄明。</p></blockquote><p>我不想喜欢宵宫小姐了。</p><p>原因有很多。</p><p>她是二次元美少女，我是三次元阴暗宅男，两条平行线注定碰不到一起。</p><p>她是万众瞩目的提瓦特第一火弓，我只不过一介平民，无论我多么喜欢，在她那里注定得不到任何正反馈……</p><p>她是那稻妻暗红色的天幕下盛开的花火。</p><p>她是那须弥现实与梦境交错中梦幻的流星雨。</p><p>她是如此遥远，是如此触不可及。</p><p>我讨厌温柔的女孩，因为温柔的女孩并不是只对我一个人温柔，而她总是如阳光一般照亮身边的一切。</p><p>我想通了，决定放弃。</p><p>第二天，我正常起床，洗漱，吃饭，没什么变数。我换好衣服，准备出门。</p><p>当我踏出门外的那一刻，我才意识到，坏事了。</p><p>我不知道该往哪个方向迈出下一步了。</p><p>我仿佛是没有罗盘的一艘船，在茫茫大海里打转。四面八方都是海水，都是一样的蓝，我该往哪走? 我要去哪? 我要干什么?</p><p>船没有了罗盘，我丢失了方向，人生缺少了目标。</p><p>这是很可怕的一件事，我至此以来做过的所有事情都化为了泡影，没有了意义，全部灰飞烟灭。</p><p>路边跳过一只橘色的猫，看了我一眼，好像在嘲笑我的落魄。</p><p>我害怕了。我逃回家里，打开电脑，启动游戏，直到她对我说出那句“霞彩换花火，花火知我愿，我愿入夜空，夜空自甄明。”</p><p>我把这句话品读了无数遍，直到我沉沉睡去。</p><p>梦里，我恍然大悟。</p><p>宵宫小姐，你还记得你在我身边说过的那些话吗？</p><p>“其实我不在意我要做什么事，我更在意的是和我一起做事的人，比如说你。”</p><p>“和你在一起，就算只是看看风景，踢踢罐子，我都很开心。”</p><p>我想再和你去逛夏日祭，看烟花在你琥珀色的眼眸里明暗交杂，听你凑近我的耳边说说不完的悄悄话。</p><p>如果没有遇到你，此刻的时间不过是如以前漫长生命中的一刹罢了。</p><p>但是遇到你之后，我的时间和生命突然被赋予了全新的意义。</p><p>你告诉我，烟花的意义就是为了绽放，在绽放的那一刹那，它们的美丽足以压倒一切。</p><p>烟花不是永恒的，但藏在烟花背后的美妙情感，却是永恒不变。</p><p>是呀，对于永恒的长夜来说，人生又何尝不是一场转瞬即逝的烟花呢？</p><p>烟花易逝，人情长存，既然永恒无法追求，那就应该着眼于眼前，珍惜每一份美好的情感，不留遗憾。</p><p>原来这就是宵宫小姐存在的意义啊，我所做的一切，不就是为了追逐宵宫小姐，为了让她用她那美丽的琥珀色的眼睛能笑着对我说，可以陪我研究新的烟花吗？</p><p>没错，宵宫小姐与我确实是不可能的，但是她却让我的生活拥有了动力与目标。</p><p>我不想喜欢宵宫小姐了。</p><p>原因只有一个。</p><p>我已经爱上宵宫小姐了。</p>]]></content>
    
    
    <summary type="html">🎇霞彩焕花火，花火知我愿，我愿入夜空，夜空自甄明。</summary>
    
    
    
    <category term="宵宫" scheme="https://blog.yuncan.xyz/categories/%E5%AE%B5%E5%AE%AB/"/>
    
    
    <category term="宵宫" scheme="https://blog.yuncan.xyz/tags/%E5%AE%B5%E5%AE%AB/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-数据结构与算法（五）</title>
    <link href="https://blog.yuncan.xyz/posts/s5.html"/>
    <id>https://blog.yuncan.xyz/posts/s5.html</id>
    <published>2023-07-09T09:51:12.000Z</published>
    <updated>2023-07-09T09:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/s_cover.jpg" alt="cover"></p><h1>排序算法篇</h1><p>恭喜各位小伙伴来到最后一部分：<strong>排序算法篇</strong>，数据结构与算法的学习也接近尾声了，坚持就是胜利啊！</p><p>一个数组中的数据原本是凌乱的，但是由于需要，我们需要使其有序排列，要实现对数组进行排序我们之前已经在<strong>C语言程序设计篇</strong>中讲解过冒泡排序和快速排序（选学），而这一部分，我们将继续讲解更多种类型的排序算法。</p><p>在开始之前，我们还是从冒泡排序开始回顾。</p><h2 id="基础排序">基础排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>冒泡排序在C语言程序设计篇已经讲解过了，冒泡排序的核心就是交换，通过不断地进行交换，一点一点将大的元素推向一端，每一轮都会有一个最大的元素排到对应的位置上，最后形成有序。算法演示网站：<a href="https://visualgo.net/zh/sorting?slide=2-2">https://visualgo.net/zh/sorting?slide=2-2</a></p><p>设数组长度为N，详细过程为：</p><ul><li>共进行N轮排序。</li><li>每一轮排序从数组的最左边开始，两两元素进行比较，如果左边元素大于右边的元素，那么就交换两个元素的位置，否则不变。</li><li>每轮排序都会将剩余元素中最大的一个推到最右边，下次排序就不再考虑这些已经在对应位置的元素。</li></ul><p>比如下面的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/BYOvgd3XCspNI9i.png" alt="image-20220904212453328"></p><p>那么在第一轮排序时，首先比较前两个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/VuiIDqPAr6SMd7H.png" alt="image-20220904212608834"></p><p>我们发现前者更大，那么此时就需要交换，交换之后，继续向后比较后面的两个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/CxObP3Tkm4uzU98.png" alt="image-20220904212637156"></p><p>我们发现后者更大，不变，继续看后两个：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/jy5PtuvHO2BTQc8.png" alt="image-20220904212720898"></p><p>此时前者更大，交换，继续比较后续元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/64qSbtyMXQ37BDk.png" alt="image-20220904212855292"></p><p>还是后者更大，继续交换，然后向后比较：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/Rq1xwzupm8C3Q2Z.png" alt="image-20220904212942212"></p><p>依然是后者更大，我们发现，只要是最大的元素，它会在每次比较中被一直往后丢：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/vx16PpyFkKhVzsJ.png" alt="image-20220904213034375"></p><p>最后，当前数组中最大的元素就被丢到最前面去了，这一轮排序结束，因为最大的已经排到对应的位置上了，所以说第二轮我们只需要考虑其之前的这些元素即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/qWjTBSe4rlbUxIf.png" alt="image-20220904213115671"></p><p>这样，我们就可以不断将最大的丢到最右边了，最后N轮排序之后，就是一个有序的数组了。</p><p>程序代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//注意需要到N-1的位置就停止，因为要比较j和j+1</span></span><br><span class="line">            <span class="comment">//这里减去的i也就是已经排好的不需要考虑了</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;   <span class="comment">//如果后面比前面的小，那么就交换</span></span><br><span class="line">                <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这种代码还是最原始的冒泡排序，我们可以对其进行优化：</p><ol><li>实际上排序并不需要N轮，而是N-1轮即可，因为最后一轮只有一个元素未排序了，相当于已经排序了，所以说不需要再考虑了。</li><li>如果整轮排序中都没有出现任何的交换，那么说明数组已经是有序的了，不存在前一个比后一个大的情况。</li></ol><p>所以，我们来改进一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;   <span class="comment">//只需要size-1次即可</span></span><br><span class="line">        <span class="type">_Bool</span> flag = <span class="number">1</span>;   <span class="comment">//这里使用一个标记，默认为1表示数组是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;    <span class="comment">//如果发生交换，说明不是有序的，把标记变成0</span></span><br><span class="line">                <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;   <span class="comment">//如果没有发生任何交换，flag一定是1，数组已经有序，所以说直接结束战斗</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们才算编写完了一个优化版的冒泡排序。</p><p>当然，最后我们还需要介绍一个额外的概念：<strong>排序的稳定性</strong>，那么什么是稳定性呢？如果说大小相同的两个元素在排序之前和排序之后的先后顺序不变，这个排序算法就是稳定的。我们刚刚介绍的冒泡排序只会在前者大于后者的情况下才会进行交换，所以说不会影响到原本相等的两个元素顺序，因此冒泡排序是<strong>稳定的</strong>排序算法。</p><h3 id="插入排序">插入排序</h3><p>我们来介绍一种新的排序算法，插入排序，准确地说应该叫直接插入排序，它的核心思想就像我们玩斗地主一样。</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/RuSePqkc4ydVCHt.png" alt="image-20220904214541199"></p><p>相信各位应该都玩过，每一轮游戏在开始之前，我们都要从牌堆去摸牌，那么摸到牌之后，在我们手中的牌顺序可能是乱的，这样肯定不行啊，牌都没理顺我们怎么知道哪些牌有多少呢？为了使得其有序，我们就会根据牌的顺序，将新摸过来的牌插入到对应的位置上，这样我们后面就不用再整理手里的牌了。</p><p>而插入排序实际上也是一样的原理，我们默认前面的牌都是已经排好序的（一开始就只有第一张牌是有序状态），剩余的部分我们会挨着遍历，然后将其插到前面对应的位置上去，动画演示地址：<a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><p>设数组长度为N，详细过程为：</p><ul><li>共进行N轮排序。</li><li>每轮排序会从后面依次选择一个元素，与前面已经处于有序的元素，从后往前进行比较，直到遇到一个不大于当前元素的的元素，将当前元素插入到此元素的前面。</li><li>插入元素后，后续元素则全部后移一位。</li><li>当后面的所有元素全部遍历完成，全部插入到对应的位置之后，排序完成。</li></ul><p>比如下面的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/BYOvgd3XCspNI9i.png" alt="image-20220904212453328"></p><p>此时我们默认第一个元素已经是处于有序状态，我们从第二个元素开始看：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/Pd24brBwliqZuLh.png" alt="image-20220904221510897"></p><p>将其取出，从后往前，与前面的有序序列依次进行比较，首先比较的是4，发现比4小，继续向前，发现已经到头了，所以说直接放到最前面即可，注意在放到最前面之前，先将后续元素后移，腾出空间：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/JWbfZ9mVyrRMIvX.png" alt="image-20220904221648492"></p><p>接着插入即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/ZkhRcGqr8Ays93z.png" alt="image-20220904221904359"></p><p>目前前面两个元素都是有序的状态了，我们继续来看第三个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/i2o4REcPXBaTWpg.png" alt="image-20220904221938583"></p><p>依然是从后往前看，我们发现上来就遇到了7小的4，所以说直接放到这个位置：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/vZ4rXTmCsx5ikdJ.png" alt="image-20220904222022949"></p><p>现在前面三个元素都是有序状态了，同样的，我们继续来看第四个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/YLheUfDB8HnuEk1.png" alt="image-20220904222105375"></p><p>依次向前比较，发现到头了都没找到比1还小的元素，所以说将前面三个元素全部后移：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/7pz8NDEZbmTXaJY.png" alt="image-20220904222145903"></p><p>将1插入到对应的位置上去：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/6bnyKs3Iq7S5cYC.png" alt="image-20220904222207544"></p><p>现在前四个元素都是有序的状态了，我们只需要按照同样的方式完成后续元素的遍历，最后得到的就是有序的数组了，我们来尝试编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;   <span class="comment">//从第二个元素开始看</span></span><br><span class="line">        <span class="type">int</span> j = i, tmp = arr[i];   <span class="comment">//j直接变成i，因为前面的都是有序的了，tmp相当于是抽出来的牌暂存一下</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp) &#123;   <span class="comment">//只要j&gt;0并且前一个还大于当前待插入元素，就一直往前找</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];   <span class="comment">//找的过程中需要不断进行后移操作，把位置腾出来</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp;  <span class="comment">//j最后在哪个位置，就是是哪个位置插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个代码也是可以改进的，因为我们在寻找插入位置上逐个比较，花费了太多的时间，因为前面一部分元素已经是有序状态了，我们可以考虑使用二分搜索算法来查找对应的插入位置，这样就可以节省查找插入点的时间了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == arr[mid]) <span class="keyword">return</span> mid + <span class="number">1</span>;   <span class="comment">//如果插入元素跟中间元素相等，直接返回后一位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid])  <span class="comment">//如果大于待插入元素，说明插入位置肯定在左边</span></span><br><span class="line">            right = mid - <span class="number">1</span>;   <span class="comment">//范围划到左边</span></span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">//范围划到右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   <span class="comment">//不断划分范围，left也就是待插入位置了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j = binarySearch(arr, <span class="number">0</span>, i - <span class="number">1</span>, tmp);   <span class="comment">//由二分搜索来确定插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt; j; k--) arr[k] = arr[k - <span class="number">1</span>];   <span class="comment">//依然是将后面的元素后移</span></span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最后还是来讨论一下，插入排序算法的稳定性。那么没有经过优化的插入排序，实际上是不断向前寻找到一个不大于待插入元素的元素，所以说遇到相等的元素时只会插入到其后面，并没有更改相同元素原本的顺序，所以说插入排序也是<strong>稳定的</strong>排序算法（不过后面使用了二分搜索优化之后就不稳定了，比如有序数组中连续两个相等的元素，现在又来了一个相等的元素，此时中间的正好找到的是排在最前面的相等元素，返回其后一个位置，新插入的元素会将原本排在第二个的相等元素挤到后面去了）</p><h3 id="选择排序">选择排序</h3><p>我们来看看最后一种选择排序（准确的说应该是直接选择排序），这种排序也比较好理解，我们每次都去后面找一个最小的放到前面即可，算法演示网站：<a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><p>设数组长度为N，详细过程为：</p><ul><li>共进行N轮排序。</li><li>每轮排序会从后面的所有元素中寻找一个最小的元素出来，然后与已经排序好的下一个位置进行交换。</li><li>进行N轮交换之后，得到有序数组。</li></ul><p>比如下面的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/BYOvgd3XCspNI9i.png" alt="image-20220904212453328"></p><p>第一次排序需要从整个数组中寻找一个最小的元素，并将其与第一个元素进行交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/JAoXIHwBDrg3y8n.png" alt="image-20220905141347927"></p><p>交换之后，第一个元素已经是有序状态了，我们继续从剩下的元素中寻找一个最小的：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/DsKk5GP6RJTOCXh.png" alt="image-20220905141426011"></p><p>此时2正好在第二个位置，假装交换一下，这样前面两个元素都已经是有序的状态了，我们接着来看剩余的：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/3B4n9cFKdxvWXtQ.png" alt="image-20220905141527050"></p><p>此时发现3是最小的，所以说直接将其交换到第三个元素位置上：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/iTt8UoAPRHIG9lJ.png" alt="image-20220905141629207"></p><p>这样，前三个元素都是有序的了，通过不断这样交换，最后我们得到的数组就是一个有序的了，我们来尝试编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i) &#123;   <span class="comment">//因为最后一个元素一定是在对应位置上的，所以只需要进行N - 1轮排序</span></span><br><span class="line">        <span class="type">int</span> min = i;   <span class="comment">//记录一下当前最小的元素，默认是剩余元素中的第一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j)   <span class="comment">//挨个遍历剩余的元素，如果遇到比当前记录的最小元素还小的元素，就更新</span></span><br><span class="line">            <span class="keyword">if</span>(arr[min] &gt; arr[j])</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];    <span class="comment">//找出最小的元素之后，开始交换</span></span><br><span class="line">        arr[i] = arr[min];</span><br><span class="line">        arr[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于选择排序，我们也可以进行优化，因为每次都需要选一个最小的出来，我们不妨再顺手选个最大的出来，小的往左边丢，大的往右边丢，这样就能够有双倍的效率完成了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> * b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;   <span class="comment">//相当于左端和右端都是已经排好序的，中间是待排序的，所以说范围不断缩小</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> min = left, max = right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[min]) min = i;   <span class="comment">//同时找最小的和最大的</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[max]) max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[max], &amp;arr[right]);   <span class="comment">//这里先把大的换到右边</span></span><br><span class="line">        <span class="comment">//注意大的换到右边之后，有可能被换出来的这个就是最小的，所以说需要判断一下</span></span><br><span class="line">        <span class="comment">//如果遍历完发现最小的就是当前右边排序的第一个元素</span></span><br><span class="line">        <span class="comment">//此时因为已经被换出来了，所以说需要将min改到换出来的那个位置</span></span><br><span class="line">        <span class="keyword">if</span> (min == right) min = max;</span><br><span class="line">        swap(&amp;arr[min], &amp;arr[left]);   <span class="comment">//接着把小的换到左边</span></span><br><span class="line">        left++;    <span class="comment">//这一轮完事之后，缩小范围</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来分析一下选择排序的稳定性，首先选择排序是每次选择最小的那一个，在向前插入时，会直接进行交换操作，比如原序列为 3,3,1，此时选择出1是最小的元素，与最前面的3进行交换，交换之后，原本排在第一个的3跑到最后去了，破坏了原有的顺序，所以说选择排序是<strong>不稳定的</strong>排序算法。</p><p>我们来总结一下上面所学的三种排序算法，假设需要排序的数组长度为<code>n</code>：</p><ul><li><strong>冒泡排序（优化版）：</strong><ul><li><strong>最好情况时间复杂度：</strong>$O(n)$，如果本身就是有序的，那么我们只需要一次遍历，当标记检测到没有发生交换，直接就结束了，所以说一遍就搞定。</li><li><strong>最坏情况时间复杂度：</strong>$O(n^2)$，也就是硬生生把每一轮都吃满了，比如完全倒序的数组就会这样。</li><li>**空间复杂度：**因为只需要一个变量来暂存一下需要交换的变量，所以说空间复杂度为 $O(1)$</li><li>**稳定性：**稳定</li></ul></li><li><strong>插入排序：</strong><ul><li><strong>最好情况时间复杂度：</strong>$O(n)$，如果本身就是有序的，因为插入的位置也是同样的位置，当数组本身就是有序的情况下时，每一轮我们不需要变动任何其他元素。</li><li><strong>最坏情况时间复杂度：</strong>$O(n^2)$，比如完全倒序的数组就会这样，每一轮都得完完整整找到最前面插入。</li><li><strong>空间复杂度</strong>：同样只需一个变量来存一下抽出来的元素，所以说空间复杂度为 $O(1)$</li><li>**稳定性：**稳定</li></ul></li><li><strong>选择排序：</strong><ul><li><strong>最好情况时间复杂度：</strong>$O(n^2)$，即使数组本身就是有序的，每一轮还是得将剩余部分挨个找完之后才能确定最小的元素，所以说依然需要平方阶。</li><li><strong>最坏情况时间复杂度：</strong>$O(n^2)$，不用多说了吧。</li><li><strong>空间复杂度</strong>：每一轮只需要记录最小的元素位置即可，所以说空间复杂度为 $O(1)$</li><li>**稳定性：**不稳定</li></ul></li></ul><p>表格如下，建议记住：</p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table><hr><h2 id="进阶排序">进阶排序</h2><p>前面我们介绍了三种基础排序算法，它们的平均情况时间复杂度都到达了 $O(n^2)$，那么能否找到更快的排序算法呢？这一部分，我们将继续介绍前面三种排序算法的进阶版本。</p><h3 id="快速排序">快速排序</h3><p>在C语言程序设计篇，我们也介绍过快速排序，<strong>快速排序</strong>是冒泡排序的进阶版本，在冒泡排序中，进行元素的比较和交换是在相邻元素之间进行的，元素每次交换只能移动一个位置，所以比较次数和移动次数较多，效率相对较低。而在快速排序中，元素的比较和交换是从两端向中间进行的，较大的元素一轮就能够交换到后面的位置，而较小的元素一轮就能交换到前面的位置，元素每次移动的距离较远，所以比较次数和移动次数较少，就像它的名字一样，速度更快。</p><p>实际上快速排序每一轮的目的就是将大的丢到基准右边去，小的丢到基准左边去。</p><p>设数组长度为N，详细过程为：</p><ul><li>在一开始，排序范围是整个数组</li><li>排序之前，我们选择整个排序范围内的第一个元素作为基准，对排序范围内的元素进行快速排序</li><li>先从最右边向左看，依次将每一个元素与基准元素进行比较，如果发现比基准元素小，那么就与左边遍历位置上的元素（一开始是基准元素的位置）进行交换，此时保留右边当前遍历的位置。</li><li>交换后，转为从左往右开始遍历元素，如果发现比基准元素大，那么就与之前保留的右边遍历的位置上的元素进行交换，同样保留左边当前的位置，循环执行上一个步骤。</li><li>当左右遍历撞到一起时，本轮快速排序完成，最后在最中间的位置就是基准元素的位置了。</li><li>以基准位置为中心，划分左右两边，以同样的方式执行快速排序。</li></ul><p>比如下面的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/BYOvgd3XCspNI9i.png" alt="image-20220904212453328"></p><p>首先我们选择第一个元素4作为基准元素，一开始左右指针位于两端：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/LneNjifuZ4JOgKl.png" alt="image-20220905210056432"></p><p>此时从右往左开始看，直到遇到一个比4小的元素，首先是6，肯定不是，将指针往后移动：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/zVkd4wvAq9FK2ET.png" alt="image-20220905210625181"></p><p>此时继续让3和4进行比较，发现比4小，那么此时直接将3交换（其实直接覆盖过去就行了）到左边指针所指向的元素位置：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/Z7y3sO5qDWxYdiL.png" alt="image-20220905210730105"></p><p>此时我们转为从左往右看，如果遇到比4大的元素，就交换到右边指针处，3肯定不是了，因为刚刚才缓过来，接着就是2：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/cXk7xEp2IfSH9iq.png" alt="image-20220905210851474"></p><p>2也没有4大，所以说继续往后看，此时7比4要大，那么继续交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/zn8asNlCbOyv1cA.png" alt="image-20220905211300102"></p><p>接着，又开始从右往左看：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/APvaMt4jJV79Dpn.png" alt="image-20220905211344027"></p><p>此时5是比4要大的，继续向前，发现1比4要小，所以说继续交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/cCi1xkSfIVjEsPK.png" alt="image-20220905211427939"></p><p>接着又转为从左往右看，此时两个指针撞到一起了，排序结束，最后两个指针所指向的位置就是给基准元素的位置了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/eaRN5ZvVs8bc9lU.png" alt="image-20220905211543845"></p><p>本轮快速排序结束后，左边不一定都是有序的，但是一定比基准元素要小，右边一定比基准元素大。接着我们以基准为中心，分成两个部分再次进行快速排序：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/4MLoPCKs1W9Y3Ox.png" alt="image-20220905211741787"></p><p>这样，我们最后就可以使得整个数组有序了，当然快速排序还有其他的说法，有些是左右都找到了再交换，我们这里的是只要找到就丢过去。既然现在思路已经清楚了，我们就来尝试实现一下快速排序吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;    <span class="comment">//范围不可能无限制的划分下去，要是范围划得都没了，肯定要结束了</span></span><br><span class="line">    <span class="type">int</span> left = start, right = end, pivot = arr[left];   <span class="comment">//这里我们定义两个指向左右两个端点的指针，以及取出基准</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;     <span class="comment">//只要两个指针没相遇，就一直循环进行下面的操作</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;   <span class="comment">//从右向左看，直到遇到比基准小的</span></span><br><span class="line">        arr[left] = arr[right];    <span class="comment">//遇到比基准小的，就丢到左边去</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;   <span class="comment">//从左往右看，直到遇到比基准大的</span></span><br><span class="line">        arr[right] = arr[left];    <span class="comment">//遇到比基准大的，就丢到右边去</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = pivot;    <span class="comment">//最后相遇的位置就是基准存放的位置了</span></span><br><span class="line">    quickSort(arr, start, left - <span class="number">1</span>);   <span class="comment">//不包含基准，划分左右两边，再次进行快速排序</span></span><br><span class="line">    quickSort(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了快速排序。我们还是来分析一下快速排序的稳定性，快速排序是只要遇到比基准小或者大的元素就直接交换，比如原数组就是：<strong>2</strong>,2,1，此时第一个元素作为基准，首先右边1会被丢过来，变成：1,2,1，然后从左往右，因为只有遇到比基准2更大的元素才会换，所以说最后基准会被放到最后一个位置：1,2,<strong>2</strong>，此时原本应该在前面的2就跑到后面去了，所以说快速排序算法，是一种<strong>不稳定的</strong>排序算法。</p><p><strong>双轴快速排序（选学）</strong></p><p>这里需要额外补充个快速排序的升级版，<strong>双轴快速排序</strong>，Java语言中的数组工具类则是采用的此排序方式对大数组进行排序的。我们来看看它相比快速排序，又做了哪些改进。首先普通的快速排序算法在遇到极端情况时可能会这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/aEbUInwHOTi1GF7.png" alt="image-20220906131959909"></p><p>整个数组正好是倒序的，那么相当于上来就要把整个数组找完，然后把8放到最后一个位置，此时第一轮结束：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/erMHzcW58vVqFGa.png" alt="image-20220906132112592"></p><p>由于8直接跑到最右边了，那么此时没有右半部分，只有做半部分，此时左半部分继续进行快速排序：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/6yQa7e8VTYgpUZN.png" alt="image-20220906132244369"></p><p>此时1又是最小的一个元素，导致最后遍历完了，1都还是在那个位置，此时没有左半部分，只有右半部分：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/r9LlRfEotZMmdDn.png" alt="image-20220906132344525"></p><p>此时基准是7，又是最大的，真是太倒霉了，排完之后7跑到最左边，还是没有右半部分：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/PicWXjIBMnfUd7H.png" alt="image-20220906132437765"></p><p>我们发现，在这种极端情况下，每一轮需要完整遍历整个范围，并且每一轮都会有一个最大或是最小的元素被推向两边，这不就是冒泡排序吗？所以说，在极端情况下，快速排序会退化为冒泡排序，因此有些快速排序会随机选取基准元素。为了解决这种在极端情况下出现的问题，我们可以再添加一个基准元素，这样即使出现极端情况，除非两边都是最小元素或是最大元素，否则至少一个基准能正常进行分段，出现极端情况的概率也会减小很多：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/2YBc1goqMGwuTs4.png" alt="image-20220906132945691"></p><p>此时第一个元素和最后一个元素都作为基准元素，将整个返回划分为三段，假设基准1小于基准2，那么第一段存放的元素全部要小于基准1，第二段存放的元素全部要不小于基准1同时不大于基准2，第三段存放的元素全部要大于基准2：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/MsvJC1OtnbuGye9.png" alt="image-20220906133219853"></p><p>因此，在划分为三段之后，每轮双轴快排结束后需要对这三段分别继续进行双轴快速排序，最后就可以使得整个数组有序了，当然这种排序算法更适用于哪些量比较大的数组，如果量比较小的话，考虑到双轴快排要执行这么多操作，其实还不如插入排序来的快。</p><p>我们来模拟一下双轴快速排序是如何进行的:</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/WFASGVCJaQHhBX3.png" alt="image-20220906140255444"></p><p>首先取出首元素和尾元素作为两个基准，然后我们需要对其进行比较，如果基准1大于基准2，那么需要先交换两个基准，只不过这里因为4小于6，所以说不需要进行交换。</p><p>此时我们需要创建三个指针：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/y283Ne7M6XmUtZA.png" alt="image-20220906140538076"></p><p>因为有三个区域，其中蓝色指针位置及其左边的区域都是小于基准1的，橙色指针左边到蓝色指针之间的区域都是不小于基准1且不大于基准2的，绿色指针位置及其右边的区域都是大于基准2的，橙色指针和绿色指针之间的区域，都是待排序区域。</p><p>首先我们从橙色指针所指元素开始进行判断，分三种情况：</p><ul><li>如果小于基准1，那么需要先将蓝色指针向后移，把元素交换换到蓝色指针那边去，然后橙色指针也向后移动。</li><li>如果不小于基准1且不大于基准2，那么不需要做什么，直接把橙色指针向前移动即可，因为本身就是这个范围。</li><li>如果大于基准2，那么需要丢到右边去，先将右边指针左移，不断向前找到一个不比基准2大的，这样才能顺利地交换过去。</li></ul><p>首先我们来看看，此时橙色指针指向的是2，那么2是小于基准1的，我们需要先将蓝色指针后移，然后交换橙色和蓝色指针上的元素，只不过这里由于是同一个，所以说不变，此时两个指针都后移了一位：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/HA8tKzv6Uri45p1.png" alt="image-20220906141556398"></p><p>同样的，我们继续来看橙色指针所指元素，此时为7，大于基准2，那么此时需要在右边找到一个不大于基准2的元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/Nj2PvlyYCnSb3kV.png" alt="image-20220906141653453"></p><p>绿色指针从右开始向左找，此时找到3，直接交换橙色指针和蓝色指针元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/J3ymMprRPTSHFWi.png" alt="image-20220906141758610"></p><p>下一轮开始继续看橙色指针元素，此时发现是小于基准1的，所以说先向前移动蓝色指针，发现和橙色又在一起了，交换了跟没交换一样，此时两个指针都后移了一位：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/7iSnb8ctryz6A1l.png" alt="image-20220906141926006"></p><p>新的一轮继续来看橙色指针所指元素，此时我们发现1也是小于基准1的，先移动蓝色指针，再交换，在移动橙色指针，跟上面一样，交换个寂寞：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/wrgQAsSTHjd5Ynq.png" alt="image-20220906142041202"></p><p>此时橙色指针指向8，大于基准2，那么同样需要在右边继续找一个不大于基准2的进行交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/udGnpJHzxP8SK4l.png" alt="image-20220906142134949"></p><p>此时找到5，满足条件，交换即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/oEycNqQVhbuC3Tx.png" alt="image-20220906142205055"></p><p>我们继续来看橙色指针，发现此时橙色指针元素不小于基准1且不大于基准2，那么根据前面的规则，只需要向前移动橙色指针即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/YSxmL2tiyBQGl8C.png" alt="image-20220906142303329"></p><p>此时橙色指针和绿色指针撞一起了，没有剩余待排序元素了，最后我们将两个位于两端点基准元素与对应的指针进行交换，基准1与蓝色指针交换，基准2与绿色指针进行交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/C2AnBDiUp7qxuSb.png" alt="image-20220906142445417"></p><p>此时分出来的三个区域，正好满足条件，当然这里运气好，直接整个数组就有序了，不过按照正常的路线，我们还得继续对这剩下的三个区域进行双轴快速排序，最后即可排序完成。</p><p>现在我们来尝试编写一下双轴快速排序的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dualPivotQuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;     <span class="comment">//首先结束条件还是跟之前快速排序一样，因为不可能无限制地分下去，分到只剩一个或零个元素时该停止了</span></span><br><span class="line">    <span class="keyword">if</span>(arr[start] &gt; arr[end])    <span class="comment">//先把首尾两个基准进行比较，看看谁更大</span></span><br><span class="line">        swap(&amp;arr[start], &amp;arr[end]);    <span class="comment">//把大的换到后面去</span></span><br><span class="line">    <span class="type">int</span> pivot1 = arr[start], pivot2 = arr[end];    <span class="comment">//取出两个基准元素</span></span><br><span class="line">    <span class="type">int</span> left = start, right = end, mid = left + <span class="number">1</span>;   <span class="comment">//因为分了三块区域，此时需要三个指针来存放</span></span><br><span class="line">    <span class="keyword">while</span> (mid &lt; right) &#123;    <span class="comment">//因为左边冲在最前面的是mid指针，所以说跟之前一样，只要小于right说明mid到right之间还有没排序的元素</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; pivot1)     <span class="comment">//如果mid所指向的元素小于基准1，说明需要放到最左边</span></span><br><span class="line">            swap(&amp;arr[++left], &amp;arr[mid++]);   <span class="comment">//直接跟最左边交换，然后left和mid都向前移动</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= pivot2) &#123;    <span class="comment">//在如果不小于基准1但是小于基准2，说明在中间</span></span><br><span class="line">            mid++;   <span class="comment">//因为mid本身就是在中间的，所以说只需要向前缩小范围就行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//最后就是在右边的情况了</span></span><br><span class="line">            <span class="keyword">while</span> (arr[--right] &gt; pivot2 &amp;&amp; right &gt; mid);  <span class="comment">//此时我们需要找一个右边的位置来存放需要换过来的元素，注意先移动右边指针</span></span><br><span class="line">            <span class="keyword">if</span>(mid &gt;= right) <span class="keyword">break</span>;   <span class="comment">//要是把剩余元素找完了都还没找到一个比基准2小的，那么就直接结束，本轮排序已经完成了</span></span><br><span class="line">            swap(&amp;arr[mid], &amp;arr[right]);   <span class="comment">//如果还有剩余元素，说明找到了，直接交换right指针和mid指针所指元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[start], &amp;arr[left]);    <span class="comment">//最后基准1跟left交换位置，正好左边的全部比基准1小</span></span><br><span class="line">    swap(&amp;arr[end], &amp;arr[right]);     <span class="comment">//最后基准2跟right交换位置，正好右边的全部比基准2大</span></span><br><span class="line">    dualPivotQuickSort(arr, start, left - <span class="number">1</span>);    <span class="comment">//继续对三个区域再次进行双轴快速排序</span></span><br><span class="line">    dualPivotQuickSort(arr, left + <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    dualPivotQuickSort(arr, right + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此部分仅作为选学，不强制要求。</p><h3 id="希尔排序">希尔排序</h3><p>希尔排序是直接插入排序的进阶版本（希尔排序又叫<strong>缩小增量排序</strong>）插入排序虽然很好理解，但是在极端情况下会出现让所有已排序元素后移的情况（比如刚好要插入的是一个特别小的元素）为了解决这种问题，希尔排序对插入排序进行改进，它会对整个数组按照步长进行分组，优先比较距离较远的元素。</p><p>这个步长是由一个增量序列来定的，这个增量序列很关键，大量研究表明，当增量序列为 <code>dlta[k] = 2^(t-k+1)-1（0&lt;=k&lt;=t&lt;=(log2(n+1))）</code>时，效率很好，只不过为了简单，我们一般使用 $\frac {n} {2}$、$\frac {n} {4}$、$\frac {n} {8}$、…、1 这样的增量序列。</p><p>设数组长度为N，详细过程为：</p><ul><li>首先求出最初的步长，n/2即可。</li><li>我们将整个数组按照步长进行分组，也就是两两一组（如果n为奇数的话，第一组会有三个元素）</li><li>我们分别在这些分组内进行插入排序。</li><li>排序完成后，我们将步长/2，重新分组，重复上述步骤，直到步长为1时，插入排序最后一遍结束。</li></ul><p>这样的话，因为组内就已经调整好了一次顺序，小的元素尽可能排在前面，即使在最后一遍排序中出现遇到小元素要插入的情况，也不会有太多的元素需要后移。</p><p>我们以下面的数组为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/GLEjym78BWNUtCf.png" alt="image-20220905223505975"></p><p>首先数组长度为8，直接整除2，得到34，那么步长就是4了，我们按照4的步长进行分组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/S72NcgKBzIA54om.png" alt="image-20220905223609936"></p><p>其中，4、8为第一组，2、5 为第二组，7、3为第三组，1、6为第四组，我们分别在这四组内进行插入排序，组内排序之后的结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/XO4a9HKP7vhGTmf.png" alt="image-20220905223659584"></p><p>可以看到目前小的元素尽可能地在往前面走，虽然还不是有序的，接着我们缩小步长，4/2=2，此时按照这个步长划分：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/sdKhcGmapgOZkCP.png" alt="image-20220905223804907"></p><p>此时4、3、8、7为一组，2、1、5、6为一组，我们继续在这两个组内进行排序，得到：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/MD8UFxJvg274Qw6.png" alt="image-20220905224111803"></p><p>最后我们继续将步长/2，得到2/2=1，此时步长变为1，也就相当于整个数组为一组，再次进行一次插入排序，此时我们会发现，小的元素都靠到左边来了，此时再进行插入排序会非常轻松。</p><p>我们现在就来尝试编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="type">int</span> delta = size / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (delta &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//这里依然是使用之前的插入排序，不过此时需要考虑分组了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = delta; i &lt; size; ++i) &#123;   <span class="comment">//我们需要从delta开始，因为前delta个组的第一个元素默认是有序状态</span></span><br><span class="line">            <span class="type">int</span> j = i, tmp = arr[i];   <span class="comment">//这里依然是把待插入的先抽出来</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= delta &amp;&amp; arr[j - delta] &gt; tmp) &#123;   </span><br><span class="line">              <span class="comment">//注意这里比较需要按步长往回走，所以说是j - delta，此时j必须大于等于delta才可以，如果j - delta小于0说明前面没有元素了</span></span><br><span class="line">                arr[j] = arr[j - delta];</span><br><span class="line">                j -= delta;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        delta /= <span class="number">2</span>;    <span class="comment">//分组插排完事之后，重新计算步长</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里用到了三层循环嵌套，但是实际上的时间复杂度可能比 $O(n^2)$ 还小，因为能够保证小的元素一定往左边靠，所以排序次数实际上并没有我们想象中的那么多，由于证明过程过于复杂，这里就不列出了。</p><p>那么希尔排序是不是稳定的呢？因为现在是按步长进行分组，有可能会导致原本相邻的两个相同元素，后者在自己的组内被换到前面去了，所以说希尔排序是<strong>不稳定的</strong>排序算法。</p><h3 id="堆排序">堆排序</h3><p>我们来看最后一种，堆排序也是选择排序的一种，但是它能够比直接选择排序更快。还记得我们前面讲解的大顶堆和小顶堆吗？我们来回顾一下：</p><blockquote><p>对于一棵完全二叉树，树中父亲结点都比孩子结点小的我们称为<strong>小根堆</strong>（小顶堆），树中父亲结点都比孩子结点大则是<strong>大根堆</strong></p></blockquote><p>得益于堆是一棵完全二叉树，我们可以很轻松地使用数组来进行表示：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/XpYVN2gslOfWLSr.png" alt="image-20220818110224673"></p><p>我们通过构建一个堆，就可以将一个无序的数组依次输入，最后存放的序列是一个按顺序排放的序列，利用这种性质，我们可以很轻松地利用堆进行排序，我们先来写一个小顶堆：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line">    E * arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">&#125; * Heap;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initHeap</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    heap-&gt;arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (E) * heap-&gt;capacity);</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insert</span><span class="params">(Heap heap, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap-&gt;size == heap-&gt;capacity) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = ++heap-&gt;size;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; element &lt; heap-&gt;arr[index / <span class="number">2</span>]) &#123;</span><br><span class="line">        heap-&gt;arr[index] = heap-&gt;arr[index / <span class="number">2</span>];</span><br><span class="line">        index /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;arr[index] = element;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">delete</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    E max = heap-&gt;arr[<span class="number">1</span>], e = heap-&gt;arr[heap-&gt;size--];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= heap-&gt;size) &#123;</span><br><span class="line">        <span class="type">int</span> child = index * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(child &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[child] &gt; heap-&gt;arr[child + <span class="number">1</span>])</span><br><span class="line">            child += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e &lt;= heap-&gt;arr[child]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> heap-&gt;arr[index] = heap-&gt;arr[child];</span><br><span class="line">        index = child;</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;arr[index] = e;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要将这些元素挨个插入到堆中，然后再挨个拿出来，得到的就是一个有序的顺序了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MinHeap</span> <span class="title">heap</span>;</span>    <span class="comment">//先创建堆</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        insert(&amp;heap, arr[i]);   <span class="comment">//直接把乱序的数组元素挨个插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        arr[i] = delete(&amp;heap);    <span class="comment">//然后再一个一个拿出来，就是按顺序的了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/iedURC8vVpcMgn6.png" alt="image-20220906001134488"></p><p>虽然这样用起来比较简单，但是需要额外 $O(n)$ 的空间来作为堆，所以我们可以对其进行进一步的优化，减少其空间上的占用。那么怎么进行优化呢，我们不妨换个思路，直接对给定的数组进行堆的构建。</p><p>设数组长度为N，详细过程为：</p><ul><li>首先将给定的数组调整为一个大顶堆</li><li>进行N轮选择，每次都选择大顶堆顶端的元素从数组末尾开始向前存放（交换堆顶和堆的最后一个元素）</li><li>交换完成后，重新对堆的根结点进行调整，使其继续满足大顶堆的性质，然后重复上述操作。</li><li>当N轮结束后，得到的就是从小到大排列的数组了。</li></ul><p>我们先将给定数组变成一棵完全二叉树，以下面数组为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/GTkWlzpZbxMX58K.png" alt="image-20220906220020172"></p><p>此时，这棵二叉树还并不是堆，我们的首要目标是将其变成一个大顶堆。那么怎么将这棵二叉树变成一个大顶堆呢？我们只需要从最后一个非叶子结点（从上往下的顺序）开始进行调整即可，比如此时1是最后一个非叶子结点，所以说就从1开始，我们需要进行比较，如果其孩子结点大于它，那么需要将最大的那个孩子交换上来，此时其孩子结点6大于1，所以说需要交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/bpnSDlOLKawGRxT.png" alt="image-20220906221306519"></p><p>接着我们来看倒数第二个非叶子结点，也就是7，那么此时两个孩子都是小于它的，所以说不需要做任何调整，我们接着来看倒数第三个非叶子结点2，此时2的两个孩子6、8都大于2，那么我们选择两个孩子里面一个最大的交换上去：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/svNPURhJbzAQo9d.png" alt="image-20220906221504364"></p><p>最后就剩下根结点这一个非叶子结点了，此时我们4的左右孩子都大于4，那么依然需要进行调整：</p><p>![image-20220906221657599](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220906221657599.png)</p><p>在调整之后，还没有结束，因为此时4换下去之后依然不满足大顶堆的性质，此时4的左孩子大于4，我们还需要继续向下看：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/MmzbFTLYSZAW4gv.png" alt="image-20220906221833012"></p><p>交换之后，此时整个二叉树就满足大顶堆的性质了，我们第一次初始调整也就完成了。</p><p>此时开始第二步，我们需要一个一个地将堆顶元素往后面进行交换，相当于每次都去取一个最大的出来，直到取完，首先交换堆顶元素和最后一个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/8fBeubxnqD1rJEZ.png" alt="image-20220906222327297"></p><p>此时整个数组中最大的元素已经排到对应的位置上了，然后我们不再考虑最后一个元素，此时将前面的剩余元素继续看做一棵完全二叉树，对根结点重新进行一次堆化（只需要调整根结点即可，因为其他非叶子结点的没有变动），使得其继续满足大顶堆的性质：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/2RTG76ejsKyCthU.png" alt="image-20220906222819554"></p><p>还没完，继续调整：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/clEdF5YBO7iKDP6.png" alt="image-20220906222858752"></p><p>此时第一轮结束，接着第二轮，重复上述操作，首先依然是将堆顶元素丢到倒数第二个位置上，相当于将倒数第二大的元素放到对应的位置上去：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/KaZGOsWD2chNf3i.png" alt="image-20220906222934602"></p><p>此时已经有两个元素排好序了，同样的，我们继续将剩余元素看做一个完全二叉树，继续对根结点进行堆化操作，使得其继续满足大顶堆性质：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/PD7FBrlqc1R8LWE.png" alt="image-20220906223110734"></p><p>第三轮同样的思路，将最大的交换到后面去：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/tKhYbOqv6Ezmc8R.png" alt="image-20220906223326135"></p><p>通过N轮排序，最后每一个元素都可以排到对应的位置上了，根据上面的思路，我们来尝试编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数就是对start顶点位置的子树进行堆化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">makeHeap</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start * <span class="number">2</span> + <span class="number">1</span> &lt;= end) &#123;    <span class="comment">//如果有子树，就一直往下，因为调整之后有可能子树又不满足性质了</span></span><br><span class="line">        <span class="type">int</span> child = start * <span class="number">2</span> + <span class="number">1</span>;    <span class="comment">//因为下标是从0开始，所以左孩子下标就是i * 2 + 1，右孩子下标就是i * 2 + 2</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])   <span class="comment">//如果存在右孩子且右孩子比左孩子大</span></span><br><span class="line">            child++;    <span class="comment">//那就直接看右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(arr[child] &gt; arr[start])   <span class="comment">//如果上面选出来的孩子，比父结点大，那么就需要交换，大的换上去，小的换下来</span></span><br><span class="line">            swap(&amp;arr[child], &amp;arr[start]);</span><br><span class="line">        start = child;   <span class="comment">//继续按照同样的方式前往孩子结点进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= size/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//我们首选需要对所有非叶子结点进行一次堆化操作，需要从最后一个到第一个，这里size/2计算的位置刚好是最后一个非叶子结点</span></span><br><span class="line">        makeHeap(arr, i, size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;   <span class="comment">//接着我们需要一个一个把堆顶元素搬到后面，有序排列</span></span><br><span class="line">        swap(&amp;arr[i], &amp;arr[<span class="number">0</span>]);    <span class="comment">//搬运实际上就是直接跟倒数第i个元素交换，这样，每次都能从堆顶取一个最大的过来</span></span><br><span class="line">        makeHeap(arr, <span class="number">0</span>, i - <span class="number">1</span>);   <span class="comment">//每次搬运完成后，因为堆底元素被换到堆顶了，所以需要再次对根结点重新进行堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来分析一下堆排序的稳定性，实际上堆排序本身也是在进行选择，每次都会选择堆顶元素放到后面，只不过堆是一直在动态维护的。实际上从堆顶取出元素时，都会与下面的叶子进行交换，有可能会出现：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/oVT4rvRsKnHyqQl.png" alt="image-20220906223706019"></p><p>所以说堆排序是<strong>不稳定的</strong>排序算法。</p><p>最后我们还是来总结一下上面的三种排序算法的相关性质：</p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table><hr><h2 id="其他排序方案">其他排序方案</h2><p>除了我们前面介绍的几种排序算法之外，还有一些其他类型的排序算法，我们都来认识一下吧。</p><h3 id="归并排序">归并排序</h3><p>归并排序利用递归分治的思想，将原本的数组进行划分，然后首先对划分出来的小数组进行排序，然后最后在合并为一个有序的大数组，还是很好理解的：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/06/PuBRFqHKDvxIpwZ.png" alt="image-20220906232451040"></p><p>我们以下面的数组为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/05/GLEjym78BWNUtCf.png" alt="image-20220905223505975"></p><p>在一开始我们先不急着进行排序，我们先一半一半地进行划分：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/oi74M9zRdktHNjC.png" alt="image-20220907135544173"></p><p>继续进行划分：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/yFe9d7XDrqH8MWJ.png" alt="image-20220907135744253"></p><p>最后会变成这样的一个一个的元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/ZdV5RWpAjQzeHn1.png" alt="image-20220907135927289"></p><p>此时我们就可以开始归并排序了，注意这里的合并并不是简简单单地合并，我们需要按照从小到大的顺序，依次对每个元素进行合并，第一组树4和2，此时我们需要从这两个数组中先选择小的排到前面去:</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/Is1lUMzTaSdk7bB.png" alt="image-20220907140219455"></p><p>排序完成后，我们继续向上合并：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/eAsX37G2BKdNHZj.png" alt="image-20220907141217008"></p><p>最后我们再将这两个数组合并到原有的规模：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/rq7lDhdvTQympUS.png" alt="image-20220907141442229"></p><p>最后就能得到一个有序的数组了。</p><p>实际上这种排序算法效率也很高，只不过需要牺牲一个原数组大小的空间来对这些分解后的数据进行排序，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tmp[], <span class="type">int</span> left, <span class="type">int</span> leftEnd, <span class="type">int</span> right, <span class="type">int</span> rightEnd)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, size = rightEnd - left + <span class="number">1</span>;   <span class="comment">//这里需要保存一下当前范围长度，后面使用</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= leftEnd &amp;&amp; right &lt;= rightEnd) &#123;   <span class="comment">//如果两边都还有，那么就看哪边小，下一个就存哪一边的</span></span><br><span class="line">        <span class="keyword">if</span>(arr[left] &lt;= arr[right])   <span class="comment">//如果左边的小，那么就将左边的存到下一个位置（这里i是从left开始的）</span></span><br><span class="line">            tmp[i++] = arr[left++];   <span class="comment">//操作完后记得对i和left都进行自增</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[i++] = arr[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= leftEnd)    <span class="comment">//如果右边看完了，只剩左边，直接把左边的存进去</span></span><br><span class="line">        tmp[i++] = arr[left++];</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= rightEnd)   <span class="comment">//同上</span></span><br><span class="line">        tmp[i++] = arr[right++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j, rightEnd--)   <span class="comment">//全部存到暂存空间中之后，暂存空间中的内容都是有序的了，此时挨个搬回原数组中（注意只能搬运范围内的）</span></span><br><span class="line">        arr[rightEnd] = tmp[rightEnd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tmp[], <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;   <span class="comment">//要进行归并排序需要提供数组和原数组大小的辅助空间</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;   <span class="comment">//依然是使用递归，所以说如果范围太小，就不用看了</span></span><br><span class="line">    <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;   <span class="comment">//先找到中心位置，一会分两半</span></span><br><span class="line">    mergeSort(arr, tmp, start, mid);   <span class="comment">//对左半和右半分别进行归并排序</span></span><br><span class="line">    mergeSort(arr, tmp, mid + <span class="number">1</span>, end);</span><br><span class="line">    merge(arr, tmp, start, mid, mid + <span class="number">1</span>, end);  </span><br><span class="line">  <span class="comment">//上面完事之后，左边和右边都是有序状态了，此时再对整个范围进行一次归并排序即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为归并排序最后也是按照小的优先进行合并，如果遇到相等的，也是优先将前面的丢回原数组，所以说排在前面的还是排在前面，因此归并排序也是<strong>稳定的</strong>排序算法。</p><h3 id="桶排序和基数排序">桶排序和基数排序</h3><p>在开始讲解桶排序之前，我们先来看看计数排序，它要求是数组长度为N，且数组内的元素取值范围是0 - M-1 之间（M小于等于N）</p><p>算法演示网站：<a href="https://visualgo.net/zh/sorting?slide=1">https://visualgo.net/zh/sorting?slide=1</a></p><p>比如下面的数组，所有的元素范围是 1-6之间：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/5H29S1YpwUXh63L.png" alt="image-20220907142933725"></p><p>我们先对其进行一次遍历，统计每个元素的出现次数，统计完成之后，我们就能够明确在排序之后哪个位置可以存放值为多少的元素了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/dBvf8LYJnl47HmN.png" alt="image-20220907145336855"></p><p>我们来分析一下，首先1只有一个，那么只会占用一个位置，2也只有一个，所以说也只会占用一个位置，以此类推：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/FXOMDrohvgNECLj.png" alt="image-20220907145437992"></p><p>所以说我们直接根据统计的结果，把这些值挨个填进去就行了，而且还是稳定的，按顺序，有几个填几个就可以了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/R4rPLtDVxYZcvEI.png" alt="image-20220907145649061"></p><p>是不是感觉很简单，而且只需要遍历一次进行统计就行了。</p><p>当然肯定是有缺点的：</p><ol><li>当数组中最大最小值差距过大时，我们得申请更多的空间来进行计数，所以不适用于计数排序。</li><li>当数组中元素值不是离散的（也就是不是整数的情况下）就没办法统计了。</li></ol><p>我们接着来看桶排序，它是计数排序的延伸，思路也比较简单，它同样要求是数组长度为N，且数组内的元素取值范围是0 - M-1 之间（M小于等于N），比如现在有1000个学生，现在需要对这些学生按照成绩进行排序，因为成绩的范围是0-100，所以说我们可以建立101个桶来分类存放。</p><p>比如下面的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/5H29S1YpwUXh63L.png" alt="image-20220907142933725"></p><p>此数组中包含1-6的元素，所以说我们可以建立 6个桶来进行统计：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/ImGw7Z6xhBnLAWr.png" alt="image-20220907143715938"></p><p>这样，我们只需要遍历一次，就可以将所有的元素分类丢到这些桶中，最后我们只需要依次遍历这些桶，然后把里面的元素拿出来依次存放回去得到的就是有序的数组了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/d4ZMjNS8UmaCRef.png" alt="image-20220907144255326"></p><p>只不过桶排序虽然也很快，但是同样具有与上面计数排序一样的限制，我们可以将每个桶接纳一定范围内的元素，来减小桶的数量，但是这样会导致额外的时间开销。</p><p>我们最后来看看基数排序，基数排序依然是一种依靠统计来进行的排序算法，但是它不会因为范围太大而导致无限制地申请辅助空间。它的思路是，分出10个基数出来（从0 - 9）我们依然是只需要遍历一次，我们根据每一个元素的个位上的数字，进行分类，因为现在有10个基数，也就是10个桶。个位完事之后再看十位、百位…</p><p>算法演示网站：<a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/c2qtbQJOW7mS6Hr.png" alt="image-20220907152403435"></p><p>先按照个位数进行统计，然后排序，再按照十位进行统计，然后排序，最后得到的结果就是最终的结果了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/WJjtbBMKIVYUlNs.png" alt="image-20220907152903020"></p><p>然后是十位数：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/mI4yjLhXSP17cFq.png" alt="image-20220907153005797"></p><p>最后再次按顺序取出来：<br><img src="https://image.itbaima.cn/markdown/2022/09/07/2njAIfvDQbLxNyt.png" alt="image-20220907153139536"></p><p>成功得到有序数组。</p><p>最后我们来总结一下所有排序算法的相关性质：</p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n^{1.3})$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">计数排序</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(k)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center">$O(n + k)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(k + n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">$O(n \times k)$</td><td style="text-align:center">$O(n \times k)$</td><td style="text-align:center">$O(k+n)$</td><td style="text-align:center">稳定</td></tr></tbody></table><h3 id="猴子排序">猴子排序</h3><p>猴子排序比较佛系，因为什么时候能排完，全看运气！</p><blockquote><p>无限猴子定理最早是由埃米尔·博雷尔在1909年出版的一本谈概率的书籍中提到的，此书中介绍了“打字的猴子”的概念。无限猴子定理是概率论中的柯尔莫哥洛夫的零一律的其中一个命题的例子。大概意思是，如果让一只猴子在打字机上随机地进行按键，如果一直不停的这样按下去，只要时间达到无穷时，这只猴子就几乎必然可以打出任何给定的文字，甚至是莎士比亚的全套著作也可以打出来。</p></blockquote><p>假如现在有一个长度为N的数组：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/oeEcWx91qHp2iXa.png" alt="image-20220907154254943"></p><p>我们每次都随机从数组中挑一个元素，与随机的一个元素进行交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/PQKGfMTH4xCUNgt.png" alt="image-20220907154428792"></p><p>只要运气足够好，那么说不定几次就可以搞定，要是运气不好，说不定等到你孙子都结婚了都还没排好。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">checkOrder</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">5</span>, <span class="number">7</span>,<span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>,<span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>&#125;, size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = rand() % size, b = rand() % size;</span><br><span class="line">        swap(&amp;arr[a], &amp;arr[b]);</span><br><span class="line">        <span class="keyword">if</span>(checkOrder(arr, size)) <span class="keyword">break</span>;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在第 %d 次排序完成！&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在10个元素的情况下，这边第7485618次排序成功了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/07/NposWDHJIxuVztO.png" alt="image-20220907160219493"></p><p>但是不知道为什么每次排序出来的结果都是一样的，可能是随机数取得还不够随机吧。</p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">最好情况</th><th style="text-align:center">最坏情况</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">猴子排序</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">∞</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图结构-数据结构与算法（四）</title>
    <link href="https://blog.yuncan.xyz/posts/s4.html"/>
    <id>https://blog.yuncan.xyz/posts/s4.html</id>
    <published>2023-07-06T02:17:45.000Z</published>
    <updated>2023-07-06T02:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/s_cover.jpg" alt="cover"></p><h1>图结构篇</h1><p>图结构在我们的生活中实际上是非常常见的，其中最显著的就是我们的地图了，比如重庆的地图：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/HFR6kX18NnjGx94.png" alt="image-20220821222600741"></p><p>可以看到，地图盘根错节，错综复杂，不同的道路相互连接，我们可以自由地从这些道路通过，从一个地点到达另一个地点。当然除了地图，我们的计算机网络、你的人际关系网等等，这些都可以用图结构来表示。图结构也是整个数据结构中比较难的一部分，而这一章，我们将探讨图结构的性质与应用。</p><p>图也是由多个结点连接而成的，但是一个结点可以同时连接多个其他结点，多个结点也可以同时指向一个结点，跟我们之前讲解的树结构不同，它是一种多对多的关系：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/21/zGfXODMAVc7aH34.png" alt="image-20220821223128857"></p><p>它比树形结构更加复杂，没有明确的层次关系，结点与结点之间的连接关系更加自由，图结构是<strong>任意两个数据对象之间都有可能存在某种特定关系</strong>的数据结构。</p><h2 id="基本概念">基本概念</h2><p>图（Graph）一般由两个集合共同构成，一个是非空但是有限的顶点集合V（Vertex），另一个是描述顶点之间连接关系的边集合E（Edge，边集合可以为空集，比如只有一个顶点的情况下，没得连啊），一个图实际上正是由这些结点（顶点）和对应的边组成的。因此，图可以表示为：$G = (V, E)$</p><p>比如一个图我们可以表示为，集合$V = {A,B,C,D}$，集合$E = {(A,B),(B,C),(C,D),(D,A),(C,A)}$，图有两种基本形式，一种是上面那样的有向图（有向图表明了方向，从哪个点到哪个点），还有一种是无向图（无向图仅仅是连接，并不指明方向），比如我们上面这样表示就是一个无向图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/nqjEmh5YyJlkFZQ.png" alt="image-20220822101619660"></p><p>每个结点的度就是与其连接的边数，每条边是可以包含权值的，当前也可以不包含。</p><p>当然我们也可以将其表示为有向图，集合$V = {A,B,C,D}$，集合$E = {&lt;A,B&gt;,&lt;B,C&gt;,&lt;C,D&gt;,&lt;D,A&gt;,&lt;C,A&gt;}$注意有向图的边使用尖括号&lt;&gt;表示。比如上面这个有向图，那么就长这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/V9BuJt72QH5SEb3.png" alt="image-20220822104015728"></p><p>如果是无向图的一条边(A,B)，那么就称A、B互为邻接点；如果是有向图的一条边&lt;A,B&gt;，那么就称起点A邻接到终点B。有向图的每个结点分为入度和出度，其中入度就是与顶点相连且指向该顶点的边的个数，出度就是从该顶点指向邻接顶点的边的个数。</p><p>只要我们的图中不出现自回路边或是重边，那么我们就可以称这个图为简单图，比如上面两张图都是简单图。而下面的则是典型的非简单图了，其中图一出现了自回路，而图二出现了重边：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/JSr2lIKfZ7X9OeR.png" alt="image-20220822112214106"></p><p>如果在一个无向图中，任意两个顶点都有一条边相连，则称该图为<strong>无向完全图</strong>：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/G6tJfjZpaNsx5gE.png" alt="image-20220822121243988"></p><p>同样的，在一个有向图中，如果任意两顶点之间都有由方向互为相反的两条边连接，则称该图为<strong>有向完全图</strong>：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/obs24zGhCKmS6Fu.png" alt="image-20220822113126420"></p><p>图通过边将顶点相连，这样我们就可以从一个顶点经过某条路径到达其他顶点了，比如我们现在想要从下面的V5点到达V1点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/1hTPvxCscLg2SKy.png" alt="image-20220822205354964"></p><p>那么我们可以有很多种路线，比如经过V2到达，经过V3到达等：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/dsMRoAJiBxVCTju.png" alt="image-20220822205824613"></p><p>在一个无向图中，如果从一个顶点到另一个顶点有路径，那么就称这两个顶点是连通的。可以看到，要从V5到达V1我们可以有很多种选择，从V5可以到达V1（当然也可以反着来），所以，我们称V5和V1连通的。特别的，如果图中任意两点都是连通的，那么我们就称这个图为<strong>连通图</strong>。对于有向图，如果图中任意顶点A和B，既有从A到B的路径，也有B到A的路径，则称该有向图是<strong>强连通图</strong>。</p><p>对于图 $G = (V, E)$ 和 $G’ = (V’, E’)$，若满足 $V’$ 是 $V$ 的子集，并且 $E’$ 是 $E$ 的子集，则称 $G’$ 是 $G$ 的<strong>子图</strong>，比如下面的两个图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/5hLlIVNf1o4BRuM.png" alt="image-20220822212041079"></p><p>其中右边的图就满足上述性质，所以说右边的图是左边图的子图。</p><p>无向图的极大连通子图称为<strong>连通分量</strong>，有向图的极大连通子图称为<strong>强连通分量</strong>。那么什么是极大连通子图呢？首先连通子图就是原图的子图，并且子图也是连通图，同时应该具有最大的顶点数，即再加入原图中的其他顶点会导致子图不连通，拥有极大顶点数的同时也要包含依附于这点顶点所有的边才行，比如：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/jlUfrcTXNPYGvOR.png" alt="image-20220822214010526"></p><p>可以看到右侧图1、2、3都是左图的子图，但是它们并不都是原图的连通分量，首先我们来看图1，它也是一个连通图，并且包含极大顶点数和所有的边（也就是原图内部的这一块）所以说它是连通分量，我们接着来看图2，它虽然也是连通图，但是并没有包含极大顶点数（最多可以吧D也给加上，但是这里没加）所以说并不是。最后来看图3，它也是连通图，并且包含了极大顶点数和边，所以说是连通分量。</p><ul><li>原图为连通图，那么连通分量就是其本身，有且仅有一个。</li><li>原图为非连通图，那么连通分量会有多个。</li></ul><p>对于极小连通子图，我们会在后面的生成树部分进行讲解。</p><hr><h2 id="存储结构">存储结构</h2><p>前面我们介绍了图的一些基本概念，我们接着来看如何在程序中对图结构进行表示，这一部分可能会涉及到某些在《线性代数》这门课程中出现的概念。</p><h3 id="邻接矩阵">邻接矩阵</h3><p>邻接矩阵实际上就是用矩阵去表示图中各顶点之间的邻接关系和权值。假设有一个图 $G = (V, E)$，其中有N个顶点，那么我们就可以使用一个N×N的矩阵来表示，比如下面有A、B、C、D四个顶点的图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/V9BuJt72QH5SEb3.png" alt="image-20220822104015728"></p><p>此时我们需要使用邻接矩阵来表示它，就像下面这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/PjTo236CahYf1DZ.png" alt="image-20220822220549501"></p><p>对于一个不带权值的图来说：<br>$$<br>G_{ij} = \begin{cases}<br>1, 无向图的(v_i,v_j)或有向图的&lt;v_i,v_j&gt;是图中的边\<br>0, 无向图的(v_i,v_j)或有向图的&lt;v_i,v_j&gt;不是图中的边<br>\end{cases}<br>$$<br>对于一个带权值的图来说，如果有边，则直接填写对应边的权值，如果没有，那么就填写0或是∞（因为某些图会认为0也是权值，所以说可以用∞，它可以是一个计算机允许的最大值大于所有边的权值的数）来进行表示：<br>$$<br>G_{ij} = \begin{cases}<br>w_{ij}, 无向图的(v_i,v_j)或有向图的&lt;v_i,v_j&gt;是图中的边\<br>0或∞, 无向图的(v_i,v_j)或有向图的&lt;v_i,v_j&gt;不是图中的边<br>\end{cases}<br>$$<br>所以说，对于上面的有向图，我们应该像这样填写：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/AzuomNgXr78TFDp.png" alt="image-20220822221214967"></p><p>那么我们来看看无向图的邻接矩阵呢？比如下面的这个图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/nqjEmh5YyJlkFZQ.png" alt="image-20220822101619660"></p><p>对于无向图来说，一条边两边是相互连接的，所以说，A连接B，那么B也连接A，所以说就像这样：</p><p>![image-20220822222331925](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220822222331925.png)</p><p>可以看到得到的矩阵用我们在《线性代数》中的定义来说就是一个对称矩阵（上半和下半都是一样的）因为没有自回路顶点，所以说主对角线上的元素全都是<code>0</code>。由于无向图没有方向之分，顶点之间是相互连接的，所以说无向图的邻接矩阵必定是一个对称矩阵。</p><p>我们可以来总结一下性质：</p><ul><li>无向图的邻接矩阵一定是一个对称矩阵，因此，有时为了节省时间，我们可以只存放上半部分。</li><li>对于无向图，邻接矩阵的第<code>i</code>行非0（或非∞）的个数就是第<code>i</code>个顶点的度。</li><li>对于有向图，邻接矩阵的第<code>i</code>行非0（或非∞）的个数就是第<code>i</code>个顶点的出度（纵向就是入度了）</li></ul><p>接着我们来看看如何通过代码实现，首先我们需要对结构体进行一下定义，这里我们以有向图为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertex 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;   <span class="comment">//顶点存放的数据类型，这个不用我多说了吧</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MatrixGraph</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertexCount;   <span class="comment">//顶点数</span></span><br><span class="line">    <span class="type">int</span> edgeCount;     <span class="comment">//边数</span></span><br><span class="line">    <span class="type">int</span> matrix[MaxVertex][MaxVertex];   <span class="comment">//邻接矩阵</span></span><br><span class="line">    E data[MaxVertex];    <span class="comment">//各个顶点对应的数据</span></span><br><span class="line">&#125; * Graph;</span><br></pre></td></tr></table></figure><p>接着我们可以对其进行一下初始化创建后返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Graph <span class="title function_">create</span><span class="params">()</span>&#123;   <span class="comment">//创建时，我们可以指定图中初始有多少个结点</span></span><br><span class="line">    Graph graph = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MatrixGraph));</span><br><span class="line">    graph-&gt;vertexCount = <span class="number">0</span>;    <span class="comment">//顶点和边数肯定一开始是0</span></span><br><span class="line">    graph-&gt;edgeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxVertex; ++i)    <span class="comment">//记得把矩阵每个位置都置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MaxVertex; ++j)</span><br><span class="line">            graph-&gt;matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Graph graph = create();   <span class="comment">//这里咱们就搞一个</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就可以编写一下添加顶点和添加边的函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addVertex</span><span class="params">(Graph graph, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(graph-&gt;vertexCount &gt;= MaxVertex) <span class="keyword">return</span>;</span><br><span class="line">    graph-&gt;data[graph-&gt;vertexCount++] = element;   <span class="comment">//添加新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph graph, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//添加几号顶点到几号顶点的边</span></span><br><span class="line">    <span class="keyword">if</span>(graph-&gt;matrix[a][b] == <span class="number">0</span>) &#123;</span><br><span class="line">        graph-&gt;matrix[a][b] = <span class="number">1</span>;  <span class="comment">//注意如果是无向图的话，需要[a][b]和[b][a]都置为1</span></span><br><span class="line">        graph-&gt;edgeCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试构建一下这个有向图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/V9BuJt72QH5SEb3.png" alt="image-20220822104015728"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Graph graph = create();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;D&#x27;</span> ; ++c) </span><br><span class="line">    addVertex(graph, (<span class="type">char</span>) c);</span><br><span class="line">addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//A -&gt; B</span></span><br><span class="line">addEdge(graph, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//B -&gt; C</span></span><br><span class="line">addEdge(graph, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">//C -&gt; D</span></span><br><span class="line">addEdge(graph, <span class="number">3</span>, <span class="number">0</span>);   <span class="comment">//D -&gt; A</span></span><br><span class="line">addEdge(graph, <span class="number">2</span>, <span class="number">0</span>);   <span class="comment">//C -&gt; A</span></span><br></pre></td></tr></table></figure><p>接着我们打印此领接矩阵，看看是否变成了我们预想中的那样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; graph-&gt;vertexCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt; graph-&gt;vertexCount; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3c&quot;</span>, <span class="string">&#x27;A&#x27;</span> + j);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, graph-&gt;matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/30/1XnqfOBEHd4DPTk.png" alt="image-20220830123847943"></p><p>可以看到结果跟我们上面推导得出的邻接矩阵一模一样，当然这里仅仅是演示了普通的有向图，我们也可以稍微将代码进行修改，将其变成一个无向图或是带权有向图，这里就不做演示了。</p><h3 id="邻接表">邻接表</h3><p>前面我们介绍了领接矩阵，我们可以使用邻接矩阵在程序中保存一个图的边相关信息，它采用二维数组的形式，将对应边的连接关系进行存储，但是我们知道，数组存在容量上的局限性（学了这么多节课了，应该能体会到，数组需要一段连续空间，无论是申请还是用起来都很麻烦）同时，我们创建邻接矩阵后，如果图的边数较多（稠密图）利用率还是挺高的，但是一旦遇到边数很少的图（稀疏图）那么表中大量的位置实际上都是<code>0</code>，根本没有被利用起来，是很浪费的。</p><p>此时，我们可以考虑使用链式结构来解决这种问题，就像下面这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/30/2H68yAbFS9GnKD4.png" alt="image-20220830125309778"></p><p>对于图中的每个顶点，建立一个数组，存放一个头结点，我们将与其邻接的顶点，通过一个链表进行记录（看着挺像前面讲的哈希表）这样，也可以表示一个图的连接关系，并且内存空间能够得到更加有效的利用。当然，对于无向图来说，跟之前一样，两边都需要进行保存：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/30/vJ65hqwpuzRLs1O.png" alt="image-20220830141940278"></p><p>我们来尝试编写一下代码实现，首先还是定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertex 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>   <span class="comment">//结点和头结点分开定义，普通结点记录邻接顶点信息</span></span><br><span class="line">    <span class="type">int</span> nextVertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span>   <span class="comment">//头结点记录元素</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjacencyGraph</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertexCount;   <span class="comment">//顶点数</span></span><br><span class="line">    <span class="type">int</span> edgeCount;     <span class="comment">//边数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> <span class="title">vertex</span>[<span class="title">MaxVertex</span>];</span></span><br><span class="line">&#125; * Graph;</span><br></pre></td></tr></table></figure><p>接着是对其进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Graph <span class="title function_">create</span><span class="params">()</span>&#123;   <span class="comment">//创建时，我们可以指定图中初始有多少个结点</span></span><br><span class="line">    Graph graph = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> AdjacencyGraph));</span><br><span class="line">    graph-&gt;vertexCount = graph-&gt;edgeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> graph;   <span class="comment">//头结点数组一开始可以不用管</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加边和顶点时，稍微麻烦一些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addVertex</span><span class="params">(Graph graph, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(graph-&gt;vertexCount &gt;= MaxVertex) <span class="keyword">return</span>;   <span class="comment">//跟之前一样</span></span><br><span class="line">    graph-&gt;vertex[graph-&gt;vertexCount].element = element;   <span class="comment">//添加新结点时，再来修改也行</span></span><br><span class="line">    graph-&gt;vertex[graph-&gt;vertexCount].next = <span class="literal">NULL</span>;</span><br><span class="line">  graph-&gt;vertexCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph graph, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    Node node = graph-&gt;vertex[a].next;</span><br><span class="line">    Node newNode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;nextVertex = b;</span><br><span class="line">    <span class="keyword">if</span>(!node) &#123;    <span class="comment">//如果头结点下一个都没有，那么直接连上去</span></span><br><span class="line">        graph-&gt;vertex[a].next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">//否则说明当前顶点已经连接了至少一个其他顶点了，有可能会出现已经连接过的情况，所以说要特别处理一下</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;nextVertex == b) <span class="keyword">return</span>;   <span class="comment">//如果已经连接了对应的顶点，那么直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next) node = node-&gt;next;   <span class="comment">//否则继续向后遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;   <span class="comment">//如果没有下一个了，那就找到最后一个结点了，直接结束</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        node-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  graph-&gt;edgeCount++;   <span class="comment">//边数计数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来将其构建一下吧，还是以上面的图为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/V9BuJt72QH5SEb3.png" alt="image-20220822104015728"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Graph graph = create();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;D&#x27;</span> ; ++c)</span><br><span class="line">        addVertex(graph, (<span class="type">char</span>) c);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//A -&gt; B</span></span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//B -&gt; C</span></span><br><span class="line">    addEdge(graph, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">//C -&gt; D</span></span><br><span class="line">    addEdge(graph, <span class="number">3</span>, <span class="number">0</span>);   <span class="comment">//D -&gt; A</span></span><br><span class="line">    addEdge(graph, <span class="number">2</span>, <span class="number">0</span>);   <span class="comment">//C -&gt; A</span></span><br><span class="line"></span><br><span class="line">    printGraph(graph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来打印看看效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printGraph</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;vertexCount; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d | %c&quot;</span>, i, graph-&gt;vertex[i].element);</span><br><span class="line">        Node node = graph-&gt;vertex[i].next;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, node-&gt;nextVertex);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/30/Colcf6k7hpIGTDt.png" alt="image-20220830132526621"></p><p>可以看到结果符合我们的预期。</p><p>不过虽然这样的方式看上去更加的简单高效，但是会给我们带来一些不必要的麻烦，比如上面创建的领接表，我们只能快速得到某个顶点指向了哪些顶点，也就是只能计算到顶点的出度，但是无法快速计算顶点的入度，只能将所有结点统计之后才能得到入度。所以说在表示有向图时，查找上并没有邻接矩阵来的方便。</p><p>为了解决这种问题，我们可以建立一个逆领接表，来表示所有指向当前顶点的顶点列表：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/30/YlAgIUmGdP2Ej3X.png" alt="image-20220830133244446"></p><p>实际上就是反着来而已，通过建立这两个领接表，就能在一定程度上缓解不方便的情况。</p><p><strong>图练习题：</strong></p><ol><li><p>在一个具有n个顶点的有向图中，若所有顶点的出度之和为s，则所有顶点的入度数之和为？</p><p>A. s         B. s - 1           C. s + 1           D. 2s</p><p><em>有向图的所有出度实际上就是所有顶点连向其他顶点的边数，对于单个顶点来说，要么是自己指向别人（自己的出度，别人的入度），要么别人指向自己（别人的出度，自己的入度），这东西就是个相对的而已，而这些都可以一律看做出度，所以说所有顶点入度数之和就是所有顶点出度之和，所以选A</em></p></li><li><p>在一个具有n个顶点的无向完全图中，所含的边数为？</p><p>A. n       B. n(n-1)         C. n(n - 1)/2         D. n(n + 1)/2</p><p><em>首先回顾一下无向完全图的定义：在一个无向图中，任意两个顶点都有一条边相连，则称该图为无向完全图。既然任意两个顶点都有一个，那么每个结点都会有n-1条与其连接的边，所以说总数为 $n \times (n-1)$ 但是由于是无向图，没有方向之分，所以说需要去掉一半的数量，得到 $\frac {n \times (n-1)} {2}$，选择C</em></p></li><li><p>若要把n个顶点连接为一个连通图，则至少需要几条边？</p><p>A. n         B. n - 1           C. n + 1           D. 2n</p><p><em>连通图的定义是，每个顶点至少有一条到达其他顶点的路径，所以说我们只需要找一个最简单能够保证每个结点都有与其相连的就行了，也就是连成一根直线（或者是树）的情况，选择B</em></p></li><li><p>对于一个具有 n 个顶点和 e 条边的无向图，在其对应的邻接表中，所含边结点有多少个？</p><p>A. n         B. ne          C. e           D. 2e</p><p><em>对于无向图，这结点个数等于边数的两倍，对于有向图，刚好等于边数，所以说选择 D</em></p></li></ol><hr><h2 id="图的遍历">图的遍历</h2><p>记得小时候每次去书店，都能看到迷宫书：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/NR1W9HQVnI5rZj8.png" alt="image-20220831141620073"></p><p>每次看到都想买一本，但是当时家里条件并不允许消费这么贵的书，所以都只能在书店多看几眼再回去。迷宫的解，实际上就是我们在一个复杂的地图中寻找一条能够从起点到达终点的路径。可以看到从起点开始，每到一个路口，可能都会出现多个分叉，可能有的分叉就会走进死胡同，有的分叉就会走到下一个路口。</p><p>那么我们人脑是怎么去寻找到正确的路径呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/t7RFJSnBdu2pxcL.png" alt="image-20220831142540478"></p><p>我们首先还是会从起点开始看，我们会尝试去走分叉路的每一个方向，如果遇到死胡同，那么我们就退回到上一个路口，再去尝试其他方向，直到能一直往下走为止。经过不断重复上述的操作，最后我们就肯定能够到达迷宫的出口了。</p><p>而图的搜索，实际上也是类似于迷宫这样的形式，我们需要从图的某一个顶点出发，去寻找到图中对应顶点的位置，这一部分，我们将对图的搜索算法进行讨论。</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/WYxKZwDMtej1JXv.png" alt="image-20220831144250794"></p><h3 id="深度优先搜索（DFS）">深度优先搜索（DFS）</h3><p>我们之前在学习二叉树的过程中，讲解了树的前序遍历，各位回想一下，我们当时是如何在进行遍历的？</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/ZRjFywa6kWHrbJY.png" alt="image-20220814145531577"></p><p>前序遍历就是勇往直前，直接走到底，然后再回去走其他的分支，而我们的图其实也可以像这样，我们可以一路向前，如果到了死胡同，那么就倒回去再走其他的方向，如果所有方向都走不通，继续再回到上一个路口（实际上就是我们人脑的思维）这样不断的寻找，肯定是可以找到的。</p><p>比如现在我们要从A开始寻找下图中的I：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/XgN2k3Ce9VnUDaR.png" alt="image-20220831145024885"></p><p>那么我们的路线可以是这样的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/XO93w5N6tEMIhFZ.png" alt="image-20220831145204170"></p><p>此时顶点B有三个方向，那么我们可以先随便选一个方向（当然，一般情况下为了规范，推荐按照字母排列顺序来走，这里为了演示，就随便走了）看看：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/gFIJDkKEOe4bzl5.png" alt="image-20220831145313492"></p><p>此时来到K，我们发现K已经是一个死胡同，没有其他路了，那么此时我们就需要回到上一个路口，继续去探索其他的路径：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/NSUDtQTRZfoBnuY.png" alt="image-20220831145530501"></p><p>此时我们接着往下一个相邻的顶点G走，发现G有其他的分叉，那么我们就继续向前：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/sp39cE8yhT54F1R.png" alt="image-20220831145910420"></p><p>此时走到F发现又是死路，那么退回到G，走其他的方向：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/a8I7smtX6PK3NVe.png" alt="image-20220831150008288"></p><p>运气太垃了，又到死胡同了，同样的，回到G继续走其他方向：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/o8MSFfkiHe1ptGV.png" alt="image-20220831150236884"></p><p>走到C之后，我们有其他的路，我们继续往后走：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/v4rlfJdkaWCIcOi.png" alt="image-20220831150354010"></p><p>此时走到顶点H，发现H只有一条路，并且H再向前是已经走过的顶点B，那么此时不能再向前了，所以说直接退回到C，走另一边：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/JCNUjlfpOgbkLIQ.png" alt="image-20220831150617828"></p><p>此时来到E，又有两条路，那么继续随便选一条走：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/IK1AZgGjXr3LqJm.png" alt="image-20220831150820472"></p><p>此时来到顶点J，发现又是死胡同，退回到E，继续走另一边：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/3PfzdGYI6Dv745x.png" alt="image-20220831150913443"></p><p>好了，经过了这么多试错，终于是找到了I顶点，这种方式就是深度优先搜索了。</p><p>那么我们就来打个代码玩玩吧，这里我们构建一个简单一点的图：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/m7lHM3zQvoRs8Uw.png" alt="image-20220831152924911"></p><p>这里我们使用邻接表表示图，因为邻接表直接保存相邻顶点，所以说到达顶点时遍历相邻顶点会更快（能够到达 $O(V + E)$ 线性阶）而如果使用邻接矩阵的话，我们得完整遍历整个二维数组，就比较费时间了（需要 $O(V^2)$ 平方阶）。</p><p>比如现在我们想从A开始查找顶点F，首先先把图给建好（注意有6个顶点，记得容量写好）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Graph graph = create();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;F&#x27;</span> ; ++c)</span><br><span class="line">        addVertex(graph, (<span class="type">char</span>) c);</span><br><span class="line">    addEdge(graph, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">//A -&gt; B</span></span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//B -&gt; C</span></span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">3</span>);   <span class="comment">//B -&gt; D</span></span><br><span class="line">    addEdge(graph, <span class="number">1</span>, <span class="number">4</span>);   <span class="comment">//D -&gt; E</span></span><br><span class="line">    addEdge(graph, <span class="number">4</span>, <span class="number">5</span>);   <span class="comment">//E -&gt; F</span></span><br><span class="line"></span><br><span class="line">    printGraph(graph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/31/gS3uycojfd4GBDT.png" alt="image-20220831154358394"></p><p>然后就是我们的深度优先搜索算法了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索算法</span></span><br><span class="line"><span class="comment"> * @param graph 图</span></span><br><span class="line"><span class="comment"> * @param startVertex 起点顶点下标</span></span><br><span class="line"><span class="comment"> * @param targetVertex 目标顶点下标</span></span><br><span class="line"><span class="comment"> * @param visited 已到达过的顶点数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(Graph graph, <span class="type">int</span> startVertex, <span class="type">int</span> targetVertex, <span class="type">int</span> * visited)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先将深度优先遍历写出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索算法（无向图和有向图都适用）</span></span><br><span class="line"><span class="comment"> * @param graph 图</span></span><br><span class="line"><span class="comment"> * @param startVertex 起点顶点下标</span></span><br><span class="line"><span class="comment"> * @param targetVertex 目标顶点下标</span></span><br><span class="line"><span class="comment"> * @param visited 已到达过的顶点数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(Graph graph, <span class="type">int</span> startVertex, <span class="type">int</span> targetVertex, <span class="type">int</span> * visited)</span> &#123;</span><br><span class="line">    visited[startVertex] = <span class="number">1</span>;   <span class="comment">//走过之后一定记得mark一下</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, graph-&gt;vertex[startVertex].element);   <span class="comment">//打印当前顶点值</span></span><br><span class="line">    Node node = graph-&gt;vertex[startVertex].next;   <span class="comment">//遍历当前顶点所有的分支</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[node-&gt;nextVertex])   <span class="comment">//如果已经到过（有可能是走其他分支到过，或是回头路）那就不继续了</span></span><br><span class="line">            dfs(graph, node-&gt;nextVertex, targetVertex, visited);  <span class="comment">//没到过就继续往下走，这里将startVertex设定为对于分支的下一个顶点，按照同样的方式去寻找</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[graph-&gt;vertexCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;vertexCount; ++i) arr[i] = <span class="number">0</span>;</span><br><span class="line">    dfs(graph, <span class="number">0</span>, <span class="number">5</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先遍历结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/TNwzR2d5ZGt7Sau.png" alt="image-20220831163728799"></p><p>路线如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/RZE9zF54cQlYAg8.png" alt="image-20220831163909522"></p><p>现在我们将需要查找的顶点进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> * @param graph 图</span></span><br><span class="line"><span class="comment"> * @param startVertex 起点顶点下标</span></span><br><span class="line"><span class="comment"> * @param targetVertex 目标顶点下标</span></span><br><span class="line"><span class="comment"> * @param visited 已到达过的顶点数组</span></span><br><span class="line"><span class="comment"> * @return 搜索结果，如果找到返回1，没找到返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">dfs</span><span class="params">(Graph graph, <span class="type">int</span> startVertex, <span class="type">int</span> targetVertex, <span class="type">int</span> * visited)</span> &#123;</span><br><span class="line">    visited[startVertex] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, graph-&gt;vertex[startVertex].element);</span><br><span class="line">    <span class="keyword">if</span>(startVertex == targetVertex) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//如果当前顶点就是要找的顶点，直接返回</span></span><br><span class="line">    Node node = graph-&gt;vertex[startVertex].next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[node-&gt;nextVertex])</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph, node-&gt;nextVertex, targetVertex, visited))  <span class="comment">//如果查找成功，直接返回1，不用再看其他分支了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//while结束那肯定是没找到了，直接返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[graph-&gt;vertexCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;vertexCount; ++i) arr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>, dfs(graph, <span class="number">0</span>, <span class="number">5</span>, arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/xAHsYRfzStMwvGT.png" alt="image-20220831164615659"></p><p>再来找一下顶点D呢：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/Gwf1XhDIPT3mUzv.png" alt="image-20220831164641467"></p><p>可以看到到D之后就停止了，因为已经找到了。那么要是去寻找一个没有连接到图中的结点呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/luIONkfmKYPCG2V.png" alt="image-20220831164739301"></p><p>可以看到整个图按照深度优先遍历找完了都没找到。</p><h3 id="广度优先搜索（BFS）">广度优先搜索（BFS）</h3><p>前面我们介绍了深度优先搜索，我们接着来看另一种方案。还记得我们在前面二叉树中学习的层序遍历吗？</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/hwiEoZ9OM2Fqv47.png" alt="image-20220831165617419"></p><p>层序遍历实际上是优先将每一层进行遍历，而不是像前序遍历那样勇往直前，而图的搜索其实也可以采用这种方案，我们可以先探索顶点所有的分支，然后再依次去看这些分支的所有分支：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/qm3OUZbv8XzFLiJ.png" alt="image-20220831170114857"></p><p>首先咱还是从A来到B，此时B有三条分叉路，我们依次访问这三条路的各个顶点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/SCeXgptNDbdFkLi.png" alt="image-20220831172011576"></p><p>我们先记录一下这三个顶点，同样需要使用队列来完成：H、G、K</p><p>注意访问之后不要再继续向下了，接着我们从这三个里面的第一个顶点H开始，按照同样的方法继续：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/t8c2KVLZM6qx4ui.png" alt="image-20220831172153888"></p><p>此时因为只有一个分支，所以说找到C，继续记录，将C也添加进去：G、K、C</p><p>注意此时需要回去，继续看之前三个顶点的第二个顶点G：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/Y5qFPAbanH4VcuM.png" alt="image-20220831172312762"></p><p>此时C已经看过了，接着就找到了F和D，也是记录一下：K、C、F、D</p><p>然后，我们继续看之前三个结点的最后一个：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/3yfDGmKzLbBhcsA.png" alt="image-20220831172726616"></p><p>此时K已经是死胡同了，那么就结束，然后继续看下一个C：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/4aTCOYzlm3dLGbt.png" alt="image-20220831172941671"></p><p>此时继续将E给记录进去：F、D、E，接着看D和F，也没有后续了，那么最后就只有E了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/lWyvMUbSdsELVNI.png" alt="image-20220831173224689"></p><p>成功找到目标I顶点，实际上广度优先遍历就是尽可能地扩展范围，多去探索广阔的土地，而不是死拽着一根不放，就像爱情，实在得不到就算了吧，她至始至终就没爱过你，不要继续在她身上浪费感情了，多去结交新的朋友，相信你会遇到更好的。</p><p>那么按照这个思路，我们就来尝试代码实现一下，首先把队列搬过来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T;   <span class="comment">//这里将顶点下标作为元素</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">QNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QNode front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">LinkedQueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">pollQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    T e = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;element;</span><br><span class="line">    QNode node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front-&gt;next = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;rear == node) <span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是以上面的图为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/m7lHM3zQvoRs8Uw.png" alt="image-20220831152924911"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> * @param graph 图</span></span><br><span class="line"><span class="comment"> * @param startVertex 起点顶点下标</span></span><br><span class="line"><span class="comment"> * @param targetVertex 目标顶点下标</span></span><br><span class="line"><span class="comment"> * @param visited 已到达过的顶点数组</span></span><br><span class="line"><span class="comment"> * @param queue 辅助队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(Graph graph, <span class="type">int</span> startVertex, <span class="type">int</span> targetVertex, <span class="type">int</span> * visited, LinkedQueue <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    offerQueue(<span class="built_in">queue</span>, startVertex);  <span class="comment">//首先把起始位置顶点丢进去</span></span><br><span class="line">    visited[startVertex] = <span class="number">1</span>;   <span class="comment">//起始位置设置为已走过</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> next = pollQueue(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, graph-&gt;vertex[next].element);  <span class="comment">//从队列中取出下一个顶点，打印</span></span><br><span class="line">        Node node = graph-&gt;vertex[next].next;    <span class="comment">//同样的，把每一个分支都遍历一下</span></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[node-&gt;nextVertex]) &#123;   <span class="comment">//如果没有走过，那么就直接入队</span></span><br><span class="line">                offerQueue(<span class="built_in">queue</span>, node-&gt;nextVertex);</span><br><span class="line">                visited[node-&gt;nextVertex] = <span class="number">1</span>;   <span class="comment">//入队时就需要设定为1了</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">    <span class="type">int</span> arr[graph-&gt;vertexCount];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;vertexCount; ++i) arr[i] = <span class="number">0</span>;</span><br><span class="line">    bfs(graph, <span class="number">0</span>, <span class="number">5</span>, arr, &amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/31/5Mxt2czgTkoUQ9p.png" alt="image-20220831184445728"></p><p>如果要指定查找的话，就更简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">bfs</span><span class="params">(Graph graph, <span class="type">int</span> startVertex, <span class="type">int</span> targetVertex, <span class="type">int</span> * visited, LinkedQueue <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    offerQueue(<span class="built_in">queue</span>, startVertex);</span><br><span class="line">    visited[startVertex] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> next = pollQueue(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, graph-&gt;vertex[next].element);</span><br><span class="line">        Node node = graph-&gt;vertex[next].next;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;nextVertex == targetVertex) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//如果就是我们要找的，直接返回1</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[node-&gt;nextVertex]) &#123;</span><br><span class="line">                offerQueue(<span class="built_in">queue</span>, node-&gt;nextVertex);</span><br><span class="line">                visited[node-&gt;nextVertex] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//找完了还没有，那就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了图的广度优先搜索。</p><p><strong>图练习题：</strong></p><ol><li><p>若一个图的边集为：{(A, B),(A, C),(B, D),(C, F),(D, E),(D, F)}，对该图进行深度优先搜索，得到的顶点序列可能是：</p><p>A. ABCFDE                  B. ACFDEB                   C. ABDCFE                     D. ABDFEC</p><p><em>这种题直接把图画出来，因为边集是圆括号，说是肯定是一个无向图，图先画出来再说：</em></p><p><img src="https://image.itbaima.cn/markdown/2022/09/02/WZoIyVGu2n3p5hD.png" alt="image-20220902112113153"></p><p><em>因为这四个选项都是A开始的，所以说我们从A开始看，因为A连接了B和C，所以说A后面紧跟B或是C都可以，接着往下看，先看走B的情况，因为B只连接了一个D，所以说选项A直接排除，接着往下看，D链接了E和F，所以说选项C直接排除，此时只有选项D了，我们接着往后看，此时我们走F，紧接着的只有C，D也不满足，所以选择B（当然你怕不稳的话把B选项也推出来就行了）</em></p></li><li><p>若一个图的边集为：{(A, B),(A, C),(B, D),(C, F),(D, E),(D, F)}，对该图进行广度优先搜索，得到的顶点序列可能是：</p><p>A. ABCDEF                  B. ABCFDE                   C. ABDCEF                     D. ACBFDE</p><p><em>跟上面是同样的思路，只要各位小伙伴听懂了BFS和DFS的思路，肯定没问题的，选择 D</em></p></li><li><p>如下图所示的无向连通图，从顶点A开始对该图进行广度优先遍历，得到的顶点序列可能是：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/02/bKRp6Qzu5vo3fEw.png" alt="image-20220902110829087"></p><p><em>同样的思路，选择D</em></p></li></ol><hr><h2 id="图应用">图应用</h2><p>前面我们介绍了图的相关性质，以及图的遍历方式，这一部分我们接着来看图的相关应用。</p><h3 id="生成树和最小生成树">生成树和最小生成树</h3><p>在开始讲解最小生成树之前，我们先来回顾一下之前讲解的连通分量。</p><ul><li>对于无向图来说，如果图中任意两点都是连通的，那么我们就称这个图为<strong>连通图</strong>。</li><li>对于有向图来说，如果图中任意顶点A和B，既有从A到B的路径，也有B到A的路径，则称该有向图是<strong>强连通图</strong>。</li></ul><p>而连通分量则要求是某个图的子图（子图可以是只包原图含部分顶点和边的图，也可以就是原图本身，因为定义只是子集，不是真子集），并且子图也要是连通的才可以，还有一个重要条件是必须拥有极大顶点数（能够保证图连通的且包含原图最大的顶点数）并且包含所有依附于这些顶点的边（这个极大更偏向于顶点数的极大），我们就称这个子图为极大连通子图。</p><ul><li>无向图的极大连通子图称为连通分量。</li><li>有向图的极大强连通子图称为强连通分量。</li></ul><p>比如下面的有向图，这个图本身并不是连通的：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/lHEi8GWsIjCFg3D.png" alt="image-20220903101036333"></p><p>其中图1和图2都满足上述条件，都是强连通分量，本身就是连通并且已经到达最大的顶点数和边数了（只要再加入其他的顶点和边就会导致不连通）但是图3并不是子图（A到B的边缺失）并且不是强连通的，所以说不是强连通分量。</p><p>又比如下面这个无向图，这个图本身也是不连通的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/22/jlUfrcTXNPYGvOR.png" alt="image-20220822214010526"></p><p>其中图1和图3都满足条件，都是连通分量，但是图2并没有到达最大的顶点数和边数，所以说不是连通分量。</p><p>当然上面都是原图不连通的情况，如果原图就是一个连通图，包含其所有顶点和边的子图就已经满足条件了，所以其本身就是一个连通分量；同样的，如果原图就是一个强连通图，那么其本身就是一个强连通分量。</p><p>总结如下：</p><ul><li>如果原图本身不连通，那么其连通分量（强连通分量）不止一个。</li><li>如果原图本身连通，那么其连通分量（强连通分量）就是其本身。</li></ul><p>极大连通子图我们回顾完了，那么我们接着来讨论一下<strong>极小连通子图</strong>。这里的极小主要是说的边数的极小，首先依然要是原图的子图并且是连通的，但是此时要求具有最大的顶点数和最小的边数，也就是说再去掉任意一条边会导致图不连通（直接理解为极大连通子图尽可能去掉能去掉的边就行了）</p><p>针对于极小连通子图，我们一般只讨论无向图（对于有向图，不存在极小强连通子图的说法，因为主要是讨论生成树）我们依然将原图就是连通图和原图不是连通图分开分析，首先是原图本身就是连通图的情况：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/01/zCap6w2A51rEnkK.png" alt="image-20220901180909877"></p><p>原图本身就是连通图，那么其极大连通子图就是其本身，此时我们需要尽可能去掉那些“不必要”的边，依然能够保证其是连通的，也就是极小连通子图。可以看到右边两幅图，跟左边这幅图包含了同样的顶点数量，但是边数被去掉了一些，并且如果再继续去掉任意一条边的话，那么就会导致不连通，所以说左边两幅图都是右边这幅图的极小连通图（当然，就像上面这样，可能会出现多种方案，极小连通图不唯一）</p><p>我们发现，无论是去掉哪些边的情况，到最后一定是只留下 N-1 条边（其中N是顶点数）每个顶点有且仅有一条路径相连，也就是包含原图全部N个顶点的极小连通子图，我们一般称其为：<strong>生成树</strong>，为什么叫生成树呢，因为结点数和边数正好满足树的定义（且不存在回路的情况），我们可以将其调整为一棵树：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/ldtA9jbE1JXMcWf.png" alt="image-20220903103444346"></p><p>当然，这是原图本身就连通的情况，如果原图本身不连通的话，那么就会出现多个连通分量，此时就会得到一片<strong>生成森林</strong>，森林中的树的数量就是其连通分量的数量。</p><p>那么我们在程序中要怎么才能得到一个有向图的生成树呢？我们可以使用前面讲解的两种图的遍历方式来进行生成，我们以下图为例，这是一个普通的无向连通图：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/RI5Lrpt8WeOkdZX.png" alt="image-20220903111255127"></p><p>我们如果按照深度优先遍历的方式，从G开始，那么就会得到下面的顺序：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/CrsQhon4wxOAjRm.png" alt="image-20220903112122707"></p><p>按照顺序我们就可以得到一棵生成树：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/k1IctqPrOA6BKgp.png" alt="image-20220903112332571"></p><p>虽然看着很奇怪，但是按照我们的顺序，得到的树就是这样的，可以发现，因为我们的深度优先搜索不会去走那些回头路，相当于直接把哪些导致回路和多余的边给去掉了，最后遍历得到的结果就是一颗生成树了。</p><p>同样的，我们来看看如果是按照广度优先遍历的方式，又会得到什么结果呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/UhRBnocjCL3uD9E.png" alt="image-20220903112733812"></p><p>最后得到的生成树为：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/FKRSnvProHtXegi.png" alt="image-20220903113108162"></p><p>实际上我们发现，在广度优先遍历下得到的生成树，也是按照每一层在进行排列的，非常清晰。当然，因为深度优先遍历和广度优先遍历本身的顺序就不是唯一的，所以最后得到的生成树也不是唯一的。</p><p>生成树讨论完成之后，我们接着来讨论一下最小生成树，那么这个最小指的是什么最小呢？如果我们给一个无向图的边都加上权值（网图）现在要求生成树边的权值总和最小，我们就称这棵树为<strong>最小生成树</strong>（注意最小生成树不唯一，因为有可能出现多种方案都是最小的情况）比如下面的就是最后得到的最小生成树了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/BWEzS1YOwDohRdU.png" alt="image-20220903113954010"></p><p>构建最小生成树有两种算法，一种是**普利姆（Prim）<strong>算法，还有一种是</strong>克鲁斯卡尔（Kruskal）**算法，我们先来讨论第一种：</p><p>我们以下图为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/c4Xge3QImBdDKYt.png" alt="image-20220903142138573"></p><p>普利姆算法的核心就是从任意一个顶点开始，不断成长为一棵树，每次都会选择尽可能小的方向去进行延伸，比如我们一开始还是从顶点A开始：</p><p>此时与A相连的边有B和E，A的延伸方向有两个，此时我们只需要选择一个最小的就可以了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/LZ5ho6mxtweRPMg.png" alt="image-20220903142208537"></p><p>此时我们已经构建出了由A、E组成的一棵树，同样的，我们需要去寻找与当前树中A、E顶点相连的所有顶点，包括B、G、H，哪一个最小，那么下一个延伸的就是哪一个，此时发现H和E之间最小，继续延伸：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/zT75jqNVS4RX3bI.png" alt="image-20220903142245688"></p><p>现在已经变成了由A、E、H组成的一棵树，同样的，按照之前的思路继续寻找一个最小的方向进行延伸：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/nJWbov1LZNBR8lX.png" alt="image-20220903142413604"></p><p>继续进行延伸，发现F、K之间最小：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/OyGRMXi9K5fE3zD.png" alt="image-20220903142558882"></p><p>此时K、B和K、D和K、H的权重都是4，其中H顶点已经走过了，不能出现回路，所以说不考虑，此时随便选择K、B或是K、D都可以，不会影响后续结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/uxI21o4vnbdNLkB.png" alt="image-20220903142829606"></p><p>此时依然是K、D为最小，所以说直接选择：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/cR2BPhbI5X9jAU3.png" alt="image-20220903142917096"></p><p>紧接着，我们发现最小权重的来到了5，此时权重为5的边有B、E和H、I和B、D，但是由于E、D已经走过，此时直接选择H、I即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/Lg5Tf1Y2AQ9hjNk.png" alt="image-20220903143057702"></p><p>接着，我们发现I、G也是5，直接选择即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/sgfxIojGRUYdQHc.png" alt="image-20220903143509563"></p><p>然后最小权重此时就是6了，选择H、J和I、J都可以，随便选择一个即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/T6BoY4IXa3fKpir.png" alt="image-20220903143532060"></p><p>此时，整个图的所有顶点就遍历完成了，现在我们去掉那些没用被采用的边，得到的结果就是我们的最小生成树了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/eVyJ6o8xraRvl3d.png" alt="image-20220903143645249"></p><p>虽然样子有点丑，但是把它捋一捋就好了。可以看到省去的边都是尽可能大的边，或是那种导致回路的边，留下的边基本都是权重小的边，得到的就是最小生成树了（注意考试的时候只要按照我们的思路推是肯定没问题的，但是千万要仔细看，不要把边给看漏了，不然会出大问题）</p><p>我们接着来看另一种，克鲁斯卡尔算法，它的核心思想就是我们主动去选择那些小的边，而不是像上面一样被动地扩展延伸。</p><p>在一开始的时候，直接去掉所有的边，我们从这些边中一个一个选择出来（注意是任意一条边都可以选择，并不是只有选择的顶点旁边才能选择，这个过程中可能会出现多棵树，但是最后一定会连成一棵树的），最后形成一颗最小生成树，假设一开始什么都没选择，被选中的边我们一会用橙色标注：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/qdNyC6We2cZHTog.png" alt="image-20220903144403449"></p><p>首先我们直接找到最小边，K、F，它的权值为2，所以说直接选择就行：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/tTq2NnfJPcvogFG.png" alt="image-20220903144533239"></p><p>紧接着就是F、H的边，权重为3，目前最小的了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/MtJxvkjZoScT2KH.png" alt="image-20220903144828106"></p><p>此时最小的权重就只有4了，目前有4条边都可以进行选择，但是K、H这条边因为K和H都已经在树中了，所以说不能考虑，其他三条边都是没问题的，我们随便选择一条就行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/9vEVncqotmeklr7.png" alt="image-20220903145239074"></p><p>继续选择权重为4的边：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/BXZjrOTYfow51iD.png" alt="image-20220903145321395"></p><p>此时权重就来到了5，那么权重为5的顶点我们也可以随便选择一条，只要不会导致出现回路就行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/qUd8hiGnYyAZLo5.png" alt="image-20220903145431925"></p><p>此时连接G、I，我们发现出现了两棵树，没关系的，最后会连成一棵树的，我们继续选择其他权重为5的边：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/hpcVj8HwRJnvaf9.png" alt="image-20220903145551091"></p><p>此时我们选择A、E这条边，然后是H、I这条边，虽然这条边上的H和I顶点都已经在树中了，但是它们并不属于同一棵树，这种情况也是可以连接的，然后我们继续选择权重为6的顶点：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/Sltei9m4GdHXQkW.png" alt="image-20220903145828812"></p><p>此时选择I、J或是H、J都可以（最小生成树不唯一）现在我们已经连接上所有的顶点了，最小生成树构建完成，我们把那些没有选择都边都扔了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/eVyJ6o8xraRvl3d.png" alt="image-20220903143645249"></p><p>其实无论是哪种算法，最后都能够得到一棵最小生成树，有关实现代码，由于太过复杂，这里就不进行编写了。</p><h3 id="最短路径问题">最短路径问题</h3><p>前面我们介绍了最小生成树，通过两种算法就能够从众多的边中选择那些尽可能小的边得到一个权重最小的树，这一块我们将继续讨论最小开销相关的问题。</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/FuxnpoTNezYP9Aa.png" alt="image-20220903150609366"></p><p>地铁线路错综复杂，我们想要从一个站点坐到另一个站点，其实是有很多种方案的，比如我们可以选择少的换乘数放的方案，或是距离近的方案，不同的方案可能坐的站点数就不同，而最后我们出站时，始终是按照从A地点到B地点最小经过的站点数进行收费的（比如从A到B有两种方案，前者要坐11个站，后者要坐7个站，但是最后只会按7个站进行收费），那么这么多线路，我们要如何计算得到一条最短的路径呢？</p><p>我们首先从最简单的<strong>单源最短路径</strong>进行讨论，所谓单源最短路径，就是一个顶点出发，到其他顶点的最短路径，比如下面的这张图：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/6ABvydlgPUqEYIZ.png" alt="image-20220903153802247"></p><p>要解决这种问题，我们可以采用**迪杰斯特拉（Dijkstra）**算法，下面我们来看看迪杰斯特拉算法是如何让计算机来计算最短路径的，它跟普利姆算法求最小生成树有着很多相似之处，我们就从A出发，这里我们需要一个表来记录：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/cU2s1vRGq9SJkpE.png" alt="image-20220903195351496"></p><p>dist这一行记录A到其他顶点的最短路径，path这一行记录的是最短路径所邻接的顶点，我们首先还是从A开始，与A直接相邻的两个分别是B和D，其中B的距离是2，D的距离是5，那么我们就先进行一下记录：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/fxAocwRZFzSYgBb.png" alt="image-20220903195723929"></p><p>因为都是从A过来的，所以说直接记录为A即可，接着我们继续找到当前A路径最短的一个顶点B，此时顶点B可以到达C、D、A，因为不能走回头路，不考虑A，那么目前从A到达C的最短距离就是经过B到达的，相当于A-&gt;B加上B-&gt;C的距离：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/nbhD6gKrcWHZYwF.png" alt="image-20220903230103368"></p><p>然后我们来看顶点D，此时我们发现，除了A直接到D之外，从B也可以到达D，那么我们就可以比较一下，看是从B到D更短一些，还是从A直接到D更短一些 $min(2 + 2, 5)$ ，通过比较，我们发现从B绕过去会更短一些，只需要4即可，所以说我们将其更新一下：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/wZtX2eCvWciJ7mo.png" alt="image-20220903230254335"></p><p>接着我们继续找到下一个离A最近的顶点D，D与顶点E和J相连，直接更新即可，比如E的最短路径就是相当于是A到D的最短路径加上D到E的路径，D到J也是同理：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/RndcpoWkY6Oe84y.png" alt="image-20220903230521739"></p><p>此时继续找到表中下一个距离A最近的顶点J，J可以到达H或者是E，按照同样的方式，我们看看是从D直接到E更短，还是从J到E更短，进行比较 $min(6 + 3, 8)$ ，得到结果是D直接过去更短，所以说不需要更新。然后H更新为J过去的最短路径：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/d8qoaxZiymTGBlv.png" alt="image-20220903231152767"></p><p>我们接着来看下一个距离A最近的顶点C，此时C可以到达F和E，我们先来看E，还是对其进行比较，如果从C到达E更短，那么就更新为新的值，$min(7 + 4, 8)$，最后仍然是从D到E最短，所以说不变，接着我们把F的值更新一下：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/uknUSC2gK5adZjL.png" alt="image-20220903231449081"></p><p>然后我们来看下一个距离A最近的顶点E，E连接的就比较多了，此时E最短路径是从D过来的，那么我们就不考虑D，我们来依次看看与其相连的C、F、G、H、J（注意这里比较的是从E到这些顶点，之前比较的是从这些顶点到E，不要以为是一样的了）</p><ul><li>从E到达顶点C：$min(8 + 4, 7)$，故C继续采用原方案。</li><li>从E到达顶点F：$min(8 + 2, 15)$，此时从E到达F路径更短，更新F。</li><li>从E到达顶点G：直接更新。</li><li>从E到达顶点H：$min(8 + 6, 13)$，故H继续采用原方案。</li><li>从E到达顶点J：$min(8 + 3, 6)$，故J继续采用原方案。</li></ul><p>最后得到：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/Ek7nhJuXtKSZgeo.png" alt="image-20220903232316607"></p><p>我们继续来到下一个离A最近的顶点F，F连接了G和E，但是由于当前最短路径是从E过来的，不能走回头路，所以说直接去看G，比较 $min(10 + 5, 17)$，得到从F到达G会更短，所以说更新G：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/mphBFRsLArDQHwK.png" alt="image-20220903232542904"></p><p>然后我们接着看到下一个最短的顶点H，此时H与G和I相连，我们先来看G，$min(13 + 3, 15)$，维持原方案。然后是I，直接更新即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/PlHs4NE8JTiFZad.png" alt="image-20220903232752582"></p><p>虽然此时表已经填完了，但是我们还没有把所有的顶点都遍历完，有可能还会存在更短的路径，所以说别着急，我们还得继续看。此时继续选择下一个离A最近的顶点G，它与E、F、H、I相连，由于其实从F过来的，排除掉F，我们来看看其他三个：</p><ul><li>从G到达顶点E：$min(15 + 9, 8)$，显然选择原方案就行。</li><li>从G到达顶点H：$min(15 + 3, 13)$，依然是选择原方案更短。</li><li>从G到达顶点I：$min(15 + 4, 21)$，从G到达I更短，更新。</li></ul><p>最后得到：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/03/RL9XeTnAJBdUNMF.png" alt="image-20220903233144469"></p><p>此时我们来看最后一个顶点I，与其连接的有G和H，因为是从G过来的，直接比较H就行了，$min(19 + 8, 13)$，维持原方案就行，至此，迪杰斯特拉算法结束。最后得到的表，就是最终的A到达各个顶点的最短路径值了，并且根据path这一栏的数据，我们就可以直接推出一条路径出来。</p><p>当然，这只是解决了<strong>单源最短路径</strong>问题，现在我们将问题的难度提升一下，比如我们现在想要求得图中每一对顶点之间的最短路径，那么该如何进行计算呢？最简单的办法就是，我们可以将所有的顶点都执行一次迪杰斯特拉算法，这样我们就可以求到所有顶点之间的最短距离了。只不过这种方式并不是最好的选择，对于这种问题，我们可以选择<strong>弗洛伊德</strong>（Floyd）算法。</p><p>比如下面的有向网图（权值别出现负数了，不然要出大问题）：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/MdPc7Ew96Ukzxjt.png" alt="image-20220904094948962"></p><p>我们可以很轻松地得到它的邻接矩阵：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/ZQ7KvWeuJ6bdThx.png" alt="image-20220904101234641"></p><p>而弗洛伊德算法则是根据最初的邻接矩阵进行推导得出的。规则如下：</p><ul><li>从1开始，一直到n（n就是顶点数）的一个矩阵序列A1、A2、…An，我们需要从最初的邻接矩阵开始，从A1开始不断往后推。</li><li>每一轮，我们都会去更新那些非对角线（对角线都是0，更新了还是0，所以说没必要看）、<code>i</code>行<code>i</code>列以外的元素，判断水平和垂直方向投影的两个元素之和是否比原值小，如果是，那就更新为新的值。迭代公式为：$A_k(i,j)=min(A_{k−1}(i,j), A_{k−1}(i,k)+A_{k−1}(k,j))$</li><li>经历n轮后，最后得到的就是最终的最短距离了。</li></ul><p>我们从第一轮开始，第一轮是基于原有的邻接矩阵来进行处理的：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/czu5FEq8gGsRC97.png" alt="image-20220904102258851"></p><p>此时我们看到，除了对角线以外，就是B-&gt;C和C-&gt;B的这两个位置，我们按照上面的规则，进行计算：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/i3csRCQaxW17jV9.png" alt="image-20220904102738649"></p><p>同样的，我们继续看到C-&gt;B这个为止，按照同样的方式进行更新：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/TsIgShcqrdR3BaQ.png" alt="image-20220904103010762"></p><p>最后更新完成得到的结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/dObC8f2u6SqX4eT.png" alt="image-20220904103033008"></p><p>实际上我们发现，我们计算的和相当于是绕路的结果与当前直接走的结果相比较得到的。按照的同样的方式，我们开始第二轮：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/tXkEVLqR5dIchWT.png" alt="image-20220904103410691"></p><p>更新完成之后，C-&gt;A的距离变成了5：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/b9SGVFR6xEWBtgp.png" alt="image-20220904103549079"></p><p>我们接着来看最后一轮：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/alRYcGDp8xETLn1.png" alt="image-20220904103724239"></p><p>此时我们将A-&gt;B的距离也更新一下：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/Qwa2JMLXYBhnFsd.png" alt="image-20220904103815369"></p><p>最后我们得到的矩阵，存放的就是所有顶点之间的最短距离了，当然这里我们只计算了最短距离，没有去记录从哪个方向到达此顶点的，各位小伙伴也可以在计算的同时单独在另一个表中记录一下从哪个顶点过去计算出来的最小距离，这里就不演示了。实际上这个算法对我们来说是更好理解的一种算法，并且在编写程序时也会很简单，我们以下图为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/9fuBUwRYav4bghd.png" alt="image-20220904105442929"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 210000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">floyd</span><span class="params">(<span class="type">int</span> matrix[N][N], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)    <span class="comment">//一共需要执行K轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)   <span class="comment">//i和j从0开始就行了，直接全看，不会影响结果的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                matrix[i][j] = min(matrix[i][k] + matrix[k][j], matrix[i][j]);   <span class="comment">//按照规则更新就行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> matrix[N][N] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, INF, INF&#125;,</span><br><span class="line">                        &#123;<span class="number">4</span>, <span class="number">0</span>, INF, <span class="number">5</span>&#125;,</span><br><span class="line">                        &#123;INF, <span class="number">2</span>, <span class="number">0</span>, INF&#125;,</span><br><span class="line">                        &#123;<span class="number">3</span>, INF, <span class="number">7</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    floyd(matrix, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/mDWY8ZzqSipRGFa.png" alt="image-20220904110149836"></p><p>经过对比，确实是最短的路径了。</p><h3 id="拓扑排序">拓扑排序</h3><p>我们接着来看<strong>拓扑排序</strong>，实际上我们生活中可能会遇到下面的问题：</p><p>比如我们的大学课程的学习，一些课程开启可能需要修完一些前置课程，比如数据结构开课需要先修完C语言程序设计，Java开课需要修完计算机网络、计算机组成原理等课程，我们在到达某个阶段之前，需要完成一些前置条件才可以解锁。包括我们游戏中的任务，需要先完成哪些主线任务，完成哪些支线任务，才能解锁新的阶段。</p><p>我们可以将这些任务都看做是一个顶点，最后就能够连接成一个有向图：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/OoPBQgd9WrSJhNx.png" alt="image-20220904110937920"></p><p>因为始终是由前置条件来解锁后续，所以说整个图中是不可以出现循环的（要是有循环的话就没办法继续了，就像先有鸡还是先有蛋的问题一样）所以说构建出来的这种图我们也称为<strong>有向无环图</strong>（DAG），其实按照我们通俗的话来说，它就是个流程图罢了，我们只需要按照这个流程图来进行即可。像这种顶点表示活动或任务的图也称为<strong>AOV图</strong>。</p><p><strong>拓扑排序</strong>（Topological Order）是指，将一个有向无环图（Directed Acyclic Graph）进行排序进而得到一个有序的线性序列。</p><p>比如上图的拓扑排序可以是以下的几种：</p><ul><li>A,B,C,D,E,F,G,H,I,J</li><li>A,C,D,B,E,F,G,H,I,J</li><li>A,D,C,B,E,F,G,H,I,J</li><li>A,B,D,C,E,F,G,H,I,J</li></ul><p>只要我们保证前置任务在后续任务之前完成即可，前置任务的完成顺序不做要求，所以拓扑排序不唯一。</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/uMWBeLlzh9vHpdC.png" alt="image-20220904121459739"></p><p>那么我们在程序中如何对一个有向无环图进行拓扑排序呢？以上图为例，其实很简单，我们还是利用队列来完成，我们每次只需要将那些入度为0的顶点，丢进队列中（注意丢进去之后记得更新一下图中其他顶点的入度）首先从A：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/7bRdsEGLMqokZCf.png" alt="image-20220904122602140"></p><p>此时队列中有A这个顶点，接着我们来看看图中剩余的顶点，哪些又是入度为0的顶点，可以看到D也是：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/quj1yedrT69OQz3.png" alt="image-20220904122621668"></p><p>当目前所有度数为0的顶点进入队列之后，我们开始出队，正式开始拓扑排序，在出队时直接打印，并且查看，当此顶点离开图之后，图中会不会有其他顶点的入度变为0，如果有，将其他顶点入队。比如此时A出队之后，那么A要从图中移除，现在B也变成了入度为0的顶点，所以说将B丢进队列：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/23gdNArusypQS84.png" alt="image-20220904122914376"></p><p>接着，我们继续让D出队，我们发现D出队之后，E变成了入度为0的顶点，所以说将E入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/wjZ4TFslOL69IBA.png" alt="image-20220904123206951"></p><p>接着我们继续出队，B出队之后，我们发现没有任何顶点入度变为0了，所以说不管，继续：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/gWDMYimuxjFN45O.png" alt="image-20220904123257858"></p><p>继续将E出队，在E出队之后，顶点F、C都变成了入度为0的顶点，统统入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/uiXtEYK5aIWxNl4.png" alt="image-20220904123445483"></p><p>此时继续将C出队，我们发现没有任何顶点入队变为0，我们继续来看F：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/ue1dkjGcLKg3TCY.png" alt="image-20220904123544940"></p><p>当F出队后，顶点G变成了入度为0的顶点，此时将G入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/yqDC2BFQpElfz1L.png" alt="image-20220904123635522"></p><p>剩下就是把G出队，然后F入队F再出队了：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/2Na4UxFBJV6u3eR.png" alt="image-20220904123742305"></p><p>最后得到的拓扑序列为：ADBECFGH，其实思路还是比较简单的，当然，其实我们利用拓扑排序算法可以检测一个有向图是否为有向无环图，也就是说顶点还没遍历完队列就空了的话，说明一定出现了回路。</p><h3 id="关键路径计算">关键路径计算</h3><p>经过前面的学习，我们知道一个任务可能会存在前置任务，只不过我们仅仅是简单讨论了任务的完成顺序，如果此时我们为每个任务添加一个权重，表示任务所需要花费的时间，那么我们的后续任务就需要前置任务全部按时间完成之后才能继续：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/uUPRtKrGBbXlNHi.png" alt="image-20220904130014247"></p><p>比如A代表某个任务（事件），B代表另一个任务，我们需要先花费2天时间完成A之后，才能开始B，活动包括时间用边来表示，我们将边作为活动的图称为<strong>AOE图</strong>，每个事件对应着多个活动（多条边）它就像一个大工程一样，从A开始，中间需要经过各种各样的步骤，最后到H完工作为结束。</p><p>而我们需要计算的是那些最拖延工期的活动，比如要开始任务C，那么需要完成A、B才可以，完成A需要7天，完成B需要5天，由于C需要同时完成A和B才能继续，所以说A就变成了最拖延工期的任务，因为它的时间比B还长，B都完工了，还需要等待A完成才可以。只要计算出这些最拖延工期的任务，得到一条<strong>关键路径</strong>，我们就可以得到完成整个工程最早的时间以及各项任务可以在什么时候开工了。</p><p>我们来看看如何进行计算，我们以下图为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/E8UqCQoylmLMuZA.png" alt="image-20220904132328013"></p><p>我们需要计算两个东西，一个是<strong>事件最早完成时间</strong>（也就是要完成这个事件最快要多久），还有一个是<strong>事件最晚开始时间</strong>（就是这个事件在不影响工期的情况下最晚可以多久开始）：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/GeXishvJ5wmKUHW.png" alt="image-20220904132930050"></p><p>我们依然是按照之前的拓扑排序的顺序进行，首先一开始是A，因为只有一个起点A肯定是可以直接开始的，所以说最早和最晚时间都是0（注意如果出现多个起点的话，最晚开始时间就不一定了），我们接着AOE图的工作顺序，来计算任务B和C的最早和最晚时间：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/YFJonUm1x6H5AOl.png" alt="image-20220904133246766"></p><p>接着就是D和E，首先D需要B和C同时完工之后才能继续，那么也就是说需要选择B和C过来时间最长的那一个：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/qo1ZwWgSji45uv3.png" alt="image-20220904133658962"></p><p>最后就是F，到达F一共有三条路径，我们依然是选择最长的那一条，从D过来总共需要8天时间：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/M4UzkX9ePgtSV2c.png" alt="image-20220904133802361"></p><p>故整个工程的最早完成时间为8天，我们接着来看活动的最晚开始时间，现在我们要从终点倒着往回看：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/EsHI4DSYjWAVfvB.png" alt="image-20220904134114068"></p><p>首先终点一定是8，因为工期最快是在8天结束的，我们继续倒着往回走，先来看E，E需要6天才能到达，但是只需要1天就可以结束，所以 8 - 1 = 7，最晚可以在第7天时动工：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/8W2mo5D1vFN9ur6.png" alt="image-20220904134310369"></p><p>然后是D，因为D到F需要2天时间，而D已经是第6天了，总时间8天，所以说D刻不容缓，第6天就需要马上开工：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/mTkRZXpP8necDyf.png" alt="image-20220904134445037"></p><p>然后是C，C比较复杂，因为C有两个活动，一个是指向D的，一个是指向F的，我们需要单独计算每一个活动：</p><ul><li>C -&gt; F：用F的最晚开始时间减去任务时间 = 8 - 3 = 5，此时C最晚可以从第5天开始。</li><li>C -&gt; D：用D的最晚开始时间减去任务时间 = 6 - 4 = 2，此时因为C的最早开始时间就是2，所以说C不能晚点开始。</li></ul><p>综上，C不能晚点开始，只能从第2天就开始，因为要满足D的条件：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/7YbvfGVhlwO1yJR.png" alt="image-20220904135059487"></p><p>最后是B，B也是有两个任务，一个是指向E一个是指向D：</p><ul><li>B -&gt; E：用E的最晚开始时间减去任务时间 = 7 - 3 = 4，此时B最晚可以第4天开工。</li><li>B -&gt; D：用D的最晚开始时间减去任务时间 = 6 - 2 = 4，同上。</li></ul><p>所以，B的最晚开始时间可以是第4天：</p><p><img src="https://image.itbaima.cn/markdown/2022/09/04/oyInZ68SxJqYm5R.png" alt="image-20220904135338214"></p><p>当然最后我们也可以计算一下A -&gt; B和A -&gt; C，但是由于只有这一个起点，所以说算出来肯定是0，当然如果出现多个起点的情况，还需要进行计算得到的。</p><p>计算完成之后，我们就可以得到关键路径了，也就是那些最早和最晚时间都一样的顶点（说明是刻不容缓的，时间很紧）这些顶点连成的路线，就是我们要找的关键路径了：A -&gt; C -&gt; D -&gt; F，这条路径被安排的满满当当。关键路径上的所有活动都是<strong>关键活动</strong>，整个工期就是由这些活动在决定的，因此，我们可通过适当加快关键活动来缩短整个项目的工期，但是注意不能加快得太猛，因为如果用力过猛可能会导致关键路径发生变化。当然，关键路径并不是唯一的，可能会出现一样的情况。</p><p>至此，有关图结构相关的内容，我们就讲解到这里。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>散列表-数据结构与算法（三）</title>
    <link href="https://blog.yuncan.xyz/posts/s3.html"/>
    <id>https://blog.yuncan.xyz/posts/s3.html</id>
    <published>2023-07-02T12:39:43.000Z</published>
    <updated>2023-07-02T12:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/s_cover.jpg" alt="cover"></p><h1>散列表篇</h1><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。在最后我们还了解了B树和B+树，得益于它们的巧妙设计，我们可以以尽可能少的时间快速找到我们需要的元素，大大提升程序的运行效率。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们查找系列内容的最后一块重要知识。</p><h2 id="散列查找">散列查找</h2><p>我们之前认识的查找算法，最快可以达到对数阶 $O(logN)$，那么我们能否追求极致，让查找性能突破到常数阶呢？这里就要介绍到我们的<strong>散列</strong>（也可以叫哈希 Hash）它采用直接寻址的方式，在理想情况下，查找的时间复杂度可以达到常数阶 $O(1)$。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>当然，如果一脸懵逼没关系，我们从哈希函数开始慢慢介绍。</p><h3 id="散列函数">散列函数</h3><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf</span> *ideaIU-<span class="number">2022</span>.<span class="number">2</span>.<span class="number">1</span>.dmg</span><br></pre></td></tr></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><h3 id="散列表">散列表</h3><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们可以通过代码来实现一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Element</span> &#123;</span>   <span class="comment">//这里用一个Element将值包装一下</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//这里元素设定为int</span></span><br><span class="line">&#125; * E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//这里把数组封装为一个哈希表</span></span><br><span class="line">    E * table;</span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;   <span class="comment">//初始化函数</span></span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Element) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">        hashTable-&gt;table[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, E element)</span>&#123;   <span class="comment">//插入操作，为了方便就不考虑装满的情况了</span></span><br><span class="line">    <span class="type">int</span> hashCode = hash(element-&gt;key);   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    hashTable-&gt;table[hashCode] = element;   <span class="comment">//对号入座</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    <span class="keyword">if</span>(!hashTable-&gt;table[hashCode]) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果为NULL那就说明没有</span></span><br><span class="line">    <span class="keyword">return</span> hashTable-&gt;table[hashCode]-&gt;key == key;  <span class="comment">//如果有，直接看是不是就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">create</span><span class="params">(<span class="type">int</span> key)</span>&#123;    <span class="comment">//创建一个新的元素</span></span><br><span class="line">    E e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Element));</span><br><span class="line">    e-&gt;key = key;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">hashTable</span>;</span></span><br><span class="line">    init(&amp;hashTable);</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">10</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">7</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">29</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;hashTable, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;hashTable, <span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><h2 id="哈希冲突">哈希冲突</h2><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。</p><h3 id="线性探测法">线性探测法</h3><p>既然有可能出现哈希值重复的情况，那么我们可以选择退让，不去进行争抢（忍一时风平浪静，退一步海阔天空）我们可以去找找哈希表中相邻的位置上有没有为空的，只要哈希表没装满，那么我们肯定是可以找到位置装下这个元素的，这种类型的解决方案我们统称为<strong>线性探测法</strong>，开放定址法包含，线性探测法、平方探测法、双散列法等，这里我们以线性探测法为例。</p><p>既然第一次发生了哈希冲突，那么我们就继续去找下一个空位：<br>$$<br>h_i(key) = (h(key) + d_i)\space % \space TableSize<br>$$<br>其中 $d_i$ 是随着哈希冲突次数增加随之增加的量，比如上面出现了一次哈希冲突，那么我就将其变成<code>1</code>表示发生了一次哈希冲突，然后我们可以继续去寻找下一个位置：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/20/p5Qdni31eqFgzZ7.png" alt="image-20220820112822005"></p><p>出现哈希冲突时，$d_i$自增，继续寻找下一个空位：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/20/Ay6zkgivEFLthM8.png" alt="image-20220820113020326"></p><p>再次计算哈希值，成功得到对应的位置，注意 $d_i$ 默认为0，这样我们就可以解决冲突的情况了。</p><p>我们来通过代码实际使用一下，这里需要调整一下插入和查找操作的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, E element)</span>&#123;   <span class="comment">//插入操作，注意没考虑满的情况，各位小伙伴可以自己实现一下</span></span><br><span class="line">    <span class="type">int</span> hashCode = hash(element-&gt;key), count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hashTable-&gt;table[hashCode]) &#123;   <span class="comment">//如果发现哈希冲突，那么需要继续寻找</span></span><br><span class="line">        hashCode = hash(element-&gt;key + ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    hashTable-&gt;table[hashCode] = element;   <span class="comment">//对号入座</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key), count = <span class="number">0</span>;   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> startIndex = hashCode;   <span class="comment">//记录一下起始位置，要是转一圈回来了得停</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable-&gt;table[hashCode]-&gt;key == key) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//如果找到就返回1</span></span><br><span class="line">        hashCode = hash(key + ++count);</span><br><span class="line">    &#125; <span class="keyword">while</span> (startIndex != hashCode &amp;&amp; hashTable-&gt;table[hashCode]);  <span class="comment">//没找到继续找</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当出现哈希冲突时，会自动寻找补位插入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">hashTable</span>;</span></span><br><span class="line">    init(&amp;hashTable);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        insert(&amp;hashTable, create(i * <span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, hashTable.table[i]-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果采用这种方案删除会比较麻烦，因为有些元素可能是通过线性探测补到其他位置上的，如果删除元素，那么很有可能会影响到前面的查找操作：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/20/PJIVAUnhT6OwB9d.png" alt="image-20220820211324957"></p><p>此时删除关键字为45的元素，会出现截断的情况，当下次查找时，会出现严重问题：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/20/am6WHpejxtyU842.png" alt="image-20220820214945139"></p><p>可以看到，删除一个元素可能会导致原有的结构意外截断，无法正确找到对应的元素，所以，我们在删除元素时，为了防止出现这种截断的情况，我们需要对这个位置进行标记，表示之前有过元素，但是被删除了，当我们在查找时，如果发现曾经有过元素，依然需要继续向后寻找：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/20/hIBUbKvDjAfYruL.png" alt="image-20220820215613368"></p><p>代码实现有点麻烦，这里就不编写代码了。</p><p>当然除了直接向后进行探测之外，我们也可以采用<strong>二次探测再散列法</strong>处理哈希冲突，因为有些时候可能刚好后面没有空位了，但是前面有，如果按照之前的方法，我们得转一圈回来才能找到对应的位置，实在是有点浪费时间，所以说我们可以左右开弓，同时向两个方向去寻找。</p><p>它的查找增量序列为：$1^2$、$-1^2$、$2^2$、$-2^2$、…、$q^2$、$-q^2$，其中$q &lt;= \lfloor {TableSize\div2} \rfloor$，比如现在我们要向下面的哈希表中插入数据，现在插入关键字为24的元素，发现冲突了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/21/CTEFJVNmf47B3yq.png" alt="image-20220821214600725"></p><p>那么此时就需要进行处理了，这里我们采用上面的方式，先去寻找 $1^2$ 位置：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/21/QmiDsrnZjX8YUb6.png" alt="image-20220821214751809"></p><p>我们接着来插入：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/21/Wj9wYLPovF6pAOs.png" alt="image-20220821215445041"></p><p>实际上我们发现和之前是一样的，只要冲突就一直往下找就完事，只不过现在是左右横跳着找，这样可以进一步提升利用率。</p><h3 id="链地址法">链地址法</h3><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/BGSfF5vVIlDtaJz.png" alt="image-20230814161152299"></p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/E4dHUtzae3jl179.png" alt="image-20230814161208801"></p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><p>我们来编写代码尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span>   <span class="comment">//结点定义</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//哈希表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">table</span>;</span>   <span class="comment">//这个数组专门保存头结点</span></span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;</span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        hashTable-&gt;table[i].key = <span class="number">-1</span>;   <span class="comment">//将头结点key置为-1，next指向NULL</span></span><br><span class="line">        hashTable-&gt;table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span>    <span class="comment">//创建哈希表</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是编写对应的插入操作，插入后直接往链表后面丢就完事了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//创建结点专用函数</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;   <span class="comment">//先计算哈希值，找到位置后直接往链表后面插入结点就完事了</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) head = head-&gt;next;</span><br><span class="line">    head-&gt;next = createNode(key);   <span class="comment">//插入新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，查找的话也是直接找到对应位置，看看链表里面有没有就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next &amp;&amp; head-&gt;key != key)   <span class="comment">//直到最后或是找到为止</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;key == key;   <span class="comment">//直接返回是否找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line"></span><br><span class="line">    insert(&amp;table, <span class="number">10</span>);</span><br><span class="line">    insert(&amp;table, <span class="number">19</span>);</span><br><span class="line">    insert(&amp;table, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">17</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">19</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p><strong>散列表习题：</strong></p><ol><li><p>下面关于哈希查找的说法，正确的是（ ）</p><p>A 哈希函数构造的越复杂越好，因为这样随机性好，冲突小</p><p>B 除留余数法是所有哈希函数中最好的</p><p>C 不存在特别好与坏的哈希函数，要视情况而定</p><p>D 越简单的哈希函数越容易出现冲突，是最坏的</p><p><em>首先，衡量哈希函数好坏并没有一个确切的标准，而是需要根据具体情况而定，并不一定复杂的哈希函数就好，因为会带来时间上的损失。其实我们的生活中很多东西都像这样，没有好坏之分，只有适不适合的说法，所以说选择C选项</em></p></li><li><p>设有一组记录的关键字为{19，14，23，1，68，20，84，27，55，11，10，79}，用链地址法构造散列表，散列函数为H（key）=key MOD 13,散列地址为1的链中有（ ）个记录。</p><p>A 1             B 2               C 3                 D 4</p><p><em>这种咱们得画图才知道了，答案是D</em></p></li><li><p>设哈希表长为14，哈希函数是H(key)=key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的元素加到表中，用二次探测再散列解决冲突，则放入的位置是（ ）</p><p>A 8             B 3               C 5                 D 9</p><p><em>咱们先把这个表给画出来吧，答案是D</em></p></li><li><p>选取哈希函数 H(key)=(key x 3)%11 用线性探测散列法和二次探测再散列法分别处理冲突。试在0~10的散列地址空间中，对关键字序列（22,41,53,46,30,13,1,67）构建哈希表，并求等概率情况下查找成功的平均查找长度。</p><p><em>其中平均查找长度（ASL）就是表中每一个元素需要查找次数之和的平均值，我们注意在插入元素时顺便记录计算次数即可，如果是链地址法，那么直接看层数就行，ASL =（第一层结点数量+第二层结点数量+第三层结点数量）/ 非头结点总数</em></p></li></ol><h2 id="算法实战">算法实战</h2><h3 id="（简单）两数之和">（简单）两数之和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a>（整个力扣的第一题）</p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p></blockquote><p>这道题很简单，实际上使用暴力枚举是可以完成的，我们只需要让每个数去寻找一个与其匹配的数即可，所以说直接循环就完事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> * returnSize)</span>&#123;</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    result[<span class="number">0</span>] = i;</span><br><span class="line">    result[<span class="number">1</span>] = j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target) </span><br><span class="line">                <span class="keyword">return</span> result(i, j, returnSize);   <span class="comment">//找到匹配就直接返回完事</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//无视即可，因为不可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样效率实在是太低了，可以看到我们的程序运行时间都好几百毫秒了，能不能优化一下呢？我们正好学习了散列表，是否可以利用一下散列表来帮助我们完成？</p><p>因为每当我们遍历一个数时，实际上就是去寻找与其匹配的数是否存在，我们可以每遍历一个数都将其存放到散列表中，当下次遇到与其相匹配的数时，只要能够从散列表中找到这个数，那么就可以直接完成匹配了，这样就只需要遍历一次即可完成。比如：</p><blockquote><p>[2,7,11,15] ，targert = 9</p><p>第一次先将2放入散列表，接着往后看7，现在目标值时9，那么只需要去寻找 9 - 7 这个数，看看散列表中有没有即可，此时散列表中正好有2，所以说直接返回即可。</p></blockquote><p>我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> K;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span>   <span class="comment">//结点定义需要稍微修改一下，因为除了存关键字还需要存一下下标</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//哈希表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">table</span>;</span>   <span class="comment">//这个数组专门保存头结点</span></span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;</span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        hashTable-&gt;table[i].key = <span class="number">-1</span>;   <span class="comment">//将头结点key置为-1，value也变成-1，next指向NULL</span></span><br><span class="line">        hashTable-&gt;table[i].value = <span class="number">-1</span>;</span><br><span class="line">        hashTable-&gt;table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> key)</span>&#123;  <span class="comment">//因为哈希表用的数组，要是遇到负数的key，肯定不行，咱先给它把符号扬了再算</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">create</span><span class="params">(K key, V value)</span>&#123;   <span class="comment">//创建结点，跟之前差不多</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, K key, V value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) head = head-&gt;next;</span><br><span class="line">    head-&gt;next = create(key, value);   <span class="comment">//这里同时保存关键字和对应的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">find</span><span class="params">(HashTable hashTable, K key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;     <span class="comment">//直接定位到对应位置</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;key != key)   <span class="comment">//直接看有没有下一个结点，并且下一个结点不是key</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">//继续往后找</span></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;   <span class="comment">//出来之后要么到头了下一个是NULL，要么就是找到了，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表编写完成后，我们就可以使用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> * returnSize)</span>&#123;   <span class="comment">//跟上面一样</span></span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    result[<span class="number">0</span>] = i;</span><br><span class="line">    result[<span class="number">1</span>] = j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span>    <span class="comment">//初始化哈希表</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;   <span class="comment">//挨个遍历</span></span><br><span class="line">        Node node = find(&amp;table, target - nums[i]);  <span class="comment">//直接去哈希表里面寻找匹配的，如果有直接结束，没有就丢把当前的key丢进哈希表，之后如果遇到与其匹配的另一半，那么就直接成功了</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>) <span class="keyword">return</span> result(i, node-&gt;value, returnSize);</span><br><span class="line">        insert(&amp;table, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//无视就好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次提交代码，时间直接来到了个位数：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/21/pGF2hZo5ArbLyfB.png" alt="image-20220821122010425"></p><p>采用哈希表，就是一种空间换时间的策略，在大多数情况下，我们也更推荐使用这种方案。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>树形结构-数据结构与算法（二）</title>
    <link href="https://blog.yuncan.xyz/posts/s2.html"/>
    <id>https://blog.yuncan.xyz/posts/s2.html</id>
    <published>2023-06-29T10:33:14.000Z</published>
    <updated>2023-06-29T10:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/s_cover.jpg" alt="cover"></p><h1>树形结构篇</h1><p>前面我们学习了线性相关的数据结构，了解了顺序表和链表两种类型，我们接着来看树形结构。这一章会更加考验各位小伙伴的数学功底以及逻辑思维，难度会更大一些。</p><h2 id="树与森林">树与森林</h2><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://image.itbaima.cn/markdown/2022/08/08/NajFZzXHxUCDQBW.png" alt="image-20220808151202634"></p><h3 id="树结构介绍">树结构介绍</h3><p>一棵树就像下面这样连接：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><h3 id="森林">森林</h3><p>森林其实很好理解，一片森林肯定是是由很多棵树构成的，比如下面的三棵树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/VnblyMgQXkC6cBu.png" alt="image-20220801222928422"></p><p>它们共同组成了一片森林，因此，m（m≥0）棵树的集合我们称为<strong>森林</strong>（Forest）</p><hr><h2 id="二叉树">二叉树</h2><p>前面我们给大家介绍了树的概念，而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>二叉树有5种基本形态，分别是：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/8ncvzo6aLem14ju.png" alt="image-20220801224513856"></p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><h3 id="树和森林的转换">树和森林的转换</h3><p>二叉树和树、森林之间是可以相互转换的。</p><p>我们可以使用下面的规律将一棵普通的树转换为一棵二叉树：</p><ol><li>最左边孩子结点 -&gt; 左子树结点（左孩子）</li><li>兄弟结点 -&gt; 右子树结点（右孩子）</li></ol><p>我们以下面的这棵树为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/y51pTzhrQV3GPCJ.png" alt="image-20220806101322807"></p><p>我们优先从左边开始看，B、F、G都是A的子结点，根据上面的规律，我们将B作为左子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/g4XfmiQHaOy6JhG.png" alt="image-20220806101841459"></p><p>接着继续从左往右看，由于F是B的兄弟结点，那么根据规律，F作为B的右子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/6wqO4iErjQpyKzP.png" alt="image-20220806102023764"></p><p>接着是G，G是F的兄弟结点，那么G继续作为F的右子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/DfBsxVHlSotn6I3.png" alt="image-20220806102123476"></p><p>我们接着来看第三排，依然是从左往右，C是B的子节点，所以C作为B的左子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/93zFJGyx2SBLHC4.png" alt="image-20220806102501769"></p><p>接着，D是C的兄弟节点，那么D就作为C的右子树了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/YO5zf2TVHqBdnX6.png" alt="image-20220806102619705"></p><p>此时还有一个H结点，它是G的子结点，所以直接作为G的左子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/oHcAM6d2SFrveaE.png" alt="image-20220806102802036"></p><p>现在只剩下最后一排了，E是D的子结点，K是H的子结点，所以最后就像这样了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/6JxYP2CXSyZdGa4.png" alt="image-20220806102932517"></p><p>按照规律，我们就将一棵树转换为了二叉树。当然还有一种更简单的方法，我们可以直接将所有的兄弟结点连起来（橙色横线）：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/OSZ71J6CVEzeNiW.png" alt="image-20220807231603707"></p><p>接着擦掉所有结点除了最左边结点以外的连线：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/y62Z3UlaWdemI7v.png" alt="image-20220807231704465"></p><p>所有的黑色连线偏向左边，橙色连线偏向右边：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/yzA2uLqhYDnbZcJ.png" alt="image-20220807231922091"></p><p>效果是一样的，这两种方式都可以，你觉得哪一种简单就使用哪一种就行了。我们会发现，无论一棵树长成啥样，转换为二叉树后，<strong>根节点一定没有右子树</strong>。</p><p>**思考：**那二叉树咋变回普通的树呢？实际上我们只需要反推回去就行了。</p><p>那么森林呢，森林如何转换为一棵二叉树呢？其实很简单：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/08/QCIaYTcEv2NO47G.png" alt="image-20220808113135783"></p><p>首先我们还是按照二叉树转换为树的规则，将森林中所有树转换为二叉树，接着我们只需要依次连接即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/08/O3xnhv85WLPzJpq.png" alt="image-20220808113251636"></p><p>注意连接每一棵树的时候，一律从根结点的右边开始，不断向右连接。</p><p>我们发现，相比树转换为二叉树，森林转换为二叉树之后，根节点就存在右子树了，右子树连接的都是森林中其他的树。</p><p>**思考：**现在有一棵二叉树，我们想要转回去，我们怎么知道到底是将其转换为森林还是转换为树呢？</p><h3 id="二叉树的性质">二叉树的性质</h3><p>由于二叉树结构特殊，我们可以总结出以下的五个性质：</p><ul><li><p>**性质一：**对于一棵二叉树，第<code>i</code>层的最大结点数量为 $2^{i-1}$ 个，比如二叉树的第一层只有一个根结点，也就是 $2^0 = 1$ ，而二叉树的第三层可以有 $2^2 = 4$ 个结点。</p></li><li><p>**性质二：**对于一棵深度为<code>k</code>的二叉树，可以具有的最大结点数量为：<br>$$<br>n = 2^0 + 2^1 + 2^2 + … + 2^{k-1}<br>$$<br>我们发现，实际上每一层的结点数量，组成了一个等比数列，公比<code>q</code>为<code>2</code>，结合等比数列求和公式，我们可以将其简化为：<br>$$<br>S_n = \frac {a_1 \times (1 - q^n)} {1 - q} = \frac {1 \times (1 - 2^k)} {1 - 2} = - (1 - 2^k) = 2^k - 1<br>$$<br>所以一棵深度为<code>k</code>的二叉树最大结点数量为 $n = 2^k - 1$，顺便得出，结点的边数为 $E = n - 1$。</p></li><li><p><strong>性质三：<strong>假设一棵二叉树中度为0、1、2的结点数量分别为$n_0$、$n_1$、$n_2$，由于一棵二叉树中只有这三种类型的结点，那么可以直接得到结点总数：<br>$$<br>n = n_0 + n_1 + n_2<br>$$<br>我们不妨换一个思路，我们从二叉树的边数上考虑，因为每个结点有且仅有一条边与其父结点相连，那么边数之和就可以表示为：<br>$$<br>E = n_1 + 2n_2<br>$$<br>度为1的结点有一条边，度为2的结点有两条边，度为0的结点没有，加在一起就是整棵二叉树的边数之和，结合我们在</strong>性质二</strong>中推导的结果，可以得到另一种计算结点总数的方式：<br>$$<br>E = n - 1 = n_1 + 2n_2<br>$$</p><p>$$<br>n = n_1 + 2n_2 + 1<br>$$</p><p>再结合我们第一个公式：<br>$$<br>n = n_0 + n_1 + n_2 = n_1 + 2n_2 + 1<br>$$<br>综上，对于任何一棵二叉树，如果其叶子结点个数为 $n_0$ ，度为2的结点个数为 $n_2$ ，那么两者满足以下公式：<br>$$<br>n_0 = n_2 + 1<br>$$<br><em>（性质三的推导过程比较复杂，如果觉得麻烦推荐直接记忆）</em></p></li><li><p>**性质四：**完全二叉树除了最后一层有空缺外，其他层数都是饱满的，假设这棵二叉树为满二叉树，那么根据我们前面得到的性质，假设层数为<code>k</code>，那么结点数量为：$n = 2^k - 1$ ，根据完全二叉树的性质，最后一层可以满可以不满，那么一棵完全二叉树结点数<code>n</code>满足：<br>$$<br>2^{k-1} - 1 &lt; n &lt;= 2^k - 1<br>$$<br>因为<code>n</code>肯定是一个整数，那么可以写为：<br>$$<br>2^{k - 1} &lt;= n &lt;= 2^k - 1<br>$$<br>现在我们只看左边的不等式，我们对不等式两边同时取对数，得到：<br>$$<br>k - 1 &lt;= log_2n<br>$$<br>综上所述，一棵具有<code>n</code>个结点的完全二叉树深度为 $k = \lfloor log_2n \rfloor + 1$ 。</p><p><em>（性质四的推导过程比较复杂，如果觉得麻烦推荐直接记忆）</em></p></li><li><p>**性质五：**一颗有<code>n</code>个结点的完全二叉树，由性质四得到深度为 $k = \lfloor log_2n \rfloor + 1$ 现在对于任意一个结点<code>i</code>，结点的顺序为从上往下，从左往右：</p><ul><li>对于一个拥有左右孩子的结点来说，其左孩子为<code>2i</code>，右孩子为<code>2i + 1</code>。</li><li>如果<code>i = 1</code>，那么此结点为二叉树的根结点，如果<code>i &gt; 1</code>，那么其父结点就是 $\lfloor i/2 \rfloor$，比如第3个结点的父结点为第1个节点，也就是根结点。</li><li>如果<code>2i &gt; n</code>，则结点<code>i</code>没有左孩子，比如下面图中的二叉树，n为5，假设此时<code>i = 3</code>，那么<code>2i = 6 &gt; n = 5</code> 说明第三个结点没有左子树。</li><li>如果<code>2i + 1 &gt; n</code>，则结点<code>i</code>没有右孩子。</li></ul></li></ul><p><img src="https://image.itbaima.cn/markdown/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>以上五条二叉树的性质一般是笔试重点内容，还请务必牢记，如果觉得推导过程比较麻烦，推荐直接记忆结论。</p><p><strong>二叉树练习题：</strong></p><ol><li><p><strong>由三个结点可以构造出多少种不同的二叉树？</strong></p><p><em>这个问题我们可以直接手画得到结果，一共是五种，当然，如果要求N个结点的话，可以利用动态规划求解，如果这道题是求N个结点可以构造多少二叉树，我们可以分析一下：</em></p><ul><li>假设现在只有一个结点或者没有结点，那么只有一种，$h(0) = h(1) = 1$</li><li>假设现在有两个结点，那么其中一个拿来做根结点，剩下这一个可以左边可以右边，要么左边零个结点右边一个结点，要么左边一个结点右边零个结点，所以说 $h(2) = h(1) × h(0) + h(0) × h(1) = 2$</li><li>假设现在有三个结点，那么依然是其中一个拿来做根节点，剩下的两个结点情况就多了，要么两个都在左边，两个都在右边，或者一边一个，所以说 $h(3) = h(2) × h(0) + h(1) × h(1) + h(0) × h(2)$</li></ul><p><em>我们发现，它是非常有规律的，N每+1，项数多一项，所以我们只需要按照规律把所有情况的结果相加就行了，我们按照上面推导的结果，编写代码：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);   <span class="comment">//读取需要求的N</span></span><br><span class="line">    <span class="type">int</span> dp[size + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">//没有结点或是只有一个结点直接得到1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;   <span class="comment">//一开始先等于0再说</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;   <span class="comment">//内层循环是为了计算所有情况，比如i等于3，那么就从j = 0开始，计算dp[0]和dp[2]的结果，再计算dp[1]和dp[1]...</span></span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[size]);   <span class="comment">//最后计算的结果就是N个结点构造的二叉树数量了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/08/DIHPQcxgbVXLaYK.png" alt="image-20220808121124094"></p><p><em>成功得到结果，当然，实际上我们根据这个规律，还可以将其进一步简化，求出的结果序列为：1, 1, 2, 5, 14, 42, 132…，这种类型的数列我们称为<strong>卡特兰数</strong>，以中国蒙古族数学家明安图 (1692-1763)和比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名，它的通项公式为：</em><br>$$<br>C_n = \frac {1} {n + 1}C^n_{2n} = \frac {1} {n + 1} \times \frac {(2n)!} {n!\times(2n - n)!} = \frac {(2n)!} {n!\times (n + 1)!}<br>$$<br><em>所以说不需要动态规划了，直接一个算式解决问题：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) res *= i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, factorial(<span class="number">2</span>*n) / (factorial(n) * factorial(n + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>只不过这里用的是int，运算过程中如果数字太大的话就没办法了</em></p></li><li><p><strong>一棵完全二叉树有1001个结点，其中叶子结点的个数为？</strong></p><p><em>既然是完全二叉树，那么最下面这一排肯定是按顺序排的，并且上面各层应该是排满了的，那么我们先求出层数，根据性质四：</em><br>$$<br>k = \lfloor log_2n \rfloor + 1 = 9 + 1 = 10<br>$$<br><em>所以此二叉树的层数为10，也就是说上面9层都是满满当当的，最后一层不满，那么根据性质二，我们求出前9层的结点数：</em><br>$$<br>n = 2^k - 1 = 511<br>$$<br><em>那么剩下的结点就都是第十层的了，得到第十层所有叶子结点数量 $ = 1001 - 511 = 490$，因为第十层并不满，剩下的叶子第九层也有，所以最后我们还需要求出第九层的叶子结点数量，先计算第九层的所有结点数量：</em><br>$$<br>n = 2^{i - 1}=256<br>$$<br><em>接着我们需要去掉那些第九层度为一和度为二的结点，其实只需要让第十层都叶子结点除以2就行了：</em><br>$$<br>n = (490 + 1) / 2 = 245<br>$$<br><em>注意在除的时候+1，因为有可能会出现一个度为1的结点，此时也需要剔除，所以说+1变成偶数这样才可以正确得到结果。最后剔除这些结点，得到最终结果：</em><br>$$<br>n_0 = 256 - 245 + 490 = 501<br>$$<br><em>所以这道题的答案为501。</em></p></li><li><p><strong>深度为h的满m叉树的第k层有多少个结点？</strong></p><p><em>这道题只是看着复杂，但是实际上我们把之前推导都公式带进来就行了。但是注意，难点在于，这道题给的是满m叉树，而不是满二叉树，满二叉树根据性质一我们已经知道：</em><br>$$<br>n = 2^{i-1}<br>$$<br>那m叉树呢？实际上也是同理的，我们以三叉树为例，每向下一层，就划分三个孩子结点出来：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/08/XvH4At8Q93nkFIR.png" alt="image-20220808131305843"></p><p>每一层的最大结点数依次为：1、3、9、27…</p><p>我们发现，实际上每一层的最大结点数，正好是3的次方，所以说无论多少叉树，实际上变化的就是底数而已，所以说深度为h（h在这里没卵用，障眼法罢了）的满m叉树第k层的结点数：<br>$$<br>n = m^{k-1}<br>$$</p></li><li><p><strong>一棵有1025个结点的二叉树的层数k的取值范围是？</strong></p><p><em>这个问题比较简单，层数的最小值实际上就是为完全二叉树的情况，层数的最大值实际上就是连成一根线的情况，结点数就是层数，所以说根据性质四得到最小深度为11，最大深度就直接1025了，k的范围是11 - 1025</em></p></li><li><p><strong>将一棵树转换为二叉树时，根节点的右边连接的是？</strong></p><p><em>根据我们前面总结得到的性质，树转换为二叉树之后，根节点一定没有右子树，所以为空</em></p></li></ol><h3 id="二叉树的构建">二叉树的构建</h3><p>前面我们介绍了二叉树的几个重要性质，那么现在我们就来尝试在程序中表示和使用一棵二叉树。</p><p>二叉树的存储形式也可以使用我们前面的两种方式，一种是使用数组进行存放，还有一种就是使用链式结构，只不过之前链式结构需要强化一下才可以表示为二叉树。</p><p>首先我们来看数组形式的表示方式，利用前面所推导的性质五，我们可以按照以下顺序进行存放：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>这颗二叉树的顺序存储：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/jTtvWahxI9VUKuG.png" alt="image-20220806110546789"></p><p>从左往右，编号<code>i</code>从1开始，比如现在我们需要获取A的右孩子，那么就需要根据性质五进行计算，因为右孩子为<code>2i + 1</code>，所以A的右边孩子的编号就是3，也就是结点C。</p><p>这种表示形式使用起来并不方便，而且存在大量的计算，所以说我们只做了解即可，我们的重点是下面的链式存储方式。</p><p>我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的指针：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的指针和一个指向右子树的指针了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;    <span class="comment">//存放元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span>   <span class="comment">//指向左子树的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span>   <span class="comment">//指向右子树的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Node a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));   <span class="comment">//依次创建好这五个结点</span></span><br><span class="line">    Node b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node d = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">  a-&gt;element = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    b-&gt;element = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    c-&gt;element = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    d-&gt;element = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    e-&gt;element = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;   <span class="comment">//A的左孩子是B</span></span><br><span class="line">    a-&gt;right = c;   <span class="comment">//A的右孩子是C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是B这个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    b-&gt;left = d;   <span class="comment">//B的左孩子是D</span></span><br><span class="line">    b-&gt;right = e;   <span class="comment">//B的右孩子是E</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//别忘了把其他的结点改为NULL</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就成功构建好了这棵二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a-&gt;left-&gt;left-&gt;element);   <span class="comment">//比如现在我想要获取A左孩子的左孩子，那么就可以直接left二连</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/oTPeUpBlmNsZWE1.png" alt="image-20220806113156166"></p><h3 id="二叉树的遍历">二叉树的遍历</h3><p>前面我们通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：**前序遍历、中序遍历、后序遍历、层序遍历。**不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。</p><p>接着我们来通过代码实现一下，首先先把咱们这棵二叉树组装好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Node a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node d = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    a-&gt;element = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    b-&gt;element = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    c-&gt;element = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    d-&gt;element = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    e-&gt;element = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    f-&gt;element = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;</span><br><span class="line">    a-&gt;right = c;</span><br><span class="line">    b-&gt;left = d;</span><br><span class="line">    b-&gt;right = e;</span><br><span class="line">    c-&gt;right = f;</span><br><span class="line">    c-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    d-&gt;left = e-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    e-&gt;left = e-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;left = f-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装好之后，我们来实现一下前序遍历的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;   <span class="comment">//传入的是二叉树的根结点</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在我们拿到根结点之后该怎么去写呢？既然是走到哪里打印到哪里，那么我们就先打印一下当前结点的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//不多bb先打印再说</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);</span><br><span class="line">    preOrder(root-&gt;left);   <span class="comment">//将左孩子结点递归交给下一级</span></span><br><span class="line">    preOrder(root-&gt;right);  <span class="comment">//等上面的一系列向左递归结束后，再以同样的方式去到右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还没，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   <span class="comment">//如果走到NULL了，那就表示已经到头了，直接返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">    preOrder(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>当然也有非递归的写法，我们使用循环，但是就比较麻烦了，我们需要使用栈来帮助我们完成（实际上递归写法本质上也是在利用栈），我们依然是从第一个结点开始，先走左边，每向下走一步，先输出节点的值，然后将对应的结点丢到栈中，当走到尽头时，表示左子树已经遍历完成，接着就是从栈中依次取出栈顶节点，如果栈顶结点有右子树，那么再按照同样的方式遍历其右子树，重复执行上述操作，直到栈清空为止。</p><ul><li>一路向左，不断入栈，直到尽头</li><li>到达尽头后，出栈，看看有没有右子树，如果没有就继续出栈，直到遇到有右子树的为止</li><li>拿到右子树后，从右子树开始，重复上述步骤，直到栈清空</li></ul><p>比如我们还是以上面的这棵树为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>首先我们依然从根结点A出发，不断遍历左子树，沿途打印结果并将节点丢进栈中：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/e1Nf5WhQdY9VGOD.png" alt="image-20220806215229564"></p><p>当遍历到D结点时，没有左子树了，此时将栈顶结点D出栈，发现没有右节点，继续出栈，得到B结点，接着得到当前结点的右孩子E结点，然后重复上述步骤：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/pZ6FRWn9wNg1JhY.png" alt="image-20220806220752941"></p><p>接着发现E也没有左子树了，同样的，又开始出栈，此时E没有右子树，接着看A，A有右子树，所以继续从C开始，重复上述步骤：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/K73cGsRUP6WO5iu.png" alt="image-20220806221147022"></p><p>由于C之后没有左子树，那么就出栈获取右子树，此时得到结点F，继续重复上述步骤：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/zkZisVY9H2qAafL.png" alt="image-20220806221239705"></p><p>最后F出栈，没有右子树了，栈空，结束。</p><p>按照这个思路，我们来编写一下程序吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 栈 -------------------</span></span><br><span class="line"><span class="keyword">typedef</span> Node T;   <span class="comment">//这里栈内元素类型定义为上面的Node，也就是二叉树结点指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> * <span class="title">SNode</span>;</span>  <span class="comment">//这里就命名为SNode，不然跟上面冲突了就不好了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(SNode head, T element)</span>&#123;</span><br><span class="line">    SNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> StackNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">popStack</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    SNode top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    T e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span>  <span class="comment">//栈先搞出来</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//两个条件，只有当栈空并且节点为NULL时才终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;    <span class="comment">//按照我们的思路，先不断遍历左子树，直到没有为止</span></span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);   <span class="comment">//途中每经过一个结点，就将结点丢进栈中</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//然后打印当前结点元素值</span></span><br><span class="line">            root = root-&gt;left;  <span class="comment">//继续遍历下一个左孩子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = popStack(&amp;<span class="built_in">stack</span>);  <span class="comment">//经过前面的循环，明确左子树全部走完了，接着就是右子树了</span></span><br><span class="line">        root = root-&gt;right;  <span class="comment">//得到右孩子，如果有右孩子，下一轮会重复上面的步骤；如果没有右孩子那么这里的root就被赋值为NULL了，下一轮开始会直接跳过上面的while，继续出栈下一个结点再找右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就通过非递归的方式实现了前序遍历，可以看到代码是相当复杂的，也不推荐这样编写。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);  <span class="comment">//先完成全部左子树的遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//等待左子树遍历完成之后再打印</span></span><br><span class="line">    inOrder(root-&gt;right);   <span class="comment">//然后就是对右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>同样的，如果采用的是非递归，那么我也只需要稍微改动一个地方即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//其他都不变</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = popStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//只需要将打印时机延后到左子树遍历完成</span></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//时机延迟到最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>不过难点来了，后序遍历使用非递归貌似写不了啊？因为按照我们的之前的思路，最多也就实现中序遍历，我们没办法在一次循环中得知右子树是否完成遍历，难点就在这里。那么我们就要想办法先让右子树完成遍历，由于一个结点需要左子树全部完成+右子树全部完成，而目前只能明确左子树完成了遍历（也就是内层while之后，左子树一定结束了）所以我们可以不急着将结点出栈，而是等待其左右都完事了再出栈，这里我们需要稍微对结点的结构进行修改，添加一个标记变量，来表示已经完成左边还是左右都完成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> flag;   <span class="comment">//需要经历左右子树都被遍历才行，这里用flag存一下状态，0表示左子树遍历完成，1表示右子树遍历完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">peekStack</span><span class="params">(SNode head)</span>&#123;   <span class="comment">//这里新增一个peek操作，用于获取栈顶元素的值，但是不出栈，仅仅是值获取</span></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//其他都不变</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);</span><br><span class="line">            root-&gt;flag = <span class="number">0</span>;    <span class="comment">//首次入栈时，只能代表左子树遍历完成，所以flag置0</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = peekStack(&amp;<span class="built_in">stack</span>);   <span class="comment">//注意这里只是获取到结点，并没有进行出栈操作，因为需要等待右子树遍历完才能出栈</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;flag == <span class="number">0</span>) &#123;    <span class="comment">//如果仅仅遍历了左子树，那么flag就等于0</span></span><br><span class="line">            root-&gt;flag = <span class="number">1</span>;   <span class="comment">//此时标记为1表示遍历右子树</span></span><br><span class="line">            root = root-&gt;right;   <span class="comment">//这里跟之前是一样的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//当flag为1时走这边，此时左右都遍历完成了，这时再打印值出来</span></span><br><span class="line">            popStack(&amp;<span class="built_in">stack</span>);   <span class="comment">//这时再把对应的结点出栈，因为左右都完事了</span></span><br><span class="line">            root = <span class="literal">NULL</span>;   <span class="comment">//置为NULL，下一轮直接跳过while，然后继续取栈中剩余的结点，重复上述操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，后序遍历的非递归写法的最大区别是将结点的出栈时机和打印时机都延后了。</p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的。</p><p>那么现在我们就来上代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------- 队列 ----------------</span></span><br><span class="line"><span class="keyword">typedef</span> Node T;   <span class="comment">//还是将Node作为元素</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">QNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QNode front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">LinkedQueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">pollQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    T e = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;element;</span><br><span class="line">    QNode node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front-&gt;next = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;rear == node) <span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span>   <span class="comment">//先搞一个队列</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, root);  <span class="comment">//先把根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>)) &#123;   <span class="comment">//不断重复，直到队列空为止</span></span><br><span class="line">        Node node = pollQueue(&amp;<span class="built_in">queue</span>);   <span class="comment">//出队一个元素，打印值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)    <span class="comment">//如果存在左右孩子的话</span></span><br><span class="line">            offerQueue(&amp;<span class="built_in">queue</span>, node-&gt;left);  <span class="comment">//记得将左右孩子入队，注意顺序，先左后右</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            offerQueue(&amp;<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><p><strong>二叉树练习题：</strong></p><ol><li><p>现在有一棵二叉树前序遍历结果为：ABCDE，中序遍历结果为：BADCE，那么请问该二叉树的后序遍历结果为？</p></li><li><p>对二叉树的结点从1开始连续进行编号，要求每个结点的编号大于其左右孩子的编号，那么请问需要采用哪种遍历方式来实现？</p><p>A. 前序遍历      B. 中序遍历      <strong>C. 后序遍历</strong>     D. 层序遍历</p></li></ol><hr><h2 id="高级树结构">高级树结构</h2><p>高级树结构篇是对树结构的延伸扩展，有着特殊的定义和性质，在编写上可能会比较复杂，所以这一部分对于那些太过复杂的结构，就不进行代码编写了，只进行理论讲解。</p><h3 id="线索化二叉树">线索化二叉树</h3><p>前面我们学习了二叉树，我们知道一棵二叉树实际上可以由多个结点组成，每个结点都有一个左右指针，指向其左右孩子。我们在最后也讲解了二叉树的遍历，包括前序、中序、后序以及层序遍历。只不过在遍历时实在是太麻烦了，我们需要借助栈来帮助我们完成这项遍历操作。</p><p>实际上我们发现，一棵二叉树的某些结点会存在NULL的情况，我们可以利用这些为NULL的指针，将其线索化为某一种顺序遍历的指向下一个按顺序的结点的指针，这样我们在进行遍历的时候，就会很方便了。</p><p>例如，一棵二叉树的前序遍历顺序如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/ZRjFywa6kWHrbJY.png" alt="image-20220814145531577"></p><p>我们就可以将其进行线索化，首先还是按照前序遍历的顺序依次寻找：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/Wu954jeLJhbxXDr.png" alt="image-20220814150731326"></p><p>线索化的规则为：</p><ul><li>结点的左指针，指向其当前遍历顺序的前驱结点。</li><li>结点的右指针，指向其当前遍历顺序的后继结点。</li></ul><p>所以在线索化之后，G的指向情况如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/ExhJStz4eMoCRF1.png" alt="image-20220814151342130"></p><p>这样，G原本两个为NULL的指针就被我们利用起来了，但是现在有一个问题，我们怎么知道，某个结点的指针到底是指向的其左右孩子，还是说某种遍历顺序下的前驱或是后继结点呢？所以，我们还需要分别为左右添加一个标志位，来表示左右指针到底指向的是孩子还是遍历线索：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> leftTag, rightTag;   <span class="comment">//标志位，如果为1表示这一边指针指向的是线索，不为1就是正常的孩子结点</span></span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>接着是H结点，同样的，因为H结点的左右指针都是NULL，那么我们也可以将其线索化：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/pVo6FHquyBWmS7f.png" alt="image-20220814152008732"></p><p>接着我们来看结点E，这个结点只有一个右孩子，没有左孩子，左孩子指针为NULL，我们也可以将其线索化：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/2nUPAuVOvcQKw7L.png" alt="image-20220814152117861"></p><p>最后，整棵二叉树完成线索化之后，除了遍历顺序的最后一个结点没有后续之外，其他为NULL的指针都被利用起来了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/SpWPAbzXRFcOgZJ.png" alt="image-20220814152341658"></p><p>我们可以发现，在利用上那些为NULL的指针之后，当我们再次进行前序遍历时，我们不需要再借助栈了，而是可以一路向前。</p><p>这里我们弄一个简单一点的线索化二叉树，来尝试对其进行遍历：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/E1YyemquOdasTRi.png" alt="image-20220814152703468"></p><p>首先我们要对这棵二叉树进行线索化，将其变成一棵线索化二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;   <span class="comment">//单独写了个函数来创建结点</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;rightTag = node-&gt;leftTag = <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node a = createNode(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    Node b = createNode(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    Node c = createNode(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    Node d = createNode(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    Node e = createNode(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;</span><br><span class="line">    b-&gt;left = d;</span><br><span class="line">    a-&gt;right = c;</span><br><span class="line">    b-&gt;right = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上要将其进行线索化，我们只需要正常按照对应的遍历顺序进行即可，不过在遍历过程中需要留意那些存在空指针的结点，我们需要修改其指针的指向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//别急着写打印</span></span><br><span class="line">    preOrderThreaded(root-&gt;left);</span><br><span class="line">    preOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还是老规矩，先把前序遍历写出来，然后我们需要进行判断，如果存在指针指向为NULL，那么就将其线索化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;   <span class="comment">//首先判断当前结点左边是否为NULL，如果是，那么指向上一个结点</span></span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;  <span class="comment">//记得修改标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;  <span class="comment">//然后是判断上一个结点的右边是否为NULL，如果是那么进行线索化，指向当前结点</span></span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;  <span class="comment">//记得修改标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre = root;   <span class="comment">//每遍历完一个，需要更新一下pre，表示上一个遍历的结点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)   <span class="comment">//注意只有标志位是0才可以继续向下，否则就是线索了</span></span><br><span class="line">    preOrderThreaded(root-&gt;left);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">    preOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在我们进行二叉树的遍历时，会自动将其线索化，线索化完成之后就是一棵线索化二叉树了。</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/kxhAsiWCSYMdB7q.png" alt="image-20220814154539765"></p><p>可以看到结点D的左右标记都是1，说明都被线索化了，并且D的左边指向的是其前一个结点B，右边指向的是后一个结点E，这样我们就成功将其线索化了。</p><p>现在我们成功得到了一棵线索化之后的二叉树，那么怎么对其进行遍历呢？我们只需要一个简单的循环就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;  <span class="comment">//前序遍历一棵线索化二叉树非常简单</span></span><br><span class="line">    <span class="keyword">while</span> (root) &#123;   <span class="comment">//到头为止</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//因为是前序遍历，所以直接按顺序打印就行了</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>) </span><br><span class="line">            root = root-&gt;left;   <span class="comment">//如果是左孩子，那么就走左边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;right;   <span class="comment">//如果左边指向的不是孩子，而是线索，那么就直接走右边，因为右边无论是线索还是孩子，都要往这边走了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看看中序遍历的线索化二叉树，整个线索化过程我们只需要稍微调整位置就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;left);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//------  线索化 -------  现在放到中间去，其他的还是一样的</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们线索化完成之后，长这样了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/tsEJLRFCYVaTOP8.png" alt="image-20220814161529021"></p><p>那么像这样的一棵树，我们怎么对其进行遍历呢？中序遍历要稍微麻烦一些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;   <span class="comment">//因为中序遍历需要先完成左边，所以说要先走到最左边才行</span></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; root-&gt;leftTag == <span class="number">0</span>)    <span class="comment">//如果左边一直都不是线索，那么就一直往左找，直到找到一个左边是线索的为止，表示到头了</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//到最左边了再打印，中序开始</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; root-&gt;rightTag == <span class="number">1</span>) &#123;   <span class="comment">//打印完就该右边了，右边如果是线索化之后的结果，表示是下一个结点，那么就一路向前，直到不是为止</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//注意按着线索往下就是中序的结果，所以说沿途需要打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;right;  <span class="comment">//最后继续从右结点开始，重复上述操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来看看后序遍历的线索化，同样的，我们只需要在线索化时修改为后序就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;right);</span><br><span class="line">    <span class="comment">//------  线索化 -------   现在这一坨移到最后，就是后序遍历的线索化了</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线索化完成之后，变成一棵后续线索化二叉树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/Smqt1UKjeWXFRPu.png" alt="image-20220814162606692"></p><p>后序遍历的结果看起来有点怪怪的，但是这就是后序，那么怎么对这棵线索化二叉树进行后续遍历呢？这就比较复杂了。首先后续遍历需要先完成左右，左边还好说，关键是右边，右边完事之后我们并不一定能找到对应子树的根结点，比如我们按照上面的线索，先从D开始，根据线索找到E，然后继续跟据线索找到B，但是此时B无法找到其兄弟结点C，所以说这样是行不通的，因此要完成后续遍历，我们只能对结点进行改造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">parent</span>;</span>   <span class="comment">//指向双亲（父）结点</span></span><br><span class="line">    <span class="type">int</span> leftTag, rightTag;</span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>现在每个结点都保存其父结点，这样就可以顺利地找上去了。现在我们来编写一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>) &#123;</span><br><span class="line">        postOrderThreaded(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;parent = root;  <span class="comment">//左边完事之后，如果不为空，那么就设定父子关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>) &#123;</span><br><span class="line">        postOrderThreaded(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;parent = root;   <span class="comment">//右边完事之后，如果不为空，那么就设定父子关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------  线索化 -------</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    Node last = <span class="literal">NULL</span>, node = root;  <span class="comment">//这里需要两个暂存指针，一个记录上一次遍历的结点，还有一个从root开始</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != last &amp;&amp; node-&gt;leftTag == <span class="number">0</span>)    <span class="comment">//依然是从整棵树最左边结点开始，和前面一样，只不过这里加入了防无限循环机制，看到下面就知道了</span></span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node-&gt;rightTag == <span class="number">1</span>) &#123;   <span class="comment">//左边完了还有右边，如果右边是线索，那么直接一路向前，也是跟前面一样的</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);   <span class="comment">//沿途打印</span></span><br><span class="line">            last = node;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == root &amp;&amp; node-&gt;right == last) &#123;</span><br><span class="line">            <span class="comment">//上面的操作完成之后，那么当前结点左右就结束了，此时就要去寻找其兄弟结点了，我们可以</span></span><br><span class="line">            <span class="comment">//直接通过parent拿到兄弟结点，但是如果当前结点是根结点，需要特殊处理，因为根结点没有父结点了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);</span><br><span class="line">            <span class="keyword">return</span>;   <span class="comment">//根节点一定是最后一个，所以说直接返回就完事</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node-&gt;right == last) &#123;    <span class="comment">//如果当前结点的右孩子就是上一个遍历的结点，那么一直向前就行</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);   <span class="comment">//直接打印当前结点</span></span><br><span class="line">            last = node;</span><br><span class="line">            node = node-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里只有一种情况了，是从左子树上来的，那么当前结点的右边要么是线索要么是右子树，所以直接向右就完事</span></span><br><span class="line">        <span class="keyword">if</span>(node &amp;&amp; node-&gt;rightTag == <span class="number">0</span>) &#123;  <span class="comment">//如果不是线索，那就先走右边，如果是，等到下一轮再说</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，有关线索化二叉树，我们就讲解到这样。</p><h3 id="二叉查找树">二叉查找树</h3><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>因为二叉搜索树要求比较严格，所以我们在插入结点时需要遵循一些规律，这里我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就以上面这颗二叉查找树为例，现在我们想要依次插入这些结点，我们需要编写一个特殊的插入操作，这里需要注意一下，二叉查找树不能插入重复元素，如果出现重复直接忽略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">insert</span><span class="params">(Node root, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;element &gt; element)    <span class="comment">//如果插入结点值小于当前结点，那么说明应该放到左边去</span></span><br><span class="line">            root-&gt;left = insert(root-&gt;left, element);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; element)    <span class="comment">//如果插入结点值大于当前结点，那么说明应该放到右边去</span></span><br><span class="line">            root-&gt;right = insert(root-&gt;right, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">//当结点为空时，说明已经找到插入的位置了，创建对应结点</span></span><br><span class="line">        root = createNode(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;   <span class="comment">//返回当前结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过不断插入创建一棵二叉查找树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;element);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    inOrder(root);   <span class="comment">//用中序遍历查看一下结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照顺序来，首先是根结点的左右孩子，分别是10和20，那么这里我们就依次插入一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    insert(root, <span class="number">10</span>);</span><br><span class="line">    insert(root, <span class="number">20</span>);</span><br><span class="line">    inOrder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到中序结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/FlLRBprEezot5Z8.png" alt="image-20220815094708456"></p><p>比18小的结点在左边，大的在右边，满足二叉查找树的性质。接着是7、15、22：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/chEUaOBzCTl4N8G.png" alt="image-20220815094823646"></p><p>最后再插入9就是我们上面的这棵二叉查找树了。当然我们直接写成控制台扫描的形式，就更方便了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        E element;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;element);</span><br><span class="line">        root = insert(root, element);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么插入写好之后，我们怎么找到对应的结点呢？实际上也是按照规律来就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">find</span><span class="params">(Node root, E target)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;element &gt; target)    <span class="comment">//如果要找的值比当前结点小，说明肯定在左边</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; target)   <span class="comment">//如果要找的值比当前结点大，说明肯定在右边</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;   <span class="comment">//等于的话，说明找到了，就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//都找到底了还没有，那就是真没有了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">findMax</span><span class="params">(Node root)</span>&#123;   <span class="comment">//查找最大值就更简单了，最右边的一定是最大的</span></span><br><span class="line">    <span class="keyword">while</span> (root &amp;&amp; root-&gt;right) </span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试查找一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    insert(root, <span class="number">10</span>);</span><br><span class="line">    insert(root, <span class="number">20</span>);</span><br><span class="line">    insert(root, <span class="number">7</span>);</span><br><span class="line">    insert(root, <span class="number">15</span>);</span><br><span class="line">    insert(root, <span class="number">22</span>);</span><br><span class="line">    insert(root, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, find(root, <span class="number">17</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, find(root, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/15/lFOaUphkbB3wxIC.png" alt="image-20220815095915453"></p><p>搜索17的结果为NULL，说明没有这个结点，而9则成功找到了。</p><p>最后我们来看看二叉查找树的删除操作，这个操作就比较麻烦了，因为可能会出现下面的几种情况：</p><ol><li>要删除的结点是叶子结点。</li><li>要删除的结点是只有一个孩子结点。</li><li>要删除的结点有两个孩子结点。</li></ol><p>首先我们来看第一种情况，这种情况实际上最好办，直接删除就完事了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/7RWkPXh6po2HjNz.png" alt="image-20220815104036598"></p><p>而第二种情况，就有点麻烦了，因为有一个孩子，就像一个拖油瓶一样，你离开了还不行，你还得对他负责才可以。当移除后，需要将孩子结点连接上去：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/4IZVf3SaCugD8Qc.png" alt="image-20220815104553978"></p><p>可以看到在调整后，依然满足二叉查找树的性质。最后是最麻烦的有两个孩子的情况，这种该怎么办呢？前面只有一个孩子直接上位就完事，但是现在两个孩子，到底谁上位呢？这就不好办了，为了保持二叉查找树的性质，现在有两种选择：</p><ol><li>选取其左子树中最大结点上位</li><li>选择其右子树中最小结点上位</li></ol><p>这里我们以第一种方式为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/jPRG68tru4bvIFa.png" alt="image-20220815110311555"></p><p>现在我们已经分析完三种情况了，那么我们就来编写一下代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">delete</span><span class="params">(Node root, E target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//都走到底了还是没有找到要删除的结点，说明没有，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;element &gt; target)   <span class="comment">//这里的判断跟之前插入是一样的，继续往后找就完事，直到找到为止</span></span><br><span class="line">        root-&gt;left = delete(root-&gt;left, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; target)</span><br><span class="line">        root-&gt;right = delete(root-&gt;right, target);</span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">//这种情况就是找到了</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right) &#123;   <span class="comment">//先处理最麻烦的左右孩子都有的情况</span></span><br><span class="line">            Node max = findMax(root-&gt;left);  <span class="comment">//寻找左子树中最大的元素</span></span><br><span class="line">            root-&gt;element = max-&gt;element;  <span class="comment">//找到后将值替换</span></span><br><span class="line">            root-&gt;left = delete(root-&gt;left, root-&gt;element);  <span class="comment">//替换好后，以同样的方式去删除那个替换上来的结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">//其他两种情况可以一起处理，只需要删除这个结点就行，然后将root指定为其中一个孩子，最后返回就完事</span></span><br><span class="line">            Node tmp = root;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;   <span class="comment">//不是左边就是右边</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(tmp);   <span class="comment">//开删</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;   <span class="comment">//返回最终的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了二叉查找树的各种操作，当然目前为止我们了解的二叉树高级结构还比较简单，后面就开始慢慢复杂起来了。</p><h3 id="平衡二叉树">平衡二叉树</h3><p>前面我们介绍了二叉查找树，利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20 </span><span class="number">15</span> <span class="number">13</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。这里我们就编写一个插入结点代码来实现一下吧，首先还是结点定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;   <span class="comment">//每个结点需要记录当前子树的高度，便于计算平衡因子</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;   <span class="comment">//初始化时，高度写为1就可以了</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要先将左旋、右旋等操作编写出来，因为一会插入时可能需要用到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">leftRotation</span><span class="params">(Node root)</span>&#123;  <span class="comment">//左旋操作，实际上就是把左边结点拿上来</span></span><br><span class="line">    Node newRoot = root-&gt;right;   <span class="comment">//先得到左边结点</span></span><br><span class="line">    root-&gt;right = newRoot-&gt;left;   <span class="comment">//将左边结点的左子树丢到原本根结点的右边去</span></span><br><span class="line">    newRoot-&gt;left = root;   <span class="comment">//现在新的根结点左边就是原本的跟结点了</span></span><br><span class="line"></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;right), getHeight(root-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    newRoot-&gt;height = max(getHeight(newRoot-&gt;right), getHeight(newRoot-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">rightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    Node newRoot = root-&gt;left;</span><br><span class="line">    root-&gt;left = newRoot-&gt;right;</span><br><span class="line">    newRoot-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;right), getHeight(root-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    newRoot-&gt;height = max(getHeight(newRoot-&gt;right), getHeight(newRoot-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">leftRightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    root-&gt;left = leftRotation(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">rightLeftRightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    root-&gt;right = rightRotation(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是我们的插入操作了，注意在插入时动态计算树的高度，一旦发现不平衡，那么就立即采取对应措施：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">insert</span><span class="params">(Node root, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;    <span class="comment">//如果结点为NULL，说明找到了插入位置，直接创建新的就完事</span></span><br><span class="line">        root = createNode(element);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &gt; element) &#123;   <span class="comment">//和二叉搜索树一样，判断大小，该走哪边走哪边，直到找到对应插入位置</span></span><br><span class="line">        root-&gt;left = insert(root-&gt;left, element);</span><br><span class="line">        <span class="keyword">if</span>(getHeight(root-&gt;left) - getHeight(root-&gt;right) &gt; <span class="number">1</span>) &#123;   <span class="comment">//插入完成之后，需要计算平衡因子，看看是否失衡</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;element &gt; element) <span class="comment">//接着需要判断一下是插入了左子树的左边还是右边，如果是左边那边说明是LL，如果是右边那说明是LR</span></span><br><span class="line">                root = rightRotation(root);   <span class="comment">//LL型得到左旋之后的结果，得到新的根结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = leftRightRotation(root);    <span class="comment">//LR型得到先左旋再右旋之后的结果，得到新的根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; element)&#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, element);</span><br><span class="line">        <span class="keyword">if</span>(getHeight(root-&gt;left) - getHeight(root-&gt;right) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;element &lt; element)</span><br><span class="line">                root = leftRotation(root);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = rightLeftRightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面的操作完成之后记得更新一下树高度</span></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;  <span class="comment">//最后返回root到上一级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了平衡二叉树的插入操作，当然删除操作比较类似，也是需要在删除之后判断是否平衡，如果不平衡同样需要进行旋转操作，这里就不做演示了。</p><h3 id="红黑树">红黑树</h3><p>**注意：**本小节内容作为选学内容，不强制要求掌握。很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。其实红黑树难点并不在于如何构建和使用，而是在于，到底是怎么设计出来的，究竟要多么丰富的知识储备才能想到如此精妙的规则。</p><p>红黑树的发明者：</p><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025">关联数组</a>。</p><p>红黑树是在1972年由[Rudolf Bayer](<a href="https://baike.baidu.com/item/Rudolf">https://baike.baidu.com/item/Rudolf</a> Bayer/3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p></blockquote><p>在了解了后面的B树之后，相信我们就能揭开这层神秘面纱了。</p><hr><h2 id="其他树结构">其他树结构</h2><p>前面我们介绍了各种各样的二叉树，其实还是比较简单的。我们接着来看一下其他的一些树结构，这一部分我们只做了解即可。</p><h3 id="B树和B-树">B树和B+树</h3><p>前面我们介绍了多种多样的二叉树，有线索化二叉树，平衡二叉树等等，这些改造版二叉树无疑都是为了提高我们的程序运行效率而生的，我们接着来看一种同样为了提升效率的树结构。</p><p>这里首先介绍一下B树（Balance Tree），它是专门为磁盘数据读取设计的一种度为 m 的查找树（多用于数据库）它同样是一棵平衡树，但是不仅限于二叉了，之前我们介绍的这些的二叉树都是基于内存读取的优化，磁盘读取速度更慢，它同样需要优化，一棵度为4的（4阶）B树大概长这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/lH9YBVIASQJe26d.png" alt="image-20220817102503116"></p><p>第一眼看上去，感觉好像没啥头绪，不能发现啥规律，但是只要你仔细观察，你会发现，它和二叉查找树很相似，左边的一定比根节点小，右边的一定比根节点大，并且我们发现，每个结点现在可以保存多个值，每个结点可以连接多个子树，这些值两两组合划分了一些区间，比如60左边，一定是比60小的，60和80之间那么就是大于60小于80的值，以此类推，所以值有N个，就可以划分出N+1个区间，那么子树最多就可以有N+1个。它的详细规则如下：</p><ol><li>树中每个结点最多含有m个孩子（m &gt;= 2）比如上面就是m为4的4阶B树，最多有4个孩子。</li><li>除根结点和叶子结点外，其它每个结点至少有⌈m/2⌉个孩子，同理键值数量至少有⌈m/2⌉-1个。</li><li>若根结点不是叶子结点，则至少有2个孩子。</li><li>所有叶子结点都出现在同一层。</li><li>一个结点的包含多种信息（P0，K1，P1，K2，…，Kn，Pn），其中P为指向子树的指针，K为键值（关键字）<ol><li>Ki (i=1…n)为键值，也就是每个结点保存的值，且键值按顺序升序排序K(i-1)&lt; Ki</li><li>Pi为指向子树的指针，且指针Pi指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)</li><li>键值的个数n必须满足： ⌈m/2⌉-1 &lt;= n &lt;= m-1</li></ol></li></ol><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p>是不是感觉怎么要求这么多呢？我们通过感受一下B树的插入和删除就知道了，首先是B树的插入操作，这里我们以度为3的B树为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/CqwaR1s2OyeIVLc.png" alt="image-20220817105907362"></p><p>插入1之后，只有一个结点，我们接着插入一个2，插入元素满足以下规则：</p><ul><li>如果该节点上的元素数未满，则将新元素插入到该节点，并保持节点中元素的顺序。</li></ul><p>所以，直接放进去就行，注意顺序：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/HoamJkqwvP2ZlBb.png" alt="image-20220817110243376"></p><p>接着我们再插入一个3进去，但是此时因为度为3，那么键值最多只能有两个，肯定是装不下了：</p><ul><li>如果该节点上的元素已满，则需要将该节点平均地分裂成两个节点：<ol><li>首先从该节点中的所有元素和新元素中先出一个中位数作为<strong>分割值</strong>。</li><li>小于中位数的元素作为左子树划分出去，大于中位数的元素作为右子树划分。</li><li>分割值此时上升到父结点中，如果没有父结点，那么就创建一个新的（这里的上升不太好理解，一会我们推过去就明白了）</li></ol></li></ul><p>所以，当3来了之后，直接进行分裂操作：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/aEJxSUlY1t6nVWM.png" alt="image-20220817110803123"></p><p>就像爱情一样，两个人的世界容不下第三者，如果来了第三者，那么最后的结果大概率就是各自分道扬镳。接着我们继续插入4、5看看会发生什么，注意插入还是按照小的走左边，大的走右边的原则，跟我们之前的二叉查找树是一样的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/Az8pmnsXvZaNl6q.png" alt="image-20220817111405624"></p><p>此时4、5来到了右边，现在右边这个结点又被撑爆了，所以说需要按照上面的规则，继续进行分割：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/odNZMzeUGWQObtA.png" alt="image-20220817111556446"></p><p>可能各位看着有点奇怪，为啥变成这样了，首先3、4、5三个都分开了，然后4作为分割值，3、5变成两个独立的树，此时4需要上升到父结点，所以直接跑到上面去了，然后3和5出现在4的左右两边。注意这里不是向下划分，反而有点向上划分的意思。为什么不向下划分呢？因为要满足B树第四条规则：所有叶子结点都出现在同一层。</p><p>此时我们继续插入6、7，看看会发生什么情况：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/U3ExLbOdD9tpAGW.png" alt="image-20220817111943543"></p><p>此时右下角结点又被挤爆了，右下角真是多灾多难啊，那么依然按照我们之前的操作进行分裂：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/nVFhBQoy7w195Sz.png" alt="image-20220817112213868"></p><p>我们发现当新的分割值上升之后最上面的结点又被挤爆了，此时我们需要继续分裂：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/kQJZDBbrgyHnac1.png" alt="image-20220817112401155"></p><p>在2、4、6中寻找一个新的分割值，分裂后将其上升到新的父结点中，就像上图那样了。在了解了B树的插入操作之后，是不是有一点感受到这种结构带来的便捷了？</p><p>我们再来看看B树的删除操作，这个要稍微麻烦一些，这里我们以一颗5阶B树为例，现在我们想删除16结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/VsiQvCfEJ92oLch.png" alt="image-20220817114440027"></p><p>删除后，依然满足B树的性质，所以说什么都不管用：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/CzTIN2GeREP7lVU.png" alt="image-20220817114541675"></p><p>此时我们接着去删除15结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/ypYEDR7gIL4fZ8X.png" alt="image-20220817114722079"></p><p>删除后，现在结点中只有14了，不满足B树的性质：除根结点和叶子结点外，其它每个结点至少有⌈m/2⌉个孩子，同理键值数量至少有⌈m/2⌉-1个，现在只有一个肯定是不行的。此时我们需向兄弟（注意只能找左右两边的兄弟）借一个过来：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/dZVwpNlRzKxHerA.png" alt="image-20220817114956686"></p><p>此时我们继续删掉17，但是兄弟已经没办法再借给我们一个元素了，此时只能采取方案二，合并兄弟节点与分割键。这里我们就合并左边的这个兄弟吧：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/wxhF2bJUHlEMGXW.png" alt="image-20220817120014656"></p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/Xp3l8AiDU6Bebwo.png" alt="image-20220817120058865"></p><p>现在他们三个又合并回去了，这下总满足了吧？但是我们发现，父结点此时只有一个元素了，又出问题了。同样的，还是先去找兄弟结点借一个，但是兄弟结点也借不了了，此时继续采取我们的方案二，合并：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/E2RzTW5XOJjHdQm.png" alt="image-20220817120402123"></p><p>OK，这样才算是满足了B树的性质，现在我们继续删除4结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/TBrynM7Ge2lfz31.png" alt="image-20220817120835776"></p><p>这种情况会导致失去分割值，那么我们得找一个新的分割值才行，这里取左边最大的：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/pLZJNEyzHAVjfU4.png" alt="image-20220817121020793"></p><p>不过此时虽然解决了分割值的问题，但是新的问题来了，左边结点不满足性质了，元素数量低于限制，于是需要找兄弟结点借，但是没得借了，兄弟也没有多的可以借了所以被迫合并了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/jhT5SNFXwq9niYk.png" alt="image-20220817121250186"></p><p>可以看到整个变换过程中，这颗B树所有子树的高度是一直维持在一个稳定状态的，查找效率能够持续保持。</p><p>删除操作可以总结为两大类：</p><ul><li>若删除的是叶子结点的中元素：<ul><li>正常情况下直接删除。</li><li>如果删除后，键值数小于最小值，那么需要找兄弟借一个。</li><li>要是没得借了，直接跟兄弟结点、对应的分割值合并。</li></ul></li><li>若删除的是某个根结点中的元素：<ul><li>一般情况会删掉一个分割值，删掉后需要重新从左右子树中找一个新分割值的拿上来。</li><li>要是拿上来之后左右子树中出现键值数小于最小值的情况，那么就只能合并了。</li></ul></li><li>上述两个操作执行完后，还要继续往上看上面的结点是否依然满足性质，否则继续处理，直到稳定。</li></ul><p>在了解了B树的相关操作之后，是不是感觉还是挺简单的，依然是动态维护树的平衡。正是得益于B树这种结点少，高度平衡且有序的性质，而硬盘IO速冻远低于内存，我们希望能够花费尽可能少的时间找到我们想要的数据，减少IO次数，B树就非常适合在硬盘上的保存数据，它的查找效率是非常高的。</p><p><strong>注意：以下内容为选学部分：</strong></p><blockquote><p>此时此刻，我们回想一下之前提到的红黑树，我们来看看它和B树有什么渊源，这是一棵很普通的红黑树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/XorTHWdJEt24Zci.png" alt="image-20220817123042186"></p><p>此时我们将所有红色节点上移到与父结点同一高度，</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/VkJmwZI8XFz9Yl2.png" alt="image-20220817123537220"></p><p>还是没看出来？没关系，我们来挨个画个框：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/2TgcNMdztpOEXk6.png" alt="image-20220817123455865"></p><p>woc，这不就是B树吗？没错，<strong>红黑树</strong> 和 <strong>4阶B树</strong>（2-3-4树）具有等价性，其中黑色结点就是中间的（黑色结点一定是父结点)，红色结点分别位于两边，通过将黑色结点与它的红色子节点融合在一起，形成1个B树节点，最后就像这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/MJiErSB4p856mjd.png" alt="image-20220817153152790"></p><p>你会发现，红黑树的黑色节点个数总是与4阶B树的节点数相等。我们可以对比一下之前的红黑树插入和4阶B树的插入，比如现在我们想要插入一个新的14结点进来：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/mNS8zRofZCM6quE.png" alt="image-20220817153955759"></p><p>经过变色，最后得到如下的红黑树，此时又出现两个红色结点连续，因为父结点的兄弟结点依然是红色，继续变色：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/DE5UTIkbdBvAoL9.png" alt="image-20220817154655210"></p><p>最后因为根结点必须是黑色，所以说将60变为黑色，这样就插入成功了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/4nqCNJeFxQbmRGy.png" alt="image-20220817154751660"></p><p>我们再来看看与其等价的B树插入14后会怎么样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/ltno5TuiHAb3QNj.png" alt="image-20220817154838567"></p><p>由于B树的左边被挤爆了，所以说需要分裂，因为是偶数个，需要选择中间偏右的那个数作为分割值，也就是25：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/jZ4EvWynm5aQelq.png" alt="image-20220817160036666"></p><p>分裂后，分割值上升，又把父结点给挤爆了，所以说需要继续分裂：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/7SRHOMucikbnml3.png" alt="image-20220817160244020"></p><p>现在就变成了这样，我们来对比一下红黑树：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/arxhpI1ytvq7wO9.png" alt="image-20220817160427011"></p><p>不能说很像，只能说是一模一样啊。为什么呢？明明这两种树是不同的规则啊，为什么会出现等价的情况呢？</p><ul><li>B树叶节点等深实际上体现在红黑树中为任一叶节点到达根节点的路径中，黑色路径所占的长度是相等的，因为黑色结点就是B树的结点分割值。</li><li>B树节点的键值数量不能超过N实际上体现在红黑树约定相邻红色结点接最多2条，也就是说不可能出现B树中元素超过3的情况，因为是4阶B树。</li></ul><p>所以说红黑树跟4阶B树是有一定渊源的，甚至可以说它就是4阶B树的变体。</p></blockquote><p>前面我们介绍了B树，现在我们就可以利用B树来高效存储数据了，当然我们还可以让它的查找效率更高。这里我们就要提到B+树了，B+树是B树的一种变体，有着比B树更高的查询性能。</p><ol><li>有k个子树的中间结点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据（卫星数据，就是具体需要保存的内容）都保存在叶子结点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点按照从小到大的顺序连接。</li><li>所有的根结点元素都同时存在于子结点中，在子节点元素中是最大（或最小）元素。</li></ol><p>我们来看看一棵B+树长啥样：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/C4utSmNvKPAaZ35.png" alt="image-20220817163343975"></p><p>其中最后一层形成了一个有序链表，在我们需要顺序查找时，提供了极大的帮助。可以看到现在除了最后一层之外，其他结点中存放的值仅仅充当了一个指路人的角色，来告诉你你需要的数据在哪一边，比如根节点有10和18，因为这里是取得最大值，那么整棵树最大的元素就是18了，我们现在需要寻找一个小于18大于10的数，就可以走右边去查找。而具体的数据会放到最下面的叶子结点中，比如数据库就是具体的某一行数据（卫星数据）存放在最下面：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/pW5SiDqmNY2PXfZ.png" alt="image-20220817163816562"></p><p>当然，目前可能你还没有接触过数据库，在以后的学习中，你一定会接触到它的，到时你就会发现新世界。</p><p>它不像B树那样，B树并不是只有最后一行会存储卫星数据，此时比较凌乱。因为只有最后一行存储卫星数据，使用B+树，同样大小的磁盘页可以容纳更多的节点元素，这就意味着，数据量相同的情况下B+树比B树高度更低，减小磁盘IO的次数。其次，B+树的查询必须最终查找到叶子节点，而B树做的是值匹配，到达结点之后并不一定能够匹配成功，所以B树的查找性能并不稳定，最好的情况是只查根节点即可，而最坏的情况则需要查到叶子节点，但是B+树每一次查找都是稳定的，因为一定在叶子结点。</p><p>并且得益于最后一行的链表结构，B+树在做范围查询时性能突出。很多数据库都在采用B+树作为底层数据结构，比如MySQL就默认选择B+Tree作为索引的存储数据结构。</p><p>至此，有关B树和B+树相关内容，就到这里。</p><h3 id="哈夫曼树">哈夫曼树</h3><p>最后我们来介绍一个比较重要的的树形结构，在开篇之前，我想问下，各位了解文件压缩吗？它是怎么做到的呢？我们都会在这一节进行探讨。</p><blockquote><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）</p></blockquote><p>乍一看好像没看懂，啥叫带权路径长度达到最小？就是树中所有的叶结点的权值乘上其到根结点根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/goKnFtErpiNQebU.png" alt="image-20220817170310064"></p><p>这里我们分别将叶子结点ABCD都赋予一个权值，我们来尝试计算一下，计算公式如下：<br>$$<br>WPL = \sum_{i=1}^{n} (value(i) \times depth(i))<br>$$<br>那么左右两边的计算结果为：</p><ul><li>左图： $WPL=5\times2+7\times2+2\times2+13\times2=54$</li><li>右图：$WPL=5\times3+2\times3+7\times2+13\times1=48$</li></ul><p>通过计算结果可知，右图的带权路径长度最小，实际上右图是一棵哈夫曼树。</p><p>那么现在给了我们这些带权的叶子结点，我们怎么去构建一颗哈夫曼树呢？首先我们可以将这些结点视为4棵树，他们共同构成了一片森林：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/V1E4tZsnGbWFzjo.png" alt="image-20220817171759738"></p><p>首先我们选择两棵权值最小的树作为一颗新的树的左右子树，左右顺序不重要（因为哈夫曼编码不唯一，后面会说），得到的树根结点权值为这两个结点之和：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/ZCyj1PVwsqiWz4e.png" alt="image-20220817172343786"></p><p>接着，我们需要将这这棵树放回到森林中，重复上面的操作，继续选择两个最小的出来组成一颗新的树，此时得到：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/G5EyArvMhJ9CQNS.png" alt="image-20220817172640686"></p><p>继续重复上述操作，直到森林里面只剩下一棵树为止：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/ywuA6pRPrboE51S.png" alt="image-20220817172737480"></p><p>这样，我们就得到了一棵哈夫曼树，因为只要保证越大的值越靠近根结点，那么出来的一定是哈夫曼树。所以，我们辛辛苦苦把这棵树构造出来干嘛呢？实际上哈夫曼树的一个比较重要应用就是对数据进行压缩，它是现代压缩算法的基础，我们常常可以看到网上很多文件都是以压缩包（.zip、.7z、.rar等格式）形式存在的，我们将文件压缩之后。</p><p>比如这一堆字符串：ABCABCD，现在我们想要将其进行压缩然后保存到硬盘上，此时就可以使用哈夫曼编码。那么怎么对这些数据进行压缩呢？这里我们就可以采用刚刚构建好的哈夫曼树，我们需要先对其进行标注：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/oRuOayXEKFkPs3d.png" alt="image-20220817173559604"></p><p>向左走是0，向右走是1，比如现在我们要求出A的哈夫曼编码，那么就是根结点到A整条路径上的值拼接：</p><ul><li>A：110</li><li>B：0</li><li>C：111</li><li>D：10</li></ul><p>这些编码看起来就像二进制的一样，也便于我们计算机的数据传输和保存，现在我们要对上面的这个字符串进行压缩，那么只需要将其中的每一个字符翻译为对应编码就行了：</p><ul><li>ABCABCD = 110 0 111 110 0 111 10</li></ul><p>这样我们就得到了一堆压缩之后的数据了。那怎么解码回去呢，也很简单，只需要对照着写回去就行了：</p><ul><li>110 0 111 110 0 111 10 = ABCABCD</li></ul><p>我们来尝试编写一下代码实现一下哈夫曼树的构建和哈夫曼编码的获取把，因为构建哈夫曼树需要选取最小的两个结点，这里需要使用到优先级队列。</p><p>优先级队列与普通队列不同，它允许VIP插队（权值越大的元素优先排到前面去），当然出队还是一律从队首出来。</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/xySEK5OZ8Q3IbNz.png" alt="image-20220817174835425"></p><p>比如一开始4和9排在队列中，这时又来了个7，那么由于7比4大，所以说可以插队，直接排到4的前面去，但是由于9比7大，所以说不能再往前插队了：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/bv4cD8GTgo2qPEQ.png" alt="image-20220817174921980"></p><p>这就是优先级队列，VIP插队机制，要实现这样的优先级队列，我们只需要修改一下入队操作即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//因为下面用到了判断结点的下一个为NULL，所以说记得默认设定为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//因为下面用到了判断结点的下一个为NULL，所以说记得默认设定为NULL</span></span><br><span class="line">    LNode pre = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//我们从头结点开始往后挨个看，直到找到第一个小于当前值的结点，或者到头为止</span></span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;element &gt;= element)</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="built_in">queue</span>-&gt;rear) &#123;   <span class="comment">//如果说找到的位置已经是最后了，那么直接插入就行，这里跟之前是一样的</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//否则开启VIP模式，直接插队</span></span><br><span class="line">        node-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">9</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">4</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">7</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/17/cw6QCUSgDjotKbl.png" alt="image-20220817180127650"></p><p>这样我们就编写好了一个优先级队列，然后就可以开始准备构建哈夫曼树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> value;    <span class="comment">//存放权值</span></span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>首先按照我们前面的例子，构建出这四个带权值的结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element, <span class="type">int</span> value)</span>&#123;   <span class="comment">//创建一个结点</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode pre = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;element-&gt;value &lt;= element-&gt;value)   <span class="comment">//注意这里改成权重的比较，符号改成小于</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="built_in">queue</span>-&gt;rear) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;B&#x27;</span>, <span class="number">16</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;C&#x27;</span>, <span class="number">8</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;D&#x27;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/17/IU9RYEVl7GytZmQ.png" alt="image-20220817180820954"></p><p>已经是按照权重顺序在排队了，接着我们就可以开始构建哈夫曼树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;B&#x27;</span>, <span class="number">16</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;C&#x27;</span>, <span class="number">8</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;D&#x27;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>.front-&gt;next != <span class="built_in">queue</span>.rear) &#123;   <span class="comment">//如果front的下一个就是rear那么说明队列中只有一个元素了</span></span><br><span class="line">        Node left = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">        Node right = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">        Node node = createNode(<span class="string">&#x27; &#x27;</span>, left-&gt;value + right-&gt;value);   <span class="comment">//创建新的根结点</span></span><br><span class="line">        node-&gt;left = left;</span><br><span class="line">        node-&gt;right = right;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, node);   <span class="comment">//最后将构建好的这棵树入队</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node root = pollQueue(&amp;<span class="built_in">queue</span>);   <span class="comment">//最后出来的就是哈夫曼树的根结点了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在得到哈夫曼树之后，我们就可以对这些字符进行编码了，当然注意我们这里面只有ABCD这几种字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">encode</span><span class="params">(Node root, E e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//为NULL肯定就是没找到</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;element == e) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;   <span class="comment">//如果找到了就返回一个空串</span></span><br><span class="line">    <span class="type">char</span> * str = encode(root-&gt;left, e);  <span class="comment">//先去左边找</span></span><br><span class="line">    <span class="type">char</span> * s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str = <span class="built_in">strcat</span>(s, str);   <span class="comment">//如果左边找到了，那么就把左边的已经拼好的字符串拼接到当前的后面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//左边不行那再看看右边</span></span><br><span class="line">        str = encode(root-&gt;right, e);</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            str = <span class="built_in">strcat</span>(s, str);   <span class="comment">//如果右边找到了，那么就把右边的已经拼好的字符串拼接到当前的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;   <span class="comment">//最后返回操作好的字符串给上一级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printEncode</span><span class="params">(Node root, E e)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c 的编码为：%s&quot;</span>, e, encode(root, e));   <span class="comment">//编码的结果就是了</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    Node root = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到对应的编码：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/zx2cXns73yQThaV.png" alt="image-20220817184746630"></p><h3 id="堆和优先级队列">堆和优先级队列</h3><p>前面我们在讲解哈夫曼树时了解了优先级队列，它提供一种可插队的机制，允许权值大的结点排到前面去，但是出队顺序还是从队首依次出队。我们通过对前面的队列数据结构的插入操作进行改造，实现了优先级队列。</p><p>这节课我们接着来了解一下<strong>堆</strong>（Heap）它同样可以实现优先级队列。</p><p>首先必须是一棵完全二叉树，树中父亲都比孩子小的我们称为<strong>小根堆</strong>（小顶堆），树中父亲都比孩子大则是<strong>大根堆</strong>（注意不要跟二叉查找树搞混了，二叉查找树是左小右大，而堆只要是孩子一定小或者大），它是一颗具有特殊性质的完全二叉树。比如下面就是一个典型的大根堆：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/1ULKRiAeZcI2hJm.png" alt="image-20220818104754776"></p><p>因为完全二叉树比较适合使用数组才存储（因为是按序的）所以说一般堆都是以数组形式存放：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/XpYVN2gslOfWLSr.png" alt="image-20220818110224673"></p><p>那么它是怎么运作的呢？比如现在我们想要往堆中插入一个新的元素8，那么：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/mcq2wjLvxHUu6R7.png" alt="image-20220818110450863"></p><p>因为是一棵完全二叉树，那么必须按照顺序，继续在当前这一行从左往右插入新的结点，其实就相当于在数组的后面继续加一个新的进来，是一样的。但是因为要满足大顶堆的性质，所以此时8加入之后，破坏了规则，我们需要进行对应的调整（堆化），很简单，我们只需要将其与父结点交换即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/T187nAaRBV9jJed.png" alt="image-20220818110835798"></p><p>同样的，数组的形式的话，我们就行先计算出它的父结点，然后进行交换即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/tp81Tlr6LzFeaXQ.png" alt="image-20220818111156209"></p><p>当然，还没完，我们还需要继续向上比较，直到稳定为止，此时7依然是小于8的，所以说需要继续交换：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/FP5LhdDZ9zVBYfl.png" alt="image-20220818111311322"></p><p>现在满足性质了，堆化结束，可以看到最大的元素被排到了最前面，这不就是我们前面的优先级队列吗。</p><p>现在我们来试试看删除队首元素，也就相当于出队操作，删除最顶上的元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/XxivcLFwebrUKf2.png" alt="image-20220818111840303"></p><p>现在需要删除最顶上的元素但是我们需要保证删除之后依然是一棵完全二叉树，所以说我们先把排在最后面的拿上来顶替一下：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/MmtNHQla3zej6FC.png" alt="image-20220818111959046"></p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/OWGiYxKb71o249T.png" alt="image-20220818112109066"></p><p>接着我们需要按照与插入相反的方向，从上往下进行堆化操作，规则是一样的，遇到大的就交换，直到不是为止：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/BqTkxDov8AXtwCZ.png" alt="image-20220818112222696"></p><p>这样，我们发现，即使完成了出队操作，依然是最大的元素排在队首，并且整棵树依然是一棵完全二叉树。</p><p>按照上面的操作，我们来编写一下代码吧，这里还是以大顶堆为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line">    E * arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">&#125; * Heap;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initHeap</span><span class="params">(Heap heap)</span>&#123;   <span class="comment">//初始化都是老套路了，不多说了</span></span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    heap-&gt;arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (E) * heap-&gt;capacity);</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是插入操作，首先还是需要判断是否已满：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insert</span><span class="params">(Heap heap, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap-&gt;size == heap-&gt;capacity) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//满了就不处理了，主要懒得写扩容了</span></span><br><span class="line">    <span class="type">int</span> index = ++heap-&gt;size;   <span class="comment">//先计算出要插入的位置，注意要先自增，因为是从1开始的</span></span><br><span class="line">    <span class="comment">//然后开始向上堆化，直到符合规则为止</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; element &gt; heap-&gt;arr[index / <span class="number">2</span>]) &#123;</span><br><span class="line">        heap-&gt;arr[index] = heap-&gt;arr[index / <span class="number">2</span>];</span><br><span class="line">        index /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在得到的index就是最终的位置了</span></span><br><span class="line">    heap-&gt;arr[index] = element;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= heap-&gt;size; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">    insert(&amp;heap, <span class="number">5</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">2</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">3</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">7</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    printHeap(&amp;heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/18/bFS9KEPNxRdnYas.png" alt="image-20220818120554099"></p><p>插入完成之后，我们接着来写一下删除操作，删除操作实际上就是出队的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">delete</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    E max = heap-&gt;arr[<span class="number">1</span>], e = heap-&gt;arr[heap-&gt;size--];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= heap-&gt;size) &#123;   <span class="comment">//跟上面一样，开找，只不过是从上往下找</span></span><br><span class="line">        <span class="type">int</span> child = index * <span class="number">2</span>;   <span class="comment">//先找到左孩子</span></span><br><span class="line">        <span class="comment">//看看右孩子和左孩子哪个大，先选一个大的出来</span></span><br><span class="line">        <span class="keyword">if</span>(child &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[child] &lt; heap-&gt;arr[child + <span class="number">1</span>])</span><br><span class="line">            child += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e &gt;= heap-&gt;arr[child]) <span class="keyword">break</span>;   <span class="comment">//如果子结点都不大于新结点，那么说明就是这个位置，结束就行了</span></span><br><span class="line">        <span class="keyword">else</span> heap-&gt;arr[index] = heap-&gt;arr[child];  <span class="comment">//否则直接堆化，换上去</span></span><br><span class="line">        index = child;   <span class="comment">//最后更新一下index到下面去</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;arr[index] = e;   <span class="comment">//找到合适位置后，放进去就行了</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, delete(&amp;heap));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/08/18/x8YDojfnp2yBqvA.png" alt="image-20220818120633714"></p><p>可以看到结果就是优先级队列的出队结果，这样，我们就编写好了大顶堆的插入和删除操作了。</p><p>当然，堆在排序上也有着非常方便的地方，在后面的排序算法篇中，我们还会再次说起它。</p><p>至此，有关树形结构篇的内容，我们就全部讲解完毕了，请务必认真掌握前面的二叉树和高级二叉树结构，这些都是重点内容，下一章我们将继续探讨<strong>散列表</strong>。</p><hr><h2 id="算法实战">算法实战</h2><p>二叉树相关的算法实战基本都是与递归相关的，因为它实在是太适合用分治算法了！</p><h3 id="（简单）二叉查找树的范围和">（简单）二叉查找树的范围和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></p><p>给定<strong>二叉搜索树</strong>的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="img"></p><p>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15   （注意力扣上的输入案例写的是层序序列，含空节点）<br>输出：32</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt="img"></p><p>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10<br>输出：23</p></blockquote><p>这道题其实就是考察我们对于二叉查找树的理解，利用二叉查找树的性质，这道题其实很简单，只需要通过递归分治就可以解决了。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)    <span class="comment">//如果最大的值都比当前结点值小，那么肯定在左边才能找到</span></span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; low)   <span class="comment">//如果最小值都比当前结点大，那么肯定在右边才能找到</span></span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//这种情况肯定是在范围内了，将当前结点值加上左右的，再返回</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + rangeSumBST(root-&gt;right, low, high) + rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种问题比较简单，直接四行就解决了。</p><hr><h3 id="（中等）重建二叉树">（中等）重建二叉树</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>示例 1:</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p></blockquote><p>示例 2:</p><blockquote><p>Input: preorder = [-1], inorder = [-1]<br>Output: [-1]</p></blockquote><p>实际上这道题就是我们前面练习题的思路，现在给到我们的是前序和中序遍历的结果，我们只需要像之前一样逐步推导即可。</p><p>在中序遍历序列中找到根节点的位置后，这个问题就很好解决了，大致思路如下：</p><ol><li>由于前序遍历首元素为根节点值，首先可以得到根节点值。</li><li>在中序遍历序列中通过根节点的值，寻找根节点的位置。</li><li>将左右两边的序列分割开来，并重构为根节点的左右子树。（递归分治）</li><li>在新的序列中，重复上述步骤，通过前序遍历再次找到当前子树的根节点，再次进行分割。</li><li>直到分割到仅剩下一个结点时，开始回溯，从而完成整棵二叉树的重建。</li></ol><p>解题代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode * <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;   <span class="comment">//这个就是单纯拿来创建结点的函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心递归分治实现</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTreeCore</span><span class="params">(<span class="type">int</span> * preorder, <span class="type">int</span> * inorder, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果都超出范围了，肯定不行</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span> createNode(preorder[index]);   <span class="comment">//如果已经到头了，那么直接创建结点返回即可</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> =</span> createNode(preorder[index]);   <span class="comment">//先从前序遍历中找到当前子树的根结点值，然后创建对应的结点</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (inorder[pos] != preorder[index]) pos++;   <span class="comment">//找到中序的对应位置，从这个位置开始左右划分</span></span><br><span class="line">    node-&gt;left = buildTreeCore(preorder, inorder, start, pos - <span class="number">1</span>, index+<span class="number">1</span>);   </span><br><span class="line">  <span class="comment">//当前结点的左子树按照同样的方式建立</span></span><br><span class="line">  <span class="comment">//因为前序遍历的下一个结点就是左子树的根结点，所以说这里给index+1</span></span><br><span class="line">    node-&gt;right = buildTreeCore(preorder, inorder, pos+<span class="number">1</span>, end, index+(pos-start)+<span class="number">1</span>);  </span><br><span class="line">  <span class="comment">//当前结点的右子树按照同样的方式建立</span></span><br><span class="line">  <span class="comment">//最后一个index需要先跳过左子树的所有结点，才是右子树的根结点，所以说这里加了个pos-start，就是中序划分出来，左边有多少就减去多少</span></span><br><span class="line">    <span class="keyword">return</span> node;   <span class="comment">//向上一级返回当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> preorderSize, <span class="type">int</span>* inorder, <span class="type">int</span> inorderSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTreeCore(preorder, inorder, <span class="number">0</span>, preorderSize - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//这里传入了前序和中序序列，并且通过start和end指定当前中序序列的处理范围，最后的一个index是前序遍历的对应头结点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（中等）验证二叉搜索树">（中等）验证二叉搜索树</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>（先说，这题老六行为过多，全站通过率只有36.5%，但是题目本身很简单）</p><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><p>输入：root = [2,1,3]<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><p>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p></blockquote><p>这种题看起来好像还挺简单的，我们可以很快地写出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//到头了就直接返回真</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果左边不是空，并且左边还比当前结点值小的话，那肯定不是了</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);  <span class="comment">//接着向下走继续判断左右两边子树，必须同时为真才是真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接上力扣测试，嗯，没问题，提交，这把必过！于是光速打脸：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/EQdvDtlnSgU7kWC.png" alt="image-20220817224437688"></p><p>不可能啊，我们的逻辑判断没有问题的，我们的算法不可能被卡的啊？（这跟我当时打ACM一样的感觉，我这天衣无缝的算法不可能错的啊，哪个老六测试用例给我卡了）这其实是因为我们没有考虑到右子树中左子树比根结点值还要小的情况：</p><p><img src="https://image.itbaima.cn/markdown/2022/08/17/AjU1G2nXytRCKoW.png" alt="image-20220817224830911"></p><p>虽然这样错的很明显，但是按照我们上面的算法，这种情况确实也会算作真。所以说我们需要改进一下，对其上界和下界进行限定，不允许出现这种低级问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> min, <span class="type">long</span> max)</span>&#123;   <span class="comment">//这里上界和下界用long表示，因为它的范围给到整个int，真是个老六</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里还需要判断是否正常高于下界</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; (root-&gt;left-&gt;val &gt;= root-&gt;val || root-&gt;left-&gt;val &lt;= min))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//这里还需判断一下是否正常低于上界</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; (root-&gt;right-&gt;val &lt;= root-&gt;val || root-&gt;right-&gt;val &gt;= max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValid(root-&gt;left, min, root-&gt;val) &amp;&amp; isValid(root-&gt;right, root-&gt;val, max);</span><br><span class="line">    <span class="comment">//注意往左走更新上界，往右走更新下界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValid(root, <span class="number">-2147483649</span>, <span class="number">2147483648</span>);   <span class="comment">//下界刚好比int少1，上界刚好比int多1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没问题了。</p><hr><h3 id="（中等）求根到叶数字之和">（中等）求根到叶数字之和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></p><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p><p>输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p><p>输入：root = [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 = 495 + 491 + 40 = 1026</p></blockquote><p>这道题其实也比较简单，直接从上向下传递当前路径上已经组装好的值即可，到底时返回最终的组装结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumNumbersImpl</span><span class="params">(<span class="keyword">struct</span> TreeNode * root, <span class="type">int</span> parent)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果到头了，直接返回0</span></span><br><span class="line">  <span class="type">int</span> sum = root-&gt;val + parent * <span class="number">10</span>;   <span class="comment">//因为是依次向后拼接，所以说直接将之前的值x10然后加上当前值即可</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)    <span class="comment">//如果是叶子结点，那么直接返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="comment">//否则按照同样的方式将左右的结果加起来</span></span><br><span class="line">    <span class="keyword">return</span> sumNumbersImpl(root-&gt;left, sum) + sumNumbersImpl(root-&gt;right,  sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumNumbersImpl(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（困难）结点之和的最大路径">（困难）结点之和的最大路径</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/jC7MId/">剑指 Offer II 051. 节点之和最大的路径</a>（这是一道Hard难度的题目，但是其实还好）</p><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><p>输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><p>输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</p></blockquote><p>首先，我们要知道，路径有很多种可能，要么从上面下来，要么从左边上来往右边走，要么只走右边，要么只走左边…我们需要寻找一个比较好的方法在这么多种可能性之间选择出最好的那一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">-2147483648</span>;    <span class="comment">//使用一个全局变量来存储一下当前的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//不想多说了</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先把左右两边走或是不走的情况计算一下，取出值最大的情况</span></span><br><span class="line">    <span class="type">int</span> leftMax = max(maxValue(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> rightMax = max(maxValue(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//因为要么只走左边，要么只走右边，要么左右都走，所以说我们计算一下最大情况下的结果</span></span><br><span class="line">    <span class="type">int</span> maxTmp = leftMax + rightMax + root-&gt;val;</span><br><span class="line">    result = max(maxTmp, result);   <span class="comment">//更新一下最大值</span></span><br><span class="line">    <span class="comment">//然后就是从上面下来的情况了，从上面下来要么左要么右，此时我们只需要返回左右最大的一个就行了</span></span><br><span class="line">    <span class="keyword">return</span> max(leftMax, rightMax) + root-&gt;val;  <span class="comment">//注意还要加上当前结点的值，因为肯定要经过当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    maxValue(root);</span><br><span class="line">    <span class="keyword">return</span> result;   <span class="comment">//最后返回完事之后最终得到的最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就成功解决了这种问题。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线性结构-数据结构与算法（一）</title>
    <link href="https://blog.yuncan.xyz/posts/s1.html"/>
    <id>https://blog.yuncan.xyz/posts/s1.html</id>
    <published>2023-06-24T03:54:24.000Z</published>
    <updated>2023-06-24T03:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/s_cover.jpg" alt="cover"></p><h1>线性结构篇</h1><p>**注意：**开始本篇学习之前，请确保你完成了 <strong>C语言程序设计</strong> 篇视频教程，否则无法进行学习。</p><p>我们本系列课程分为基础知识和算法实战两部分，其中算法实战在LeetCode上进行：<a href="https://leetcode.cn/%EF%BC%8C%E5%90%84%E4%BD%8D%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%89%8D%E5%9C%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E6%B3%A8%E5%86%8C%E5%A5%BD%E7%9B%B8%E5%85%B3%E8%B4%A6%E5%8F%B7%E3%80%82">https://leetcode.cn/，各位可以提前在平台上注册好相关账号。</a></p><p>学习完数据结构，各位小伙伴可以尝试参加算法相关的学科竞赛，如ICPC-ACM、蓝桥杯等，算法类的比赛含金量相比项目类比赛更高，也更有价值，相应的，算法类竞赛难道会更大一些，尤其是ICPC-ACM大学生程序设计竞赛，一般都是各个高校内顶尖级队伍进行参赛，甚至还有中学队伍（这类学生预定清华、北大），因为算法更加考验个人的思维能力和天赋水平，相比其他计算机基础课程，数据结构和算法是难度最高的，也是各大高校考研的重点内容。</p><p>不过虽然很难，并且考验个人天赋，但是大部分人通过努力学习是完全能够掌握基础部分的，在应对80%的题目时，是完全有机会解决的，所以，不要怀疑自己，说不定你就是下一个大佬。</p><p>这里也说一下面试推荐书籍，内含多种常用算法以及解题分析，值得一看：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/09/TurKEpDHmvlgJhZ.png" alt="image-20220709170248015"></p><p>本篇内容虽然继续以C语言为基础进行讲解，但是将不再涉及到C语言的语言层面相关内容，更多的是数据结构和算法的思想，实际上用任意一种语言都可以实现。</p><hr><h2 id="什么是数据结构与算法">什么是数据结构与算法</h2><p>回顾我们之前的C语言程序设计阶段，我们已经接触过基本数据类型，并且能够使用结构体对数据进行组织，我们可以很轻松地使用一个结构体来存放一个学生的完整数据，在数据结构学习阶段，我们还会进一步地研究。</p><h3 id="数据结构">数据结构</h3><p>那么，我们来看看，什么是数据结构呢？</p><blockquote><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/9663235">逻辑结构</a>和数据的物理结构以及它们之间的相互关系。</p></blockquote><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p><img src="https://image.itbaima.cn/markdown/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>我们需要一种更好的数据表示和组织方式，才能做到类似于增删改查这样的操作，而完成这些操作所用到的方法，我们称其为“算法”，所以数据结构和算法，一般是放在一起进行讲解的。</p><h3 id="算法">算法</h3><p>比如现在我们希望你求出1-100所有数字的和，请通过程序来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) sum += i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易就能编写出这样的程序，实际上只需要一个for循环就能搞定了，而这就是我们设计的算法。</p><p><img src="https://image.itbaima.cn/markdown/2022/07/09/srPn4baDXWZ9qcJ.png" alt="image-20220709223103628"></p><p>在之前的C语言程序设计阶段，我们其实已经学习了许多算法，包括排序算法、动态规划等。</p><p>当然，解决问题的算法并不是只有一种，实际上我们上面的方式并不是最优的算法，如果想要求得某一段整数的和，其实使用<strong>高斯求和公式</strong>能够瞬间得到结果：<br>$$<br>\sum=\frac{(首项+末项)\times项数}{2}<br>$$<br>所以，我们完全没必要循环那么多次进行累加计算，而是直接使用数学公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="number">1</span> + <span class="number">100</span>) * <span class="number">100</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，算法的尽头还得是数学啊。</p><p>可见，不同的算法，执行的效率也是有很大差别的，这里我们就要提到算法的复杂度了。衡量一个算法的复杂程度需要用到以下两个指标：</p><ul><li>时间复杂度<code>T(n)</code>：算法程序在执行时消耗的时间长度，一般与输入数据的规模n有关。</li><li>空间复杂度<code>S(n)</code>：算法程序在执行时占用的存储单元长度，同样与数据的输入规模n有关，大部分情况下，我们都是采取空间换时间的算法。</li></ul><p>比如我们上面的两种算法，第一种需要执行n次循环，每轮循环进行一次累加操作，而第二种只需要进行一次计算即可。实际中我们计算时间复杂度时，其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用<code>O</code>渐进表示法。</p><ul><li><strong>大O符号（Big O notation）</strong>：是用于描述函数渐进行为的数学符号。</li></ul><p>而这里的循环次数，实际上就是我们需要知道的大致执行次数，所以第一种算法的时间复杂度为：<code>O(n)</code>，其中n就是项数，因为它需要执行n次计算才能得到最后的结果。而第二种算法的时间复杂度为：<code>O(1)</code>，因为它只需要执行一次计算（更准确的说它的执行次数是一个常数，跟项数n毫无关系），显然，当n变得非常大时，第二种方法的计算速度远超第一种。</p><p>再比如我们之前使用的冒泡排序算法，需要进行两轮循环，而循环的次数在经过优化之后为<code>(n - 1)(n - 1)/2</code>，得到的结果中包含了一个<code>n</code>的平方，此时这种算法的时间复杂度就来到<code>O(n^2)</code>了。</p><p>在不同的空间复杂度下，可能n小的时候还没什么感觉，但是当n变得非常大时，差距就不是一点半点了，我们来看看常用函数的增长曲线：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/09/Tr6jI5uPzy2NeDd.png" alt="image-20220709230756755"></p><p>所以我们在设计算法的时候，一定要考虑到时间和空间复杂度的问题，这里列出常用函数的增长表：</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">类型</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">$\Omicron(1)$</td><td style="text-align:center">常数阶</td><td style="text-align:center">如果算法能够优化到这个程度，那么基本上算是最快的算法了。</td></tr><tr><td style="text-align:center">$\Omicron(\log_{2}n)$</td><td style="text-align:center">对数阶</td><td style="text-align:center">仅次于常数阶的速度，我们后面会介绍的二分搜索算法，就能够到达这个级别。</td></tr><tr><td style="text-align:center">$\Omicron(n)$</td><td style="text-align:center">线性阶</td><td style="text-align:center">我们后面介绍的线性表插入、删除数据，包括动态规划类算法能够达到线性阶。</td></tr><tr><td style="text-align:center">$\Omicron(n\log_{2}n)$</td><td style="text-align:center">线性对数阶</td><td style="text-align:center">相当于在对数阶算法外层套了一层线性阶循环。</td></tr><tr><td style="text-align:center">$\Omicron(n^2)$</td><td style="text-align:center">平方阶</td><td style="text-align:center">我们前面学习的冒泡排序，需要进行两重循环，实际上就是平方阶。</td></tr><tr><td style="text-align:center">$\Omicron(n^3)$</td><td style="text-align:center">立方阶</td><td style="text-align:center">从立方阶开始，时间复杂度就开始变得有点大了。</td></tr><tr><td style="text-align:center">$\Omicron(2^n)$</td><td style="text-align:center">指数阶</td><td style="text-align:center">我们前面介绍的斐波那契数列递归算法，就是一个指数阶的算法，因为它包含大量的重复计算。</td></tr><tr><td style="text-align:center">$\Omicron(n!)$</td><td style="text-align:center">阶乘</td><td style="text-align:center">这个增长速度比指数阶还恐怖，但是一般很少有算法能达到这个等级。</td></tr></tbody></table><p>我们在编写算法时，一定要注意算法的时间复杂度，当时间复杂度太大时，可能计算机就很难在短时间内计算出结果了。</p><h3 id="案例：二分搜索算法">案例：二分搜索算法</h3><p>现在有一个从小到大排序的数组，给你一个目标值<code>target</code>，现在请你找到这个值在数组中的对应下标，如果没有，请返回<code>-1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//请实现查找算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;, target = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, search(arr, <span class="number">10</span>, target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，最简单的方法就是将数组中的元素一个一个进行遍历，总有一个是，如果遍历完后一个都没有，那么就结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == target) <span class="keyword">return</span> i;   <span class="comment">//循环n次，直到找到为止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样的算法简单粗暴，但是并不是最好的，我们需要遍历n次才能得到结果，时间复杂度为$\Omicron(n)$，我们可以尝试将其优化到更低的时间复杂度。这里我们利用它有序的特性，实际上当我们查找到大于目标<code>target</code>的数时，就没必要继续寻找了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样循环进行的次数也许就会减小了，但是如果我们要寻找的目标<code>target</code>刚好是最后几个元素呢？这时时间复杂度又来到到了$\Omicron(n)$，那么有没有更好的办法呢？我们依然可以继续利用数组有序的特性，既然是有序的，那么我们不妨随机在数组中找一个数，如果这个数大于目标，那么就不再考虑右边的部分，如果小于目标，那么就考虑左边的部分，然后继续在另一部分中再次随机找一个数，这样每次都能将范围缩小，直到找到为止（其思想就比较类似于<strong>牛顿迭代法</strong>，再次强调数学的重要性）</p><p><img src="https://image.itbaima.cn/markdown/2022/07/10/CczrjdlmBgPSRIb.png" alt="image-20220710095856681"></p><p>而二分思想就是将一个有序数组不断进行平分，直到找到为止，这样我们每次寻找的范围会不断除以2，所以查找的时间复杂度就降到了$\Omicron(\log_{2}n)$，相比一个一个比较，效率就高了不少：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/10/FSDcHgG3sOo789z.png" alt="image-20220710101328777"></p><p>好了，那么现在我们就可以利用这种思想，编写出二分搜索算法了，因为每一轮都在进行同样的搜索操作，只是范围不一样，所以这里直接采用递归分治算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> * nums, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;  <span class="comment">//left代表左边界，right代表右边界</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//如果左边大于右边，那么肯定就找完了，所以直接返回</span></span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;   <span class="comment">//这里计算出中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;   <span class="comment">//直接比较，如果相等就返回下标</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target)    <span class="comment">//这里就是大于或小于的情况了，这里mid+1和mid-1很多人不理解，实际上就是在下一次寻找中不算上当前的mid，因为这里已经比较过了，所以说左边就-1，右边就+1</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, left, mid - <span class="number">1</span>);   <span class="comment">//如果大于，那么说明肯定不在右边，直接去左边找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, mid + <span class="number">1</span>, right);  <span class="comment">//如果小于，那么说明肯定不在左边，直接去右边找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums, target, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>while</code>循环来实现二分搜索，如果需要验证自己的代码是否有问题，可以直接在力扣上提交代码：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p><hr><h2 id="线性表">线性表</h2><p>那么作为数据结构的开篇，我们就从最简单的线性表开始介绍。</p><p>还记得我们开篇提了一个问题吗？</p><blockquote><p>我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p></blockquote><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li>**初始化线性表：**将一个线性表进行初始化，得到一个全新的线性表。</li><li>**获取指定位置上的元素：**直接获取线性表指定位置<code>i</code>上的元素。</li><li>**获取元素的位置：**获取某个元素在线性表上的位置<code>i</code>。</li><li>**插入元素：**在指定位置<code>i</code>上插入一个元素。</li><li>**删除元素：**删除指定位置<code>i</code>上的一个元素。</li><li>**获取长度：**返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="顺序表">顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的结构体类型，将一些需要用到的数据保存在一起，这里我们以<code>int</code>类型的线性表为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;  <span class="comment">//这里我们的元素类型就用int为例吧，先起个别名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E <span class="built_in">array</span>[<span class="number">10</span>];   <span class="comment">//实现顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//表示底层数组的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了一会使用方便，我们可以给其起一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span> <span class="comment">//因为是数组实现，所以就叫ArrayList，这里直接将List的指针起别名</span></span><br></pre></td></tr></table></figure><p>然后我们就可以开始编写第一个初始化操作了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;   <span class="comment">//直接将数组的容量设定为10即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现一个问题，这样的话我们的顺序表长度不就是固定为10的了吗？而前面我们线性表要求的是长度是动态增长的，那么这个时候怎么办呢？我们可以直接使用一个指针来指向底层数组的内存区域，当装不下的时候，我们可以创建一个新的更大的内存空间来存放数据，这样就可以实现扩容了，所以我们来修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;   <span class="comment">//指向顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们修改一下初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;  <span class="comment">//这里就默认所有的顺序表初始大小都为10吧，随意</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);   <span class="comment">//使用malloc函数申请10个int大小的内存空间，作为底层数组使用</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;    <span class="comment">//容量同样设定为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还没完，因为我们的表里面，默认情况下是没有任何元素的，我们还需要一个变量来表示当前表中的元素数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;   <span class="comment">//指向顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组的容量</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//表中的元素数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;  <span class="comment">//这里就默认所有的顺序表初始大小都为10吧，随意</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);   <span class="comment">//使用malloc函数申请10个int大小的内存空间，作为底层数组使用</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;    <span class="comment">//容量同样设定为10</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;   <span class="comment">//元素数量默认为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种情况我们需要考虑，也就是说如果申请内存空间失败，那么需要返回一个结果告诉调用者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//需要判断如果申请的结果为NULL的话表示内存空间申请失败</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//正常情况下返回true也就是1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个比较简单的顺序表就定义好，我们可以通过<code>initList</code>函数对其进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span>   <span class="comment">//创建新的结构体变量</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;   <span class="comment">//对其进行初始化，如果失败就直接结束</span></span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下插入和删除操作，对新手来说也是比较难以理解的操作：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/DdlNcI8rykQsZif.png" alt="image-20220723121423682"></p><p>我们先设计好对应的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//list就是待操作的表，element就是需要插入的元素，index就是插入的位置（注意顺序表的index是按位序计算的，从1开始，一般都是第index个元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照上面的思路来编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)  <span class="comment">//先使用for循环将待插入位置后续的元素全部丢到后一位</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;    <span class="comment">//挪完之后，位置就腾出来了，直接设定即可</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;   <span class="comment">//别忘了插入之后相当于多了一个元素，记得size + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以来测试一下了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;   <span class="comment">//编写一个函数用于打印表当前的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i)   <span class="comment">//表里面每个元素都拿出来打印一次</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">1</span>);  <span class="comment">//每次插入操作后都打印一下表，看看当前的情况 </span></span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">777</span>, <span class="number">1</span>);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">888</span>, <span class="number">2</span>);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/nbSVp2yMqKlJQI6.png" alt="image-20220723153237528"></p><p>虽然这样看起来没什么问题了，但是如果我们在非法的位置插入元素会出现问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">-1</span>);   <span class="comment">//第一个位置就是0，怎么可能插入到-1这个位置呢，这样肯定是不正确的，所以我们需要进行判断</span></span><br><span class="line">printList(&amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>我们需要检查一下插入的位置是否合法：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>转换成位序，也就是[1, size + 1]这个闭区间，所以我们在一开始的时候进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果在非法位置插入，返回0表示插入操作执行失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//正常情况返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以再来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">-1</span>))&#123;</span><br><span class="line">    printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/07/23/7Q4IxSd2RDKmzBZ.png" alt="image-20220723154249242"></p><p>不过我们还是没有考虑到一个情况，那么就是如果我们的表已经装满了，也就是说size已经达到申请的内存空间最大的大小了，那么此时我们就需要考虑进行扩容了，否则就没办法插入新的元素了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="built_in">list</span>-&gt;capacity) &#123;   <span class="comment">//如果size已经到达最大的容量了，肯定是插不进了，那么此时就需要扩容了</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">list</span>-&gt;capacity + (<span class="built_in">list</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//我们先计算一下新的容量大小，这里我取1.5倍原长度，当然你们也可以想扩多少扩多少</span></span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(E) * newCapacity);  <span class="comment">//这里我们使用新的函数realloc重新申请更大的内存空间</span></span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果申请失败，那么就确实没办法插入了，只能返回0表示插入失败了</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">list</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>realloc函数可以做到控制动态内存开辟的大小，重新申请的内存空间大小就是我们指定的新的大小，并且原有的数据也会放到新申请的空间中，所以非常方便。当然如果因为内存不足之类的原因导致内存空间申请失败，那么会返回NULL，所以别忘了进行判断。</p></blockquote><p>这样，我们的插入操作就编写完善了，我们可以来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">            insertList(&amp;<span class="built_in">list</span>, i, i);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/IqvG1xsUQOo5KwC.png" alt="image-20220723160222988"></p><p>这样，我们就完成了顺序表的插入操作，接着我们来编写一下删除操作，其实删除操作也比较类似，也需要对元素进行批量移动，但是我们不需要考虑扩容问题，我们先设计好函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//list就是待操作的表，index是要删除的元素位序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们上面插入的思路，我们反过来想一想然后实现删除呢？首先是删除的范围：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>换算成位序就是[1, size]这个闭区间内容，所以我们先来限定一下合法范围：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正常情况返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是删除元素之后，我们还需要做什么呢？我们应该将删除的这个元素后面的全部元素前移一位：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/dgGCcL7q9Pf41tF.png" alt="image-20220723161412178"></p><p>我们按照这个思路，来编写一下删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i + <span class="number">1</span>];   <span class="comment">//实际上只需要依次把后面的元素覆盖到前一个即可</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;   <span class="comment">//最后别忘了size - 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除相比插入要简单一些，我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  <span class="comment">//先插10个</span></span><br><span class="line">    insertList(&amp;<span class="built_in">list</span>, i, i);</span><br><span class="line">deleteList(&amp;<span class="built_in">list</span>, <span class="number">5</span>);   <span class="comment">//这里删除5号元素</span></span><br><span class="line">printList(&amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/q2UrtVlh1RJWKQd.png" alt="image-20220723161835205"></p><p>OK，那么插入和删除操作我们就成功完成了，还有一些比较简单的功能，我们这里也来依次实现一下，首先是获取长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;   <span class="comment">//直接返回size就完事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是按位置获取元素和查找指定元素的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E * <span class="title function_">getList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果超出范围就返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i) &#123;   <span class="comment">//一直遍历，如果找到那就返回位序</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] == element) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果遍历完了都没找到，那么就返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的线性表就实现完成了，完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="built_in">list</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">list</span>-&gt;capacity + (<span class="built_in">list</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, newCapacity * <span class="keyword">sizeof</span>(E));</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">list</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] == element) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**问题：**请问顺序实现的线性表，插入、删除、获取元素操作的时间复杂度为？</p><ul><li>**插入：**因为要将后续所有元素都向后移动，所以平均时间复杂度为$O(n)$</li><li>**删除：**同上，因为要将所有元素向前移动，所以平均时间复杂度为$O(n)$</li><li>**获取元素：**因为可以利用数组特性直接通过下标访问到对应元素，所以时间复杂度为$O(1)$</li></ul><p><strong>顺序表习题：</strong></p><ol><li><p>在一个长度为<code>n</code>的顺序表中，向第<code>i</code>个元素前插入一个新的元素时，需要向后移动多少个元素？</p><p>A. <code>n - i</code>      B. <code>n - i + 1</code>     C. <code>n - i - 1</code>       D. <code>i</code></p><p><em>注意这里要求的是向第<code>i</code>个元素前插入（第<code>i</code>个表示的是位序，不是下标，不要搞混了，第1个元素下标就为0），这里我们假设<code>n</code>为3，<code>i</code>为2，那么也就是说要在下标为1的这个位置上插入元素，那么就需要移动后面的2个元素，所以答案是B</em></p></li><li><p>顺序表是一种（    ）的存储结构？</p><p>A. 随机存取        B. 顺序存取       C. 索引存取        D. 散列存取</p><p><em>首先顺序表底层是基于数组实现的，那么它肯定是支持随机访问的，因为我们可以直接使用下标想访问哪一个就访问哪一个，所以选择A，不要看到名字叫做顺序表就选择顺序存取，因为它并不需要按照顺序来进行存取，链表才是。这里也没有建立索引去访问元素，也更不可能是散列存取了，散列存取我们会在后面的哈希表中进行介绍</em></p></li></ol><hr><h3 id="链表">链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>那么我们就来尝试编写一个带头结点的链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;   <span class="comment">//这个还是老样子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;   <span class="comment">//保存当前元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span>   <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">Node</span>;</span>   <span class="comment">//这里我们直接为结点指针起别名，可以直接作为表实现</span></span><br></pre></td></tr></table></figure><p>同样的，我们先将初始化函数写好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点默认下一个为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span>   <span class="comment">//这里创建一个新的头结点，头结点不存放任何元素，只做连接，连接整个链表</span></span><br><span class="line">    initList(&amp;head);  <span class="comment">//先进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="comment">//head是头结点，element为待插入元素，index是待插入下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要先找到待插入位置的前驱结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果插入的位置小于1，那肯定是非法的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;   <span class="comment">//通过--index的方式不断向后寻找前驱结点</span></span><br><span class="line">        head = head-&gt;next;   <span class="comment">//正常情况下继续向后找</span></span><br><span class="line">      <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">      <span class="comment">//如果在寻找的过程中发型已经没有后续结点了，那么说明index超出可插入的范围了，也是非法的，直接润</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环操作完成后，如果没问题那么会找到对应插入位置的前驱结点，我们只需要按照上面分析的操作来编写代码即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">      <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//创建一个新的结点，如果内存空间申请失败返回0</span></span><br><span class="line">    node-&gt;element = element;   <span class="comment">//将元素保存到新创建的结点中</span></span><br><span class="line">    node-&gt;next = head-&gt;next;   <span class="comment">//先让新插入的节点指向原本位置上的这个结点</span></span><br><span class="line">    head-&gt;next = node;   <span class="comment">//接着将前驱结点指向新的这个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了链表的插入操作了，我们可以来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;element);   <span class="comment">//因为头结点不存放数据，所以从第二个开始打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initList(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);   <span class="comment">//依次插入3个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    printList(&amp;head);   <span class="comment">//打印一下看看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/1D94PILFxC52vRQ.png" alt="image-20220723222147977"></p><p>那么链表的插入我们研究完了，接着就是结点的删除了，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序，首先还是设计函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//head就是头结点，index依然是待删除的结点位序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们还是需要找到待删除结点的前驱结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//大体和上面是一样的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//注意删除的范围，如果前驱结点的下一个已经是NULL了，那么也说明超过了范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是按照我们上面说的删除结点了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node tmp = head-&gt;next;   <span class="comment">//先拿到待删除结点</span></span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;   <span class="comment">//直接让前驱结点指向下一个的下一个结点</span></span><br><span class="line">    <span class="built_in">free</span>(tmp);   <span class="comment">//最后使用free函数释放掉待删除结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就成功完成了链表的删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initList(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    deleteList(&amp;head, <span class="number">0</span>);   <span class="comment">//这里我们尝试删除一下第一个元素</span></span><br><span class="line">    printList(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到结果也是正确的：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/23/jnOKy6ls8wAqrHJ.png" alt="image-20220723224653754"></p><p>接着就是链表的一些其他操作了，这里我们也来实现一下，首先是获取对应位置上的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E * <span class="title function_">getList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果小于0那肯定不合法，返回NULL</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">//因为不算头结点，所以使用do-while语句</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//如果已经超出长度那肯定也不行</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (--index);  <span class="comment">//到达index就结束</span></span><br><span class="line">    <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是查找对应元素的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    head = head-&gt;next;    <span class="comment">//先走到第一个结点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;element == element) <span class="keyword">return</span> i;   <span class="comment">//如果找到，那么就返回i</span></span><br><span class="line">        head = head-&gt;next;   <span class="comment">//没找到就继续向后看</span></span><br><span class="line">        i++;   <span class="comment">//i记住要自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//都已经走到链表尾部了，那么就确实没找到了，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是求链表的长度，这个太简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;   <span class="comment">//如果下一个为NULL那就停止</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;   <span class="comment">//每向后找一个就+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的链表就编写完成了，整个代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//大体和上面是一样的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node tmp = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--index);</span><br><span class="line">    <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;element == element) <span class="keyword">return</span> i;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**问题：**请问链式实现的线性表，插入、删除、获取元素操作的时间复杂度为？</p><ul><li>**插入：**因为要寻找对应位置的前驱结点，所以平均时间复杂度为$O(n)$，但是不需要做任何的移动操作，效率肯定是比顺序表要高的。</li><li>**删除：**同上，所以平均时间复杂度为$O(n)$</li><li>**获取元素：**由于必须要挨个向后寻找，才能找到对应的结点，所以时间复杂度为$O(n)$，不支持随机访问，只能顺序访问，比顺序表慢。</li></ul><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p><strong>链表练习题：</strong></p><ol><li><p>在一个长度为<code>n (n&gt;1)</code>的单链表上，设有头和尾两个指针，执行（     ）操作与链表的长度有关？</p><p>A．删除单链表中的第一个元素<br>B．删除单链表中的最后一个元素<br>C．在单链表第一个元素前插入一个新元素<br>D．在单链表最后一个元素后插入一个新元素</p><p><em>注意题干，现在有指向链表头尾的两个指针，那么A、C肯定是可以直接通过头结点找到的，无论链表长度如何都不影响，D也可以直接通过尾指针进行拼接，只有B需要尾指针的前驱结点，此时只能从头开始遍历得到，所以选择B</em></p></li><li><p>在一个单链表HL中（HL为头结点指针），若要向表头插入一个由指针p指向的结点，则执行？</p><p>A． HL＝p; p-&gt;next＝HL;<br>B． p-&gt;next＝HL; HL＝p;<br>C． p-&gt;next＝HL; p＝HL;<br>D． p-&gt;next＝HL-&gt;next; HL-&gt;next＝p;</p><p><em>既然要在表头插入一个数据，也就是说要在第一个位置插入，那么根据我们之前讲解的链表的插入，只需要将头结点指向新的结点，再让新的结点指向原本的第一个结点即可，所以选择D</em></p></li><li><p>链表不具备的特点是？</p><p>A．可随机访问任一结点             B．插入删除不需要移动元素<br>C．不必事先估计存储空间         D．所需空间与其长度成正比</p><p><em>我们前面说了，链表由于是链式存储结构，无法直接访问到对应下标的元素，所以我们只能通过遍历去找到对应位置的元素，故选择A</em></p></li></ol><hr><h3 id="双向链表和循环链表">双向链表和循环链表</h3><p>前面我们介绍了单链表，通过这样的链式存储，我们不用再像顺序表那样一次性申请一段连续的空间，而是只需要单独为结点申请内存空间，同时在插入和删除的速度上也比顺序表轻松。不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。</p><p>为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><p>这里我们也来尝试实现一下，首先定义好结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;   <span class="comment">//保存当前元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span>   <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">prev</span>;</span>   <span class="comment">//指向上一个结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>接着是初始化方法，在初始化时需要将前驱和后继都设置为NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initNode(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是双向链表的插入操作，这就比单链表要麻烦一些了，我们先来分析一下：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/MYwlVZ2fXB6icPt.png" alt="image-20220724125739857"></p><p>首先我们需要考虑后继结点，当新的结点插入之后，新的结点的后继结点就是原本在此位置上的结点，所以我们可以先将待插入结点的后继指针指向此位置上的结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/IDYwp5gdPcSyFQO.png" alt="image-20220724130010432"></p><p>由于是双向链表，所以我们需要将原本在此位置上的结点的前驱指针指向新的结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/5CKQ6LnzxGm4pYd.png" alt="image-20220724130219180"></p><p>接着我们来处理一下前驱结点，首先将前驱结点的后继指针修改为新的结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/vmEViApU36FonJz.png" alt="image-20220724130342232"></p><p>最后我们将新的结点的前驱指针指向前驱结点即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/C65IuomOVdAaWZ8.png" alt="image-20220724130442927"></p><p>这样，我们就完成了双向链表中结点的插入操作，按照这个思路，我们来设计一下函数吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//跟单链表一样，还是先找到对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ListNode));  <span class="comment">//创建新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;element = element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next) &#123;   <span class="comment">//首先处理后继结点，现在有两种情况，一种是后继结点不存在的情况，还有一种是后继结点存在的情况</span></span><br><span class="line">        head-&gt;next-&gt;prev = node;   <span class="comment">//如果存在则修改对应的两个指针</span></span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//不存在直接将新结点的后继指针置为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = node;   <span class="comment">//接着是前驱结点，直接操作就行</span></span><br><span class="line">    node-&gt;prev = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了双向链表的插入操作，来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initNode(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)  <span class="comment">//插5个元素吧</span></span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);</span><br><span class="line"></span><br><span class="line">    Node node = &amp;head;   <span class="comment">//先来正向遍历一次</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">    &#125; <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   <span class="comment">//再来反向遍历一次</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node-&gt;prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果没有问题：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/DZ7zStdGB4EsvaW.png" alt="image-20220724132205136"></p><p>无论是正向遍历还是反向遍历，都可以正常完成，相比单链表的灵活度肯定是更大的，我们接着来看删除操作，其实删除操作也是差不多的方式：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/WgxjXBDAalYFGSH.png" alt="image-20220724132636580"></p><p>我们只需将前驱结点和后继结点的指向修改即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/3aU7zV1N5Mox2Qk.png" alt="image-20220724132801105"></p><p>接着直接删除对应的结点即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/L1zCq26k5BaGOlm.png" alt="image-20220724132906001"></p><p>现在我们就来编码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//跟单链表一样，还是先找到对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node tmp = head-&gt;next;  <span class="comment">//先拿到待删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next-&gt;next) &#123;   <span class="comment">//这里有两种情况待删除结点存在后继结点或是不存在</span></span><br><span class="line">        head-&gt;next-&gt;next-&gt;prev = head;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;   <span class="comment">//按照上面分析的来</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//相当于删的是最后一个结点，所以直接后继为NULL就完事</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);   <span class="comment">//最后释放已删除结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了双向链表的插入和删除操作，其他操作这里就不演示了。</p><p>接着我们再来简单认识一下另一种类型的链表，循环链表，这种链表实际上和前面我们讲的链表是一样的，但是它的最后一个结点，是与头结点相连的，双向链表和单向链表都可以做成这样的环形结构，我们这里以单链表为例：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/KZl4SJVYQ5cfv7b.png" alt="image-20220724134153904"></p><p>这种类型的链表实际上与普通链表的唯一区别就在于最后是否连接到头结点，因此循环链表支持从任意一个结点出发都可以到达任何的结点，而普通的链表则只能从头结点出发才能到达任意结点，同样也是为了更灵活而设计的。</p><p><strong>链表练习题：</strong></p><ol><li><p>与单链表相比，双链表的优点之一是？</p><p>A．插入、删除操作更简单<br>B．可以进行随机访问<br>C．可以省略表头指针或表尾指针<br>D．顺序访问相邻结点更灵活</p><p><em>首先插入删除操作并没有更简单，反而更复杂了，随机访问肯定也是不行的，省略表头表尾指针实际上单链表也可以，所以直接冲D就完事了</em></p></li><li><p>非空的循环单链表head的尾结点（由p所指向）满足？</p><p>A．p-&gt;next == NULL       B．p == NULL<br>C．p-&gt;next ==head         D．p == head</p><p><em>前面我们说了，循环链表实际上唯一区别就是尾部的下一个结点会指向头部，所以这里选择C</em></p></li><li><p>若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点，则采用什么存储方式最节省运算时间？</p><p>A．单链表    B．给出表头指针的单循环链表    C．双链表      D．带头结点的双循环链表</p><p><em>题干说明了常用的是在尾结点插入或删除尾结点，那么此时不仅需要快速找到最后一个结点，也需要快速找到最后一个结点的前驱结点，所以肯定是使用双向链表，为了快速找到尾结点，使用循环双向链表从头结点直接向前就能找到，所以选择D</em></p></li><li><p>如果对线性表的操作只有两种，即删除第一个元素，在最后一个元素的后面插入新元素，则最好使用？</p><p>A．只有表头指针没有表尾指针的循环单链表<br>B．只有表尾指针没有表头指针的循环单链表<br>C．非循环双链表<br>D．循环双链表</p><p><em>首先这里需要操作两个内容，一个是删除第一个元素，另一个是在最后插入新元素，所以A的话只有表头指针虽然循环但是还是得往后遍历才行，而B正好符合，因为循环链表的尾指针可以快速到达头结点，C不可能，D的话，循环双链表也可以，但是没有单链表节省空间，故B是最优解</em></p></li></ol><hr><h2 id="特殊线性表">特殊线性表</h2><p>前面我们讲解的基础的线性表，通过使用线性表，我们就可以很方便地对数据进行管理了。这一部分，我们将继续认识一些特殊的线性表，它有着特别的规则，在特定场景有着很大的作用，也是考察的重点。</p><h3 id="栈">栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们先使用顺序表来实现一下，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>首先还是按照我们的顺序表进行编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">//这里使用top来表示当前的栈顶位置，存的是栈顶元素的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> * <span class="title">ArrayStack</span>;</span>  <span class="comment">//起个别名</span></span><br></pre></td></tr></table></figure><p>接着我们需要编写一个初始化方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = <span class="number">10</span>;   <span class="comment">//容量还是10</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;   <span class="comment">//由于栈内没有元素，那么栈顶默认就为-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是栈的两个操作了，一个是入栈操作，一个是出栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="comment">//入栈操作只需要给元素就可以，不需要index，因为只能从尾部入栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于入栈只能在尾部插入，所以就很好写了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>] = element;   <span class="comment">//直接设定栈顶元素</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;   <span class="comment">//栈顶top变量记得自增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">stack</span>-&gt;top + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;<span class="built_in">stack</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果也是正确的：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/cDwAgi8FnyQBpRT.png" alt="image-20220724215755986"></p><p>可以看到，从栈底到栈顶一次是0、100、200，不过我们现在的<code>push</code>操作还不够完美，因为栈有可能塞满，所以要进行扩容处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top + <span class="number">1</span> == <span class="built_in">stack</span>-&gt;capacity) &#123;  <span class="comment">//栈顶+1如果等于容量的话，那么说明已经塞满了</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">stack</span>-&gt;capacity + (<span class="built_in">stack</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//大体操作和顺序表一致</span></span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;<span class="built_in">array</span>, newCapacity * <span class="keyword">sizeof</span>(E));</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的入栈操作就编写完成了，接着是出栈操作，出栈操作我们只需要将栈顶元素取出即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;   <span class="comment">//在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top--];   <span class="comment">//直接返回栈顶元素，注意多加一个自减操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;<span class="built_in">stack</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, popStack(&amp;<span class="built_in">stack</span>));   <span class="comment">//将栈中所有元素依次出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，出栈顺序和入栈顺序是完全相反的：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/U1SrtmFs3ibGO78.png" alt="image-20220724221238281"></p><p>当然使用数组实现栈除了这种可以自己扩容的之外，也有固定大小的栈，当栈已满时，就无法再进行入栈操作了。</p><p>不过有些时候，栈的利用率可能会很低，这个时候我们可以将一个固定长度的数组共享给两个栈来使用：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/HRveZ8Ed2TrtaC7.png" alt="image-20220724221917968"></p><p>数组的两头分别作为两个栈的栈底，当两个栈的栈顶指针相遇时（栈顶指针下标之差绝对值为1时），表示栈已满。通过这种方式，我们就可以将数组占用的空间更充分地使用，这样的栈我们称为<strong>共享栈</strong>。</p><p>前面我们演示了使用顺序表实现栈，我们接着来看如何使用链表来实现栈，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));   <span class="comment">//创建新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//失败就返回0</span></span><br><span class="line">    node-&gt;next = head-&gt;next;   <span class="comment">//将当前结点的下一个设定为头结点的下一个</span></span><br><span class="line">    node-&gt;element = element;   <span class="comment">//设置元素</span></span><br><span class="line">    head-&gt;next = node;   <span class="comment">//将头结点的下一个设定为当前结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来编写一个测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;element);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;head, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果没有问题：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/24/fy6ZCNqd3eJYIrG.png" alt="image-20220724224644876"></p><p>其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;   <span class="comment">//判断栈是否为空只需要看头结点下一个是否为NULL即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    Node top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    E e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);  <span class="comment">//别忘了释放结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> e;   <span class="comment">//返回出栈元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;head, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;head);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;head)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, popStack(&amp;head));   <span class="comment">//将栈中所有元素依次出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/07/24/xjOvlieXr2V9BZg.png" alt="image-20220724225005605"></p><p>实际上无论使用链表还是顺序表，都可以很轻松地实现栈，因为栈的插入和删除操作很特殊。</p><p><strong>栈练习题：</strong></p><ol><li><p>若进栈序列为1，2，3，4，则不可能得到的出栈序列是？</p><p>A.  3，2，1，4       B.  3，2，4，1<br>C.  4，2，3，1       D.  2，3，4，1</p><p><em>注意进栈并不一定会一次性全部进栈，可能会出现边进边出的情况，所以出栈的顺序可能有很多种情况，首先来看A，第一个出栈的是3，那么按照顺序，说明前面一定入栈了2、1，在出栈时4还没有入栈，然后是2、1最后是4，没有问题。接着是B，跟前面的A一样，不过这次是先出站3、2，而1留在栈中，接着4入栈，然后再让4、1出栈，也是正确的。然后是C，首先是4出栈，那么说明前三个一定都入栈了，而此时却紧接着的一定是3，而这里是2，错误。所以选择C</em></p></li><li><p>假设有5个整数以1、2、3、4、5的顺序被压入堆栈，且出栈顺序为3、5、4、2、1，那么栈大小至少为？</p><p>A.2<br>B.3<br>C.4<br>D.5</p><p><em>首先我们分析一下，第一个出栈的元素为3，那么也就是说前面的1、2都在栈内，所以大小至少为3，然后是5，那么说明此时栈内为1、2、4，算是出栈的5，那么至少需要的大小就是4了，所以选择C</em></p></li></ol><h3 id="队列">队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>想要实现队列也是很简单的，也可以通过两种线性表来实现，我们先来看看使用顺序表如何实现队列，假设一开始的时候队列中有0个元素，队首和队尾一般都初始都是-1这个位置：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/OKVFSEfQIkDjzNu.png" alt="image-20220725110033373"></p><p>此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/Pd6ZRUxKIhzVF9E.png" alt="image-20220725110155810"></p><p>之后都是同样的方式进行插入，队尾会一直向后移动：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/8w3Mlroz25EeIcL.png" alt="image-20220725110910388"></p><p>现在我们想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/LaZsrtwi8AkW9gh.png" alt="image-20220725111826355"></p><p>看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧？所以一般我们采用循环队列的形式，来实现重复使用一个数组（不过就没办法扩容了，大小是固定的）</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/MNaqpZRgkHcTlCU.png" alt="image-20220725112931675"></p><p>我们可以在移动队首队尾指针时，考虑循环的问题，也就是说如果到达了数组尽头，那么就直接从数组的前面重新开始计算，这样就相当于逻辑上都循环了，队首和队尾指针在一开始的时候都指向同一个位置，每入队一个新的元素，依然是先让队尾后移一位，在所指向位置插入元素，出队同理。</p><p>不过这样还是有问题，既然是循环的，那么怎么判断队列是否已满呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/eptxXASywr3b4c9.png" alt="image-20220725113824587"></p><p>由于队首指针和队尾指针重合时表示队列为空，所以我们只能舍弃一个存储单元，当队尾距离队首一个单元的时候，表示队列已满。</p><p>好了，现在理论讲解完毕，我们可以开始编写代码了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组容量</span></span><br><span class="line">    <span class="type">int</span> rear, front;   <span class="comment">//队尾、队首指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">ArrayQueue</span>;</span></span><br></pre></td></tr></table></figure><p>接着我们来对其进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;   <span class="comment">//默认情况下队首和队尾都指向0的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity == <span class="built_in">queue</span>-&gt;front)   <span class="comment">//先判断队列是否已满，如果队尾下一个就是队首，那么说明已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//队尾先向前移动一位，注意取余计算才能实现循环</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;rear] = element;   <span class="comment">//在新的位置插入元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt; &quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//遍历队列需要从队首开始</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//先向后循环移动</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[i]);  <span class="comment">//然后打印当前位置上的元素</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="built_in">queue</span>-&gt;rear);   <span class="comment">//当到达队尾时，结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/zLRWSAH8OaTgFBv.png" alt="image-20220725143455025"></p><p>我们接着来看出队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;   <span class="comment">//在出队之前需要先看看容量是否足够</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;rear == <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">pollQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//先将队首指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;front];   <span class="comment">//出队，完事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pollQueue(&amp;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/45dI2h7iWPuQJRp.png" alt="image-20220725144733780"></p><p>可以看到，队列是先进先出的，我们是以什么顺序放入队列中，那么出来的就是是什么顺序。</p><p>同样的，队列也可以使用链表来实现，并且使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    Node front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">LinkedQueue</span>;</span>   <span class="comment">//因为要存储首位两个指针，所以这里封装一个新的结构体吧</span></span><br></pre></td></tr></table></figure><p>接着是初始化，初始化的时候，需要把头结点先创建出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;   <span class="comment">//一开始两个指针都是指向头结点的，表示队列为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是入队操作，入队其实直接在后面插入新的结点就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear-&gt;next = node;   <span class="comment">//先让尾结点的下一个指向新的结点</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = node;   <span class="comment">//然后让队尾指针指向新的尾结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt; &quot;</span>);</span><br><span class="line">    Node node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;    <span class="comment">//注意不能直接判空，因为前面我们没考虑，也就没将新结点next设定为NULL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;element);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="built_in">queue</span>-&gt;rear) <span class="keyword">break</span>;    <span class="comment">//当已经打印最后一个元素后，再结束</span></span><br><span class="line">        <span class="keyword">else</span> node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/SqeNUgimC4I5aZD.png" alt="image-20220725151434438"></p><p>接着是出队操作，出队操作要相对麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">pollQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    E e = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;element;</span><br><span class="line">    Node node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front-&gt;next = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;next;  <span class="comment">//直接让头结点指向下下个结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;rear == node) <span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//如果队尾就是待出队的结点，那么队尾回到队首位置上</span></span><br><span class="line">    <span class="built_in">free</span>(node);   <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pollQueue(&amp;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://image.itbaima.cn/markdown/2022/07/25/KT8mn2RkxPvgZuF.png" alt="image-20220725152020131"></p><p>效果和前面的数组实现是一样的，只不过使用链表会更加灵活一些。</p><p><strong>队列练习题：</strong></p><ol><li><p>使用链表方式存储的队列，在进行出队操作时需要？</p><p>A. 仅修改头结点指向    B. 仅修改尾指针    C. 头结点指向、尾指针都要修改    D. 头结点指向、尾指针可能都要修改</p><p><em>首先出队肯定是要动头结点指向的，但是不一定需要动尾指针，因为只有当尾指针指向的是待出队的元素时才需要，因为执行后队列就为空了，所以需要将队尾指针移回头结点处，选择D</em></p></li><li><p>引起循环队列队头位置发生变化的操作是？</p><p>A. 出队</p><p>B. 入队</p><p>C. 获取队头元素</p><p>D. 获取队尾元素</p><p><em>这个题还是很简单的，因为只有出队操作才会使得队头位置后移，所以选择A</em></p></li></ol><hr><h2 id="算法实战">算法实战</h2><p>欢迎来到线性结构篇算法实战，这一部分我们将从算法相关题目上下手，解决实际问题，其中链表作为重点考察项目。</p><h3 id="（简单）删除链表中重复元素">（简单）删除链表中重复元素</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></p><p>给定一个已排序的链表的头 head（注意是无头结点的链表，上来第一个结点就是存放第一个元素） ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表 。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><blockquote><p>输入：head = [1,1,2]<br>输出：[1,2]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p><blockquote><p>输入：head = [1,1,2,3,3]<br>输出：[1,2,3]</p></blockquote><p>这道题实际上比较简单，只是考察各位小伙伴对于链表数据结构的掌握程度，我们只需要牢牢记住如何对链表中的元素进行删除操作就能轻松解决这道题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;  <span class="comment">//首先如果进来的就是NULL，那就不用再浪费时间了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node</span> =</span> head;  <span class="comment">//这里用一个指针来表示当前所指向的结点</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;   <span class="comment">//如果结点的下一个为空，就没必要再判断了，否则不断进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;val == node-&gt;val) &#123;  <span class="comment">//如果下一个节点跟当前节点值一样，那么删除下一个节点</span></span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;next;   <span class="comment">//否则继续从下一个节点开始向后判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;   <span class="comment">//最后原样返回头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（简单）反转链表">（简单）反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head = [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newHead</span> =</span> <span class="literal">NULL</span>, * tmp;   <span class="comment">//创建一个指针存放新的头结点（注意默认要为NULL），和一个中间暂存指针</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;   <span class="comment">//这里利用head不断向后遍历，来依次修改每个结点的指向</span></span><br><span class="line">        tmp = head;   <span class="comment">//先暂存当前结点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">//head可以先后移了</span></span><br><span class="line">        tmp-&gt;next = newHead;   <span class="comment">//将暂存节点的下一个节点，指向前一个结点</span></span><br><span class="line">        newHead = tmp;   <span class="comment">//最后新的头结点就是tmp所指向结点，这样循环操作直到结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;  <span class="comment">//最后返回新的结点即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（中等）旋转链表">（中等）旋转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></p><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4,5], k = 2<br>输出：[4,5,1,2,3]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img"></p><blockquote><p>输入：head = [0,1,2], k = 4<br>输出：[2,0,1]</p></blockquote><p>这道题需要我们进行一些思考了，首先我们要知道，在经过旋转之后最终的头结点是哪一个，在知道后，这道题就很简单了，我们只需要断掉对应头结点的指针即可，最后返回头结点，就是旋转之后的链表了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || k == <span class="number">0</span>) <span class="keyword">return</span> head;   <span class="comment">//如果给进来的链表是空的，或者说k为0，那么就没必要再继续了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next) &#123;   <span class="comment">//先来算一波链表的长度</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(k == len) <span class="keyword">return</span> head;   <span class="comment">//如果len和k长度一样，那也没必要继续了</span></span><br><span class="line">  </span><br><span class="line">    node-&gt;next = head;   <span class="comment">//将链表连起来变成循环的，一会再切割</span></span><br><span class="line">    <span class="type">int</span> index = len - k % len;  <span class="comment">//计算头结点最终位置</span></span><br><span class="line">  </span><br><span class="line">  node = head;</span><br><span class="line">    <span class="keyword">while</span> (--index) node = node-&gt;next;</span><br><span class="line">    head = node-&gt;next;    <span class="comment">//找到新的头结点</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//切断尾部与头部</span></span><br><span class="line">    <span class="keyword">return</span> head;  <span class="comment">//返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（简单）有效的括号">（简单）有效的括号</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s = “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：s = “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：s = “{[]}”<br>输出：true</p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    Node top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    E e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果长度不是偶数，那么一定不能成功匹配</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            pushStack(&amp;head, c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty(&amp;head)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般遇到括号匹配问题、算式计算问题，都可以使用栈这种数据结构来轻松解决。当然使用C语言太过原始，像Java、C++这些语言一般系统库都会直接提供栈的实现类，所以我们在打比赛时，可以尽量选择这些方便的语言，能节省不少时间。</p><h3 id="（简单）第-k-个缺失的正整数">（简单）第 k 个缺失的正整数</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></p><p>给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。</p><p>请你找到这个数组里第 k 个缺失的正整数。</p><p>示例 1：</p><blockquote><p>输入：arr = [2,3,4,7,11], k = 5<br>输出：9<br>解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,…] 。第 5 个缺失的正整数为 9 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：arr = [1,2,3,4], k = 2<br>输出：6<br>解释：缺失的正整数包括 [5,6,7,…] 。第 2 个缺失的正整数为 6 。</p></blockquote><p>实际上这种问题，我们第一个能够想到的就是直接通过遍历挨个寻找，从头开始一个一个找，总能找到第K个吧？我们可以很轻松地得到如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthPositive</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>, i = <span class="number">0</span>;   <span class="comment">//直接从第一个元素开始挨个找</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; arrSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--k == <span class="number">0</span>) <span class="keyword">return</span> j;   <span class="comment">//发现不相等时，相当于找到了一个数，k自减，如果自减后为0，那么说明已经找到第K个了，直接返回对应的j</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;  <span class="comment">//相等的话就继续看下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++;   <span class="comment">//每一轮j自增，表示下一轮应该按顺序匹配的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j + k - <span class="number">1</span>;   <span class="comment">//如果遍历完了都还没找到，那就按顺序直接算出下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样的效率并不高，如果这个数组特别长的话，那么我们总不可能还是挨个看吧？这样的遍历查找算法的时间复杂度为$O(n)$，那么有没有更好的算法能够解决这种问题呢？</p><p>既然这个数组是有序的，那么我们不妨直接采用二分搜索的思想，通过使用二分搜索，我们就可以更快速地找到对应的位置，但是有一个问题，我们怎么知道二分搜索找到的数，是不是第N个数呢？实际上也很简单，通过规律我们不难发现，如果某个位置上的数不匹配，那么被跳过的数<code>k</code>一定满足：<br>$$<br>k = arr[i] - i - 1<br>$$<br>所以，我们只需要找到一个大于等于<code>k</code>的位置即可，并且要尽可能的接近，在找到之后，再根据公式去寻找即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthPositive</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; k) <span class="keyword">return</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = arrSize;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] - mid - <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k - (arr[l - <span class="number">1</span>] - (l - <span class="number">1</span>) - <span class="number">1</span>) + arr[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>高级特性-C语言程序设计（三）</title>
    <link href="https://blog.yuncan.xyz/posts/c3.html"/>
    <id>https://blog.yuncan.xyz/posts/c3.html</id>
    <published>2023-06-21T15:25:32.000Z</published>
    <updated>2023-06-21T15:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/c_cover.jpg" alt="cover"></p><h1>C语言高级特性</h1><p>前面我们了解了C语言的相关基础内容，我们来看看C语言的高级部分。这一章的学习难道会比较大，尤其是指针板块，因为需要理解计算机内存模型，所以说是很多初学者的噩梦。</p><h2 id="函数">函数</h2><p>其实函数我们在一开始就在使用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   <span class="comment">//这是定义函数</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们程序的入口点就是<code>main</code>函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不够这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的<code>printf</code>也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);    <span class="comment">//直接通过 函数名称(参数...) 的形式调用函数</span></span><br></pre></td></tr></table></figure><p>那么，函数的具体定义是什么呢？</p><blockquote><p>函数是完成特定任务的独立程序代码单元。</p></blockquote><p>其实简单来说，函数时为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;H&quot;</span>);   <span class="comment">//比如下面这三行代码就是我们要做的任务</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;H&quot;</span>);   <span class="comment">//这里我们还需要执行这个任务</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;H&quot;</span>);   <span class="comment">//这里又要执行这个任务</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            a += <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？</p><p>这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。</p><p>我们来看看，如何创建和使用函数。</p><h3 id="创建和使用函数">创建和使用函数</h3><p>首先我们来看看如何创建一个函数，其实创建一个函数是很简单的，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名称([函数参数...]);</span><br></pre></td></tr></table></figure><p>其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。</p><p>函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，比如我们之前认识的<code>getchar</code>函数，这个函数实际上返回了一个int值作为结果（也就是我们输入的字符）我们同样可以将函数返回的结果赋值给变量或是参与运算等等。</p><p>当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以写成<code>void</code>表示为空。</p><p>函数参数我们放在下一个小节中讲解，所以这里我们不使用任何参数，所以这里也将参数设定为<code>void</code>表示没有参数（当然为了方便，我们也可以直接什么都不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">//定义函数原型，因为C语言是从上往下的，所以如果要在下面的主函数中使用这个函数，一定要定义到它的上面。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>&#123;   <span class="comment">//函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是测试函数!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或是直接在上方写上函数的具体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>&#123;   <span class="comment">//函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是测试函数!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在我们将函数定义好之后，该如何去使用呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();   <span class="comment">//这里我们只需要使用 函数名称(); 就可以调用函数了</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//实际上printf也是一个函数，功能是向控制台打印字符串，只不过这个函数是系统提供的，已经提前实现好了，其中的参数我们后续还会进行介绍。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/19/s1uqceI3g6kFiXa.png" alt="image-20220619224057060"></p><p>这样，我们就可以很好解决上面的代码复用性的问题，我们只需要将会重复使用的逻辑代码定义到函数中，当我们需要执行时，直接调用编写好的函数就可以了，这样是不是简单多了？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    test();   <span class="comment">//多次使用的情况下，函数会让我们的程序简单很多</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">20</span>) test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">            test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然函数除了可以实现代码的复用之外，也可以优化我们的程序，让我们的代码写得更有层次感，我们的程序可能会有很多很多的功能，需要写很多的代码，但是谁愿意去看一个几百行上千行的<code>main</code>函数呢？我们可以将每个功能都写到一个对应的函数中，这样就可以大大减少<code>main</code>函数中的代码量了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();   <span class="comment">//直接把多行代码写到一个函数中，在main中调用对应的函数，这样能够大幅度减少代码量</span></span><br><span class="line">    func2();</span><br><span class="line">    func3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们从一开始就在编写main函数实际上是一种比较特殊的函数，C语言规定程序一律从主函数开始执行，所以这也是为什么我们一定要写成<code>int main()</code>的形式。</p><h3 id="全局变量和局部变量">全局变量和局部变量</h3><p>现在我们已经了解了如何创建和调用函数，在继续学习后续内容之前，我们需要先认识一下全局变量和局部变量这两个概念（啊这，变量就变量，还分这么细啊？）</p><p>我们首先来看看局部变量，实际上我们之前使用的都是局部变量，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;   <span class="comment">//这里定义的变量i实际上是main函数中的局部变量，它的作用域只能是main函数中，也就是说其他地方是无法使用的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量只会在其作用域中生效：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/21/1sTwRq95uWce3Az.png" alt="image-20220621104906130"></p><p>可以看到在其他函数中，无法使用main函数中的变量，因为局部变量的作用域是有限的，比如位于某个函数内部的变量，那么它的作用域就是整个函数内部，而在其他位置均无法访问。又比如我们之前学习的for循环，当我们这样定义时：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/21/NohbirYPSBVLQap.png" alt="image-20220621110340649"></p><p>可以看到，在for循环中定义的变量i，只能在for循环内部使用，而出了这个花括号之后就用不了了，当然由于作用域不同，所以下面这种写法是完全没问题的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;   <span class="comment">//虽然这里写了两个for都使用了i，但是由于处于两个不同的作用域，所以这两个i半毛钱关系都没有</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，清楚了局部变量的作用域之后，我们在编写程序的时候就很清楚了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/21/jPTobYLNdn6sgcH.png" alt="image-20220621110503710"></p><p><img src="https://image.itbaima.cn/markdown/2022/06/21/PaACqnRBTNXkESY.png" alt="image-20220621110555759"></p><p>那么如果现在我们想要在任何位置都能使用一个变量，该怎么办呢？这时就要用到全局变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">//我们可以直接将变量定义放在外面，这样所有的函数都可以访问了</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">    test();    <span class="comment">//现在各位觉得，这两个操作完成后，a会是多少呢？</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/21/Sdya9HZ7lDMTcIA.png" alt="image-20220621111319786"></p><p>因为现在所有函数都能使用全局变量，所以这个结果不难得到。</p><h3 id="函数参数和返回">函数参数和返回</h3><p>我们的函数可以接受参数来完成任务，比如我们现在想要实现<strong>用一个函数计算两个数的和并输出到控制台。</strong></p><p>这种情况我们就需要将我们需要进行加法计算的两个数，告诉函数，这样函数才能对这两个数求和，那么怎么才能告诉函数呢？我们可以通过设定参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;   <span class="comment">//函数原型中需要写上需要的参数类型，多个参数用逗号隔开，比如这里我们需要的就是两个int类型的参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//函数具体定义中也要写上，这里的a和b我们称为形式参数（形参），等价于函数中的局部变量，作用域仅限此函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在定义完成了，该如何使用这个函数呢，还记得我们怎么使用<code>printf</code>函数的吗？我们只需要把它所需要的参数填入即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//这里直接填写一个常量、变量或是运算表达式都是可以的，我们称实际传入的值为实际参数（实参）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，成功计算出结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/21/dauFW2DNL3PnvYG.png" alt="image-20220621113243405"></p><p>实际上我们传入的实参在进入到函数时，会自动给函数中形参（局部变量）进行赋值，这样我们在函数中就可以得到外部传入的参数值了。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/23/8zv1O5ZYAQTJNoV.png" alt="image-20220623224355944"></p><p>我们来看看<code>printf</code>函数是怎么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * __restrict, ...)</span> __<span class="title function_">printflike</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;   <span class="comment">//看起来比较高级</span></span><br></pre></td></tr></table></figure><p>这里我们主要关心它的两个参数，一个是<code>char *</code>由于还没有学习指针，这里就把它当做<code>const char[]</code>就行了，表示一个不可修改的字符串，而第二个参数我们看到是<code>...</code>，这三个点是个啥？</p><p>我们知道，如果我们想要填写具体需要打印的值时，可以一直往后写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %d&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//参数可以一直写</span></span><br></pre></td></tr></table></figure><p>正常情况下我们函数的参数列表都是固定的，怎么才能像这样写很多个呢？这就要用到可变长参数了，不过可变长参数的使用比较麻烦，这里我们就不做讲解了。</p><p>这里给大家提一个问题，如果我们修改形式参数的值，外面的实参值会跟着发生修改吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d&quot;</span>, a, b);   <span class="comment">//最后会得到什么结果？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;   <span class="comment">//这里对a和b的值进行交换</span></span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/23/5QbExfHNM76pBOY.png" alt="image-20220623224752943"></p><p>通过结果发现，虽然调用了函数对a和b的值进行交换，但貌似并没有什么卵用。这是为什么呢？</p><p>还记得我们前面说的吗，函数的形参实际上就是函数内的局部变量，它的作用域仅仅是这个函数，而我们外面传入的实参，仅仅知识将值赋值给了函数内的形参而已，并且外部的变量跟函数内部的变量作用域都不同，所以半毛钱关系都没有，这里交换的仅仅是函数内部的两个形参变量值，跟外部作实参的变量没有任何关系。</p><p>那么，怎么样才能实现通过函数交换两个变量的值呢？这个问题我们会在指针部分进行讨论。</p><p>不过数组却不受限制，我们在函数中修改数组的值，是直接可以生效的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);  <span class="comment">//打印的是修改后的值了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">999</span>;   <span class="comment">//数组就可以做到这边修改，外面生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    test(a);</span><br><span class="line">    test(a);   <span class="comment">//连续两次调用，那么这两次的结果会是什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果都是20，（如果猜对了可以直接跳过，如果你猜测的是20和30的话，需要听我解释了）注意每次调用函数都是单独进行的，并不是复用函数中的形参，不要认为第一次调用函数test就将函数的局部变量变成20了，再次调用就是20+10变成30。实际上这两次调用都是单独进行的，形参a都是在一开始的时候被赋值为实参的值的，这两次调用没有任何关系，并且函数执行完毕后就自动销毁了。</p><p>那要是我就希望每次调用函数时保留变量的值呢？我们可以使用静态变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;   <span class="comment">//静态变量并不会在函数结束时销毁其值，而是保持</span></span><br><span class="line">    a += <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看函数的返回值，并不是所有的函数都是执行完毕就结束了的，可能某些时候我们需要函数告诉我们执行的结果如何，这时我们就需要用到返回值了，比如现在我们希望实现一个函数计算a+b的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span> )</span>;   <span class="comment">//现在我们要返回a和b的和（那么肯定也是int类型）所以这里需要将返回值类型修改为int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;   <span class="comment">//计算a和b的和</span></span><br><span class="line">  <span class="type">int</span> result = sum(a, b);   <span class="comment">//函数执行后，会返回一个int类型的结果，我们可以接收它，也可以像下面一样直接打印，当然也可以参与运算等等。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d&quot;</span>, sum(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;   <span class="comment">//通过return关键字来返回计算的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看下一个例子，现在我们希望你通过函数找到数组中第一个小于0的数字并将其返回，如果没有找到任何小于0的数，就返回0即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>;   <span class="comment">//需要两个参数，一个是数组本身，还有一个是数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">-9</span>, <span class="number">2</span>, <span class="number">-4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> min = findMin(arr, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个小于0的数是：%d&quot;</span>, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> arr[i];   <span class="comment">//当判断找到后，直接return返回即可，这样的话函数会直接返回结果，无论后面还有没有代码没有执行完，整个函数都会直接结束。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果没有找到就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/23/fRw8nbV15dQGIUH.png" alt="image-20220623231617525"></p><p>这里我们使用了<code>return</code>关键字来返回结果，注意当我们的程序走到<code>return</code>时，无论还有什么内容没执行完，整个函数都将结束，并返回结果。注意带返回值（非void）的函数中的所有情况都需要有一个对应的返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;   <span class="comment">//当a大于0时有返回语句</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//但是当a不大于0时就没有返回值了，这样虽然可以编译通过，但是会有警告（黄标），运行后可能会出现一些无法预知的问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是没有返回值的函数，我们也可以调用<code>return</code>来返回，不过默认情况下是可以省略的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">return</span>;   <span class="comment">//因为是void，所以什么都不需要加，直接return</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归调用">递归调用</h3><p>我们的函数除了在其他地方被调用之外，也可以自己调用自己（好家伙，套娃是吧），这种玩法我们称为递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    test();   <span class="comment">//函数自己在调用自己，这样的话下一轮又会进入到这个函数中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以尝试运行一下上面的程序，会发现程序直接无限打印<code>Hello World!</code>这个字符串，这是因为函数自己在调用自己，不断地重复进入到这个函数，理论情况下，它将永远都不会结束，而是无限地执行这个函数的内容。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/23/feq6xUPDjSLAKYF.png" alt="image-20220623233305190"></p><p>但是到最后我们的程序还是终止了，这是因为函数调用有最大的深度限制，因为计算机不可能放任函数无限地进行下去。</p><blockquote><p><strong>（选学）<strong>我们来大致了解一下函数的调用过程，实际上在程序运行时会有一个叫做</strong>函数调用栈</strong>的东西，它用于控制函数的调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   <span class="comment">//我们以下面的调用关系为例</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    test2();   <span class="comment">//main -&gt; test -&gt; test2</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;giao&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以很轻易地看出整个调用关系，首先是从main函数进入，然后调用test函数，在test函数中又调用了test2函数，此时我们就需要等待test2函数执行完毕，test才能继续，而main则需要等待test执行完毕才能继续。而实际上这个过程是由函数调用栈在控制的：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/23/lAfGyoDWBstz6bm.png" alt="image-20220623235007335"></p><p>而当test2函数执行完毕后，每个栈帧又依次从栈中出去：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/23/IWYsq8m2htNeEaP.png" alt="image-20220623235649397"></p><p>当所有的栈全部出去之后，程序结束。</p><p>所以这也就不难解释为什么无限递归会导致程序出现错误，因为栈的空间有限，而函数又一直在进行自我调用，所以会导致不断地有新的栈帧进入，最后塞满整个栈的空间，就爆炸了，这种问题我们称为栈溢出（Stack Overflow）</p></blockquote><p>当然，如果我们好好地按照规范使用递归操作，是非常方便的，比如我们现在需要求某个数的阶乘：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, test(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//因为不能无限制递归下去，所以我们这里添加一个结束条件，在n = 1时返回</span></span><br><span class="line">    <span class="keyword">return</span> test(n - <span class="number">1</span>) * n;  <span class="comment">//每次都让n乘以其下一级的计算结果，下一级就是n-1了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给递归调用适当地添加结束条件，这样就不会无限循环了，并且我们的程序看起来无比简洁，那么它是如何执行的呢：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/24/SsJWqGKyQko47Mm.png" alt="image-20220624002051266"></p><p>它看起来就像是一个先走到底部，然后拿到问题的钥匙后逐步返回的一个过程，并在返回的途中不断进行计算最后得到结果（妙啊）</p><p>所以，合理地使用递归反而是一件很有意思的事情。</p><h3 id="实战：斐波那契数列解法其三">实战：斐波那契数列解法其三</h3><p>前面我们介绍了函数的递归调用，我们来看一个具体的实例吧，我们还是以解斐波那契数列为例。</p><p>既然每个数都是前两个数之和，那么我们是否也可以通过递归的形式不断划分进行计算呢？我们依然可以借鉴之前动态规划的思想，通过划分子问题，分而治之来完成计算。</p><h3 id="实战：汉诺塔">实战：汉诺塔</h3><p>什么是汉诺塔？</p><blockquote><p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904">印度</a>古老传说的<a href="https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159">益智玩具</a>。<a href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始</p><p><strong>按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</strong></p></blockquote><p><img src="https://image.itbaima.cn/markdown/2022/06/24/Z7iN526FOQLS3Kz.png" alt="image-20220624002507501"></p><p>这三根柱子我们就依次命名为A、B、C，现在请你设计一个C语言程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。</p><p>这个问题看似很难，实际上我们也可以对每一步进行推理：</p><blockquote><p>当汉诺塔只有1阶的情况下：直接把A上的圆盘移动到C，搞定。</p></blockquote><blockquote><p>当汉诺塔只有2阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的1个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的1个圆盘丢到C上去</p></blockquote><blockquote><p>当汉诺塔只有3阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的2个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的2个圆盘丢到C上</p></blockquote><p>实际上我们发现，把A移动到C是一定要进行的，而在进行之前需要先把压在上面全部的圆盘全部放到B去。而移动之后也要把B上的圆盘全部移动到C上去。其实所有的情况下最终都会有一个n=1的情况，将A上的最后一个圆盘移动到C，只是多了一个前面的步骤和后面的步骤。</p><p>不过难点就是，怎么把A上的n-1个圆盘移动到B去呢？其实这时我们可以依靠C作为中间商，来帮助我们移动（比如n = 3，那么先把最上面的移动到C，然后把第二大的移动到B，再从C上把最小的移动到B上，这样就借助了C完成了两个圆盘的转移），而最后又怎么把B上的圆盘全部移到C去呢，这时就可以依靠A作为中间商，方法同理；实际上大问题最后都会变成n = 2时这样的小问题，只不过是要移动目标不同罢了。</p><p>只要想通了怎么去借助中间商进行移动，就很好写出程序了。</p><p>递归函数如下设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a存放圆盘的初始柱子，b作为中间柱子存放使用，c作为目标柱子，n表示要从a移动到c的圆盘数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来实现一下吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> n)</span>&#123;   <span class="comment">//用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d个圆盘：%c --&gt; %c\n&quot;</span>, n, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c, <span class="type">int</span> n)</span>&#123;  <span class="comment">//刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        move(a, c, n);   <span class="comment">//无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        hanoi(a, c ,b, n - <span class="number">1</span>);  <span class="comment">//首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间</span></span><br><span class="line">        move(a, c, n);   <span class="comment">//现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去</span></span><br><span class="line">        hanoi(b, a, c, n - <span class="number">1</span>);   <span class="comment">//最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化一波：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    hanoi(a, c ,b, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d个圆盘：%c --&gt; %c\n&quot;</span>, n, a, c);</span><br><span class="line">    hanoi(b, a, c, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似如此复杂的问题，其实只需要4行就可以解决了。</p><h3 id="实战：快速排序算法（选学）">实战：快速排序算法（选学）</h3><p>有一个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>现在请你设计一个C语言程序，对数组按照从小到大的顺序进行排序。这里我们使用冒泡排序的进阶版本——<strong>快速排序</strong>来完成，它的核心思想是分而治之，每一轮排序都会选出一个基准，一轮排序完成后，所以比基准小的数一定在左边，比基准大的数一定在右边，在分别通过同样的方法对左右两边的数组进行排序，不断划分，最后完成整个数组的排序。它的效率相比冒泡排序的双重for循环有所提升。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;  <span class="comment">//arr是数组，left是起始下标，right是结束下标</span></span><br><span class="line">    <span class="comment">//请实现这一部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, <span class="number">9</span>);  <span class="comment">//10个数字下标就是0-9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过虽然这种排序算法很快，但是极端情况下（比如遇到了刚好倒序的数组）还是会退化成冒泡排序的。</p><hr><h2 id="指针">指针</h2><p>指针可以说是整个C语言中最难以理解的部分了，不过其实说简单也简单，你会发现也并没有想象中的那么难，你与它的距离可能只差了那么一些基础知识，这一部分都会及时进行补充的。</p><h3 id="什么是指针">什么是指针</h3><p>还记得我们在上一个部分谈到的通过函数交换两个变量的值吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d&quot;</span>, a, b);   <span class="comment">//最后会得到什么结果？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;   <span class="comment">//这里对a和b的值进行交换</span></span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种写法是错误的，因为交换的并非是真正的a和b，而是函数中的局部变量。那么有没有办法能够直接对函数外部的变量进行操作呢？这就需要指针的帮助了。</p><p>我们知道，程序中使用的变量实际上都在内存中创建的，每个变量都会被保存在内存的某一个位置上（具体在哪个位置是由系统分配的），就像我们最终会在这个世界上的某个角落安家一样，所有的变量在对应的内存位置上都有一个地址（地址是独一无二的），而我们可以通过这个地址寻找到这个变量本体，比如int占据4字节，因此int类型变量的地址就是这4个字节的起始地址，后面32个bit位全部都是用于存放此变量的值的。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/24/zi5ZwxK76REpYUI.png" alt="image-20220624221635066"></p><p>这里的<code>0x</code>是十六进制的表示形式（10-15用字母A - F表示）如果我们能够知道变量的内存地址，那么无论身在何处，都可以通过地址找到这个变量了。而指针的作用，就是专门用来保存这个内存地址的。</p><p>我们来看看如何创建一个指针变量用于保存变量的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针</span></span><br><span class="line">    <span class="type">int</span> * p = &amp;a;   <span class="comment">//这里的&amp;并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a在内存中的地址为：%p&quot;</span>, p);  <span class="comment">//地址使用%p表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/24/Pb3cWuOFIMkJLEa.png" alt="image-20220624222718731"></p><p>可以看到，我们通过取地址操作<code>&amp;</code>，将变量a的地址保存到了一个地址变量<code>p</code>中。</p><p>拿到指针之后，我们可以很轻松地获取指针所指地址上的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">666</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存%p上存储的值为：%d&quot;</span>, p, *p);   <span class="comment">//我们可以在指针变量前添加一个*号（间接运算符，也可以叫做解引用运算符）来获取对应地址存储的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里访问指针所指向地址的值时，是根据类型来获取的，比如int类型占据4个字节，那么就读取地址后面4个字节的内容作为一个int值，如果指针是char类型的，那么就只读取地址后面1个字节作为char类型的值。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/24/GHS8UAoKNT6vZXy.png" alt="image-20220624224026228"></p><p>同样的，我们也可以直接像这样去修改对应地址存放的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">666</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">999</span>;   <span class="comment">//通过*来访问对应地址的值，并通过赋值运算对其进行修改</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值为：%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/24/3gFKBEuRQlD8wpq.png" alt="image-20220624225026394"></p><p>实际上拿到一个变量的地址之后，我们完全不需要再使用这个变量，而是可以通过它的指针来对其进行各种修改。因此，现在我们想要实现对两个变量的值进行交换的函数就很简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是两个指针类型的形参，其值为实参传入的地址，</span></span><br><span class="line"><span class="comment">// 虽然依然是值传递，但是这里传递的可是地址啊，</span></span><br><span class="line"><span class="comment">// 只要知道地址改变量还不是轻轻松松？</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> * b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;   <span class="comment">//先暂存一下变量a地址上的值</span></span><br><span class="line">    *a = *b;   <span class="comment">//将变量b地址上的值赋值给变量a对应的位置</span></span><br><span class="line">    *b = tmp;   <span class="comment">//最后将a的值赋值给b对应位置，OK，这样就成功交换两个变量的值了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    swap(&amp;a, &amp;b);   <span class="comment">//只需要把a和b的内存地址给过去就行了，这里取一下地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/24/8U6pSiKeEFTg2H4.png" alt="image-20220624225800731"></p><p>通过地址操作，我们就轻松实现了使用函数交换两个变量的值了。</p><p>了解了指针的相关操作之后，我们再来看看<code>scanf</code>函数，实际上就很好理解了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);   <span class="comment">//这里就是取地址，我们需要告诉scanf函数变量的地址，这样它才能通过指针访问变量的内存地址，对我们变量的值进行修改，这也是为什么scanf里面的变量（除数组外）前面都要进行一个取地址操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，和变量一样，要是咱们不给指针变量赋初始值的话，就不知道指的哪里了，因为指针变量也是变量，存放的其他变量的地址值也在内存中保存，如果不给初始值，那么存放别人地址的这块内存可能在其他地方使用过，这样就不知道初始值是多少了（那么指向的地址可能是一个很危险的地址，随意使用可能导致会出现严重错误），所以一定要记得给个初始值或是将其设定为NULL，表示空指针，不指向任何内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * a = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看看<code>const</code>类型的指针，这种指针比较特殊：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * p = &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;   <span class="comment">//这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改</span></span><br><span class="line">  p = &amp;b;   <span class="comment">//但是指针指向的地址是可以发生改变的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看另一种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> p = &amp;a;   <span class="comment">//const关键字被放在了类型后面</span></span><br><span class="line">    *p = <span class="number">20</span>;   <span class="comment">//允许修改所指地址上的值</span></span><br><span class="line">    p = &amp;b;   <span class="comment">//但是不允许修改指针存储的地址值，其实就是反过来了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以双管齐下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;   <span class="comment">//两个都直接报错，都不让改了</span></span><br><span class="line">    p = &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针与数组">指针与数组</h3><p>前面我们介绍了指针的基本使用，我们来回顾一个问题，为什么数组可以以原身在函数之间进行传递呢？先说结论，数组表示法实际上是在变相地使用指针，你甚至可以将其理解为数组变量其实就是一个指针变量，它存放的就是数组中第一个元素的起始地址。</p><p>为什么这么说？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * p = str;   <span class="comment">//？？？啥情况，为什么能直接把数组作为地址赋值给指针变量p？？？</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);   <span class="comment">//还能正常使用，打印出第一个字符？？？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/24/WaPeLR8o295YpsC.png" alt="image-20220624231833371"></p><p>你以为这就完了？还能这样玩呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * p = str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p[<span class="number">1</span>]);   <span class="comment">//？？？怎么像在使用数组一样用指针？？？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/24/hV6orYOmebDRyJG.png" alt="image-20220624232337311"></p><p>太迷了吧，怎么数组和指针还能这样混着用呢？我们先来看看数组在内存中是如何存放的：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/24/ij6eKTYqDSxL7tE.png" alt="image-20220624233249216"></p><p>数组在内存中是一块连续的空间，所以为什么声明数组一定要明确类型和大小，因为这一块连续的内存空间生成后就固定了。</p><p>而我们的数组变量实际上存放的就是首元素的地址，而实际上我们之前一直使用的都是<strong>数组表示法</strong>来操作数组，这样可以很方便地让我们对内存中的各个元素值进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[<span class="number">0</span>]);   <span class="comment">//直接在中括号中输入对应的下标就能访问对应位置上的数组了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们知道实际上<code>str</code>表示的就是数组的首地址，所以我们完全可以将其赋值给一个指针变量，因为指针变量也是存放的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="type">char</span> * p = str;   <span class="comment">//直接把str代表的首元素地址给到p</span></span><br></pre></td></tr></table></figure><p>而使用指针后，实际上我们可以使用另一种表示法来操作数组，这种表示法叫做<strong>指针表示法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * p = str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个元素值为：%c，第二个元素值为：%c&quot;</span>, *p, *(p+<span class="number">1</span>));   <span class="comment">//通过指针也可以表示对应位置上的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们现在需要表示数组中的第二个元素：</p><ul><li>数组表示法：<code>str[1]</code></li><li>指针表示法：<code>*(p+1)</code></li></ul><p>虽然写法不同，但是他们表示的意义是完全相同的，都代表了数组中的第二个元素，其中指针表示法使用了<code>p+1</code>的形式表示第二个元素，这里的<code>+1</code>操作并不是让地址+1，而是让地址<code>+ 一倍的对应类型大小</code>，也就是说地址后移一个char的长度，所以正好指向了第二个元素，然后通过<code>*</code>取到对应的值（注意这种操作仅对数组是有意义的，如果是普通的变量，虽然也可以通过这种方式获得后一个char的长度的数据，但是毫无意义）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(p+i)   &lt;=&gt;    str[i]    <span class="comment">//实际上就是可以相互转换的</span></span><br></pre></td></tr></table></figure><p>这两种表示法都可以对内存中存放的数组内容进行操作，只是写法不同罢了，所以你会看到数组和指针混用也就不奇怪了。了解了这些东西之后，我们来看看下面的各个表达式分别代表什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*p   <span class="comment">//数组的第一个元素</span></span><br><span class="line">p   <span class="comment">//数组的第一个元素的地址</span></span><br><span class="line">p == str   <span class="comment">//肯定是真，因为都是数组首元素地址</span></span><br><span class="line">*str    <span class="comment">//因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法</span></span><br><span class="line">&amp;str[<span class="number">0</span>]   <span class="comment">//这里得到的实际上还是首元素的地址</span></span><br><span class="line">*(p + <span class="number">1</span>)   <span class="comment">//代表第二个元素</span></span><br><span class="line">p + <span class="number">1</span>    <span class="comment">//第二个元素的内存地址</span></span><br><span class="line">*p + <span class="number">1</span>    <span class="comment">//注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符&#x27;K&#x27;</span></span><br></pre></td></tr></table></figure><p>所以不难理解，为什么<code>printf</code>函数的参数是一个<code>const char * </code>了，实际上就是需要我们传入一个字符串而已，只不过这里采用的是指针表示法而已。</p><p>当然指针也可以进行自增和自减操作，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * p = str;</span><br><span class="line"></span><br><span class="line">    p++;  <span class="comment">//自增后相当于指针指向了第二个元素的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);   <span class="comment">//所以这里打印的就是第二个元素的值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一维数组看完了，我们来看看二维数组，那么二维数组在内存中是如何表示的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>这是一个2x3的二维数组，其中存放了两个能够容纳三个元素的数组，在内存中，是这样的：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/25/nEOomiYuMI7UWNy.png" alt="image-20220625113701632"></p><p>所以虽然我们可以使用二维数组的语法来访问这些元素，但其实我们也可以使用指针来进行访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> * p = arr[<span class="number">0</span>];  <span class="comment">//因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针</span></span><br><span class="line">    <span class="comment">//同理如果这里是arr[1]的话那么就表示指向二维数组中第二个数组的首元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d = %d&quot;</span>, *(p + <span class="number">4</span>), arr[<span class="number">1</span>][<span class="number">1</span>]);   <span class="comment">//实际上这两种访问形式都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多级指针">多级指针</h3><p>我们知道，实际上指针本身也是一个变量，它存放的是目标的地址，但是它本身作为一个变量，它也要将地址信息保存到内存中，所以，实际上当我们有指针之后：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/25/NLyVRJU8OmYBTlM.png" alt="image-20220625105757445"></p><p>实际上，我们我们还可以继续创建一个指向指针变量地址的指针，甚至可以创建更多级（比如指向指针的指针的指针）比如现在我们要创建一个指向指针的指针：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/25/ISWsVwEDlqLFPbd.png" alt="image-20220625110252586"></p><p>落实到咱们的代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;   <span class="comment">//指向普通变量的指针</span></span><br><span class="line">    <span class="comment">//因为现在要指向一个int *类型的变量，所以类型为int* 再加一个*</span></span><br><span class="line">    <span class="type">int</span> ** pp = &amp;p;   <span class="comment">//指向指针的指针（二级指针）</span></span><br><span class="line">    <span class="type">int</span> *** ppp = &amp;pp;   <span class="comment">//指向指针的指针的指针（三级指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们如何访问对应地址上的值呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line">    <span class="type">int</span> ** pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p, a = %d&quot;</span>, *pp, **pp);  <span class="comment">//使用一次*表示二级指针指向的指针变量，继续使用一次*会继续解析成指针变量所指的普通变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质其实就是一个套娃而已，只要把各个层次分清楚，实际上还是很好理解的。</p><p>**特别提醒：**一级指针可以操作一维数组，那么二级指针是否可以操作二维数组呢？不能！因为二级指针的含义都不一样了，它是表示指针的指针，而不是表示某个元素的指针了。下面我们会认识数组指针，准确的说它才更贴近于二维数组的形式。</p><h3 id="指针数组与数组指针">指针数组与数组指针</h3><p>前面我们了解了指针的一些基本操作，包括它与数组的一些关系。我们接着来看指针数组和数组指针，这两词语看着就容易搞混，不过哪个词在后面就哪个，我们先来看指针数组，虽然名字很像数组指针，但是它本质上是一个数组，不过这个数组是用于存放指针的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">int</span> * arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;   <span class="comment">//可以看到，实际上本质还是数组，只不过存的都是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个数组中全都是指针，比如现在我们想要访问数组中第一个指针指向的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">int</span> * arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line"></span><br><span class="line">    *arr[<span class="number">0</span>] = <span class="number">999</span>;   <span class="comment">//[]运算符的优先级更高，所以这里先通过[0]取出地址，然后再使用*将值赋值到对应的地址上</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以用二级指针变量来得到指针数组的首元素地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * p[<span class="number">3</span>];   <span class="comment">//因为数组内全是指针</span></span><br><span class="line">    <span class="type">int</span> ** pp = p;  <span class="comment">//所以可以直接使用指向指针的指针来指向数组中的第一个指针元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上指针数组还是很好理解的，那么数组指针呢？可以看到指针在后，说明本质是一个指针，不过这个指针比较特殊，它是一个指向数组的指针（注意它的目标是整个数组，和我们之前认识的指针不同，之前认识的指针是指向某种类型变量的指针）</p><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p;   <span class="comment">//指向int类型的指针</span></span><br></pre></td></tr></table></figure><p>而数组指针则表示指向整个数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];   <span class="comment">//注意这里需要将*p括起来，因为[]的优先级更高</span></span><br></pre></td></tr></table></figure><p>注意它的目标是整个数组，而不是普通的指针那样指向的是数组的首个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>] = &amp;arr;  <span class="comment">//直接对整个数组再取一次地址（因为数组指针代表的是整个数组的地址，虽然和普通指针都是指向首元素地址，但是意义不同）</span></span><br></pre></td></tr></table></figure><p>那么现在已经取到了指向整个数组的指针，该怎么去使用呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>] = &amp;arr;  <span class="comment">//直接对整个数组再取一次地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, *(*p+<span class="number">0</span>), *(*p+<span class="number">1</span>), *(*p+<span class="number">2</span>));   <span class="comment">//要获取数组中的每个元素，稍微有点麻烦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此时：</p><ul><li><code>p</code>代表整个数组的地址</li><li><code>*p</code>表示所指向数组中首元素的地址</li><li><code>*p+i</code>表示所指向数组中第<code>i</code>个（0开始）元素的地址（实际上这里的*p就是指向首元素的指针）</li><li><code>*(*p + i)</code>就是取对应地址上的值了</li></ul><p>虽然在处理一维数组上感觉有点麻烦，但是它同样也可以处理二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>] = &#123;&#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>&#125;, &#123;<span class="number">444</span>, <span class="number">555</span>, <span class="number">666</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>] = arr;  <span class="comment">//二维数组不需要再取地址了，因为现在维度提升，数组指针指向的是二维数组中的其中一个元素（因为元素本身就是一个数组）</span></span><br></pre></td></tr></table></figure><p>比如现在我们想要访问第一个数组的第二个元素，根据上面p各种情况下的意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(*p+<span class="number">1</span>));   <span class="comment">//因为上面直接指向的就是第一个数组，所以想要获取第一个元素和之前是一模一样的</span></span><br></pre></td></tr></table></figure><p>那么要是我们现在想要获取第二个数组中的最后一个元素呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(*(p+<span class="number">1</span>)+<span class="number">2</span>);   <span class="comment">//首先*(p+1)为一个整体，表示第二个数组（因为是数组指针，所以这里+1一次性跳一个数组的长度），然后再到外层+2表示数组中的第三个元素，最后再取地址，就是第二个数组的第三个元素了</span></span><br></pre></td></tr></table></figure><p>当然也可以使用数组表示法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">&quot;%d&quot;</span>, p[<span class="number">1</span>][<span class="number">2</span>]);   <span class="comment">//好家伙，这不就是二维数组的用法吗，没错，看似很难，你甚至可以认为这两用着是同一个东西</span></span><br></pre></td></tr></table></figure><h3 id="指针函数与函数指针">指针函数与函数指针</h3><p>我们的函数可以返回一个指针类型的结果，这种函数我们就称为<strong>指针函数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">test</span><span class="params">(<span class="type">int</span> * a)</span>&#123;   <span class="comment">//函数的返回值类型是int *指针类型的</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * p = test(&amp;a);   <span class="comment">//使用指针去接受函数的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *test(&amp;a));   <span class="comment">//当然也可以直接把间接运算符在函数调用前面表示直接对返回的地址取地址上的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意指针函数不要尝试去返回一个局部变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = a;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;   <span class="comment">//返回局部变量i的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * p = test(<span class="number">20</span>);   <span class="comment">//连续调用两次test函数</span></span><br><span class="line">    test(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);   <span class="comment">//最后结果可能并不是我们想的那样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/my89qFcS73J4Hif.png" alt="image-20220625133343155"></p><p>为什么会这样呢？还记得我们前面说的吗？函数一旦返回，那么其中的局部变量就会全部销毁了，至于这段内存之后又会被怎么去使用，我们也就不得而知了。</p><p><em>局部变量其实是存放在栈帧中的，如果前面的选学部分听了之后，你就知道为什么这里得到的是第二次的30了，因为第二次调用的栈帧入栈后就覆盖了这段内存，又因为是同一个函数所以栈帧结构是一样的，最后在同样的位置就存放了新的30这个值。</em></p><p>我们接着来看<strong>函数指针</strong>，实际上指针除了指向一个变量之外，也可以指向一个函数，当然函数指针本身还是一个指针，所以依然是用变量表示，但是它代表的是一个函数的地址（编译时系统会为函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址）</p><p>我们来看看如何定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//类型 (*指针变量名称)(函数参数...)  //注意一定要把*和指针变量名称括起来，不然优先级不够</span></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拿到了函数的地址，既然拿到函数的地址，那么我们就可以通过函数的指针调用这个函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = sum;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = (*p)(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//就像我们正常使用函数那样，(*p)表示这个函数，后面依然是在小括号里面填上实参</span></span><br><span class="line">  <span class="type">int</span> result = p(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//当然也可以直接写函数指针变量名称，效果一样（咋感觉就是给函数换了个名呢）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了函数指针，我们就可以编写函数回调了（所谓回调就让别人去调用我们提供的函数，而不是我们主动来调别人的函数），比如现在我们定义了一个函数，不过这个函数需要参数通过一个处理的逻辑才能正常运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//将函数指针作为参数传入</span></span><br><span class="line">  <span class="comment">//函数回调</span></span><br><span class="line">    <span class="keyword">return</span> p(a, b);    <span class="comment">//就像你进了公司然后花钱请别人帮你写代码，工资咱们五五开，属于是直接让别人帮你实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们就还要给他一个其他函数的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumImpl</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这个函数实现了a + b</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = sumImpl;  <span class="comment">//拿到实现那个函数的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum(p, <span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，函数指针也可以保存一组函数的地址，成为函数指针数组，但是这里就不多说了，相信各位已经快顶不住了吧。</p><h3 id="实战：合并两个有序数组">实战：合并两个有序数组</h3><p><strong>来源：力扣 No.88 合并两个有序数组</strong>：<a href="https://leetcode.cn/problems/merge-sorted-array/">https://leetcode.cn/problems/merge-sorted-array/</a></p><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><blockquote><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p>示例 2：</p><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。</p><p>示例 3：</p><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p></blockquote><p>现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实战：二维数组中的查找">实战：二维数组中的查找</h3><p><strong>来源：剑指Offer 04. 二维数组中的查找</strong>：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><blockquote><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]</p><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p></blockquote><p>现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入 **matrix 是长度为 matrixSize 的数组指针的数组，其中每个元素（也是一个数组）</span></span><br><span class="line"><span class="comment"> * 的长度组成 *matrixColSize 数组作为另一输入，*matrixColSize 数组的长度也为 matrixSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="结构体、联合体和枚举">结构体、联合体和枚举</h2><p>终于熬过了最难的一个部分，后面的内容就相对简单多了，我们接着来看结构体。</p><p>我们之前认识过很多种数据类型，包括整数、小数、字符、数组等，通过使用对应的数据类型，我们就可以很轻松地将我们的数据进行保存了，但是有些时候，这种简单类型很难去表示一些复杂结构。</p><h3 id="创建和使用结构体">创建和使用结构体</h3><p>比如现在我们要保存100个学生的信息（学生信息包括学号、姓名、年龄）我们发现似乎找不到一种数据类型能够同时保存这三种数据（数组虽然能保存一些列的元素，但是只能保存同种类型的）。但是如果把它们拆开单独存在，就可以使用对应的类型存放了，不过这样也太不方便了吧，这些数据应该是捆绑在一起的，而不是单独地去存放。所以，为了解决这种问题，C语言提供了结构体类型，它能够将多种类型的数据集结到一起，让他们形成一个整体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>   <span class="comment">//使用 (struct关键字 + 结构体类型名称) 来声明结构体类型，这种类型是我们自己创建的（同样也可以作为函数的参数、返回值之类的）</span></span><br><span class="line">    <span class="type">int</span> id;    <span class="comment">//结构体中可以包含多个不同类型的数据，这些数据共同组成了整个结构体类型（当然结构体内部也能包含结构体类型的变量）</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> * name;   <span class="comment">//用户名可以用指针指向一个字符串，也可以用char数组来存，如果是指针的话，那么数据不会存在结构体中，只会存放字符串的地址，但是如果是数组的话，数据会存放在结构体中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>   <span class="comment">//也可以以局部形式存在</span></span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好结构体后，我们只需要使用结构体名称作为类型就可以创建一个结构体变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//类型需要写为struct Student，后面就是变量名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;     <span class="comment">//结构体包含多种类型的数据（它们是一个整体），只需要把这些数据依次写好放在花括号里面就行了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">&#125; s;  <span class="comment">//也可以直接在花括号后面写上变量名称（多个用逗号隔开），声明一个全局变量</span></span><br></pre></td></tr></table></figure><p>这样我们就创建好了一个结构体变量，而这个结构体表示的就是学号为1、年龄18、名称为小明的结构体数据了。</p><p>当然，结构体的初始化需要注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>&#125;;   <span class="comment">//如果只写一半，那么只会初始化其中一部分数据，剩余的内容相当于没有初始值，跟数组是一样的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span> =</span> &#123;<span class="number">1</span>, .name = <span class="string">&quot;小红&quot;</span>&#125;;   <span class="comment">//也可以指定去初始化哪一个属性 .变量名称 = 初始值</span></span><br></pre></td></tr></table></figure><p>那么现在我们拿到结构体变量之后，怎么去访问结构体内部存储的各种数据呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;id = %d, age = %d, name = %s&quot;</span>, s.id, s.age, s.name);  <span class="comment">//结构体变量.数据名称 (这里.也是一种运算符) 就可以访问结构体中存放的对应的数据了</span></span><br></pre></td></tr></table></figure><p>是不是很简单？当然我们也可以通过同样的方式对结构体中的数据进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    s.name = <span class="string">&quot;小红&quot;</span>;</span><br><span class="line">  s.age = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id = %d, age = %d, name = %s&quot;</span>, s.id, s.age, s.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么结构体在内存中占据的大小是如何计算的呢？比如下面的这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们可以借助<code>sizeof</code>关键字来帮助我们计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int类型的大小是：%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">//sizeof能够计算数据在内存中所占据的空间大小（字节为单位）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/GvmlqIwNQn6Eszo.png" alt="image-20220625220121753"></p><p>当然也可以计算变量的值占据的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int arr[10]占据的大小是：%lu&quot;</span>, <span class="keyword">sizeof</span> (arr)); <span class="comment">//在判断非类型时，sizeof 括号可省</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/yogRvUqtucjkYa7.png" alt="image-20220625220323403"></p><p>同样的，它也能计算我们的结构体类型会占用多少的空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Object));   <span class="comment">//直接填入struct Object作为类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/evxSWPQGMZgEoaA.png" alt="image-20220625223336229"></p><p>可以看到结果是8，那么，这个8字节是咋算出来的呢？</p><blockquote><p>int（4字节）+ short（2字节）+ char（1字节） =  7字节（这咋看都算不出来12啊？）</p></blockquote><p>实际上结构体的大小是遵循下面的规则来进行计算的：</p><ul><li>结构体中的各个数据要求字节对齐，规则如下：<ul><li>**规则一：**结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列的。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上（0默认是所有大小的整数倍）</li><li>**规则二：**如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。</li><li>**规则三：**基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。</li></ul></li></ul><p>这里我们以下面的为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> a;   <span class="comment">//char占据1个字节</span></span><br><span class="line">    <span class="type">int</span> b;   <span class="comment">//int占据4个字节，因为前面存了一个char，按理说应该从第2个字节开始存放，但是根据规则一，必须在自己的整数倍位置上存放，所以2不是4的整数倍位置，这时离1最近的下一个整数倍地址就是4了，所以前面空3个字节的位置出来，然后再放置</span></span><br><span class="line">    <span class="type">short</span> c; <span class="comment">//前面存完int之后，就是从8开始了，刚好满足short（2字节）的整数倍，但是根据规则二，整个结构体大小必须是最大对齐大小的整数倍（这里最大对齐大小是int，所以是4），存完short之后，只有10个字节，所以屁股后面再补两个空字节，这样就可以了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/gpPDKMLw7z3GBOC.png" alt="image-20220625224302673"></p><p>这样，就不难得出为什么结构体的大小是12了。</p><h3 id="结构体数组和指针">结构体数组和指针</h3><p>前面我们介绍了结构体，现在我们可以将各种类型的数据全部安排到结构体中一起存放了。</p><p>不过仅仅只是使用结构体，还不够，我们可能需要保存很多个学生的信息，所以我们需要使用结构体类型的数组来进行保存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">arr</span>[3] =</span> &#123;&#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;,   <span class="comment">//声明一个结构体类型的数组，其实和基本类型声明数组是一样的</span></span><br><span class="line">                             &#123;<span class="number">2</span>, <span class="number">17</span>, <span class="string">&quot;小红&quot;</span>&#125;,   <span class="comment">//多个结构体数据用逗号隔开</span></span><br><span class="line">                             &#123;<span class="number">3</span>, <span class="number">18</span>, <span class="string">&quot;小刚&quot;</span>&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在如果我们想要访问数组中第二个结构体的名称属性，该怎么做呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">arr</span>[3] =</span> &#123;&#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">2</span>, <span class="number">17</span>, <span class="string">&quot;小红&quot;</span>&#125;,</span><br><span class="line">                             &#123;<span class="number">3</span>, <span class="number">18</span>, <span class="string">&quot;小刚&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr[<span class="number">1</span>].name);   <span class="comment">//先通过arr[1]拿到第二个结构体，然后再通过同样的方式 .数据名称 就可以拿到对应的值了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除了数组之外，我们可以创建一个指向结构体的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span> =</span> &amp;student;   <span class="comment">//同样的，类型后面加上*就是一个结构体类型的指针了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们拿到结构体类型的指针后，实际上指向的就是结构体对应的内存地址，和之前一样，我们也可以通过地址去访问结构体中的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span> =</span> &amp;student;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (*p).name);  <span class="comment">//由于.运算符优先级更高，所以需要先使用*p得到地址上的值，然后再去访问对应数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样写起来太累了，我们可以使用简便写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p-&gt;name);   <span class="comment">//使用 -&gt; 运算符来快速将指针所指结构体的对应数据取出</span></span><br></pre></td></tr></table></figure><p>我们来看看结构体作为参数在函数之间进行传递时会经历什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Student student)</span>&#123;</span><br><span class="line">    student.age = <span class="number">19</span>;   <span class="comment">//我们对传入的结构体中的年龄进行修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">    test(student);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, student.age);  <span class="comment">//最后会是修改后的值吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/bAghYZQ9JtEfIud.png" alt="image-20220625232218359"></p><p>可以看到在其他函数中对结构体内容的修改并没有对外面的结构体生效，因此，实际上结构体也是值传递。我们修改的只是另一个函数中的局部变量而已。</p><p>所以如果我们需要再另一个函数中处理外部的结构体，需要传递指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> Student * student)</span>&#123;   <span class="comment">//这里使用指针，那么现在就可以指向外部的结构体了</span></span><br><span class="line">    student-&gt;age = <span class="number">19</span>;   <span class="comment">//别忘了指针怎么访问结构体内部数据的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">    test(&amp;student);   <span class="comment">//传递结构体的地址过去</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, student.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/km5Ov62CUJa7ITM.png" alt="image-20220625232826388"></p><p>当然一般情况下推荐传递结构体的指针，而不是直接进行值传递，因为如果结构体非常大的话，光是数据拷贝就需要花费很大的精力，并且某些情况下我们可能根本用不到结构体中的所有数据，所以完全没必要浪费空间，使用指针反而是一种更好的方式。</p><h3 id="联合体">联合体</h3><p>联合体也可以在内部定义很多种类型的变量，但是它与结构体不同的是，所以的变量共用同一个空间。？？？？啥意思？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Object</span> &#123;</span>   <span class="comment">//定义一个联合体类型唯一不同的就是前面的union了</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看看一个神奇的现象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Object</span> <span class="title">object</span>;</span></span><br><span class="line">    object.a = <span class="number">66</span>;   <span class="comment">//先给a赋值66</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, object.b);   <span class="comment">//访问b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/y6gXHTaeBODFsYP.png" alt="image-20220625234018499"></p><p>？？？？</p><p>我修改的是a啊，怎么b也变成66了？这是因为它们共用了内存空间，实际上我们先将a修改为66，那么就将这段内存空间上的值修改为了66，因为内存空间共用，所以当读取b时，也会从这段内存空间中读取一个char长度的数据出来，所以得到的也是66。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Object</span> <span class="title">object</span>;</span></span><br><span class="line">    object.a = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, object.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/hGDKQgMclqrZwIY.png" alt="image-20220625234747277"></p><p>因为：128 = 10000000，所以用char读取后，由于第一位是符号位，于是就变成了-128。</p><p>那么联合体的大小又是如何决定的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Object));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/25/ehHpAXPfYwZ7yBN.png" alt="image-20220625234931303"></p><p>实际上，联合体的大小至少是其内部最大类型的大小，这里是int所以就是4，当然，当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。</p><p>当然联合体的其他使用基本与结构体差不多，这里就不提了。</p><h3 id="枚举">枚举</h3><p>最后我们来看一下枚举类型，枚举类型一般用于表示一些预设好的整数常量，比如我们风扇有低、中、高三个档位，我们总是希望别人使用我们预设好的这三个档位，而不希望使用其他的档位，因为我们风扇就只设计了这三个档位。</p><p>这时我们就可以告诉别人，我们的风扇有哪几个档位，这种情况使用枚举就非常适合。在我们的程序中，只能使用基本数据类型对这三种档位进行区分，这样显然可读性不够，别人怎么知道哪个代表哪个档位呢？而使用枚举就没有这些问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比如现在我们设计：</span></span><br><span class="line"><span class="comment"> * 1 = 低档位</span></span><br><span class="line"><span class="comment"> * 2 = 中档位</span></span><br><span class="line"><span class="comment"> * 3 = 高档位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span>low = <span class="number">1</span>, middle = <span class="number">2</span>, high = <span class="number">3</span>&#125;;   <span class="comment">//enum 枚举类型名称 &#123;枚举 = 初始值, 枚举...&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以创建多个自定义名称的枚举，命名规则和变量差不多。我们可以当每一个枚举对应一个整数值，这样的话，我们就不需要去记忆每个数值代表的是什么档位了，我们可以直接根据枚举的名称来进行分辨，是不是很方便？</p><p>使用枚举也非常地方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span>low = <span class="number">1</span>, middle = <span class="number">2</span>, high = <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">status</span> <span class="title">a</span> =</span> low;   <span class="comment">//和之前一样，直接定义即可，类型为enum + 枚举名称，后面是变量名称，值可以直接写对应的枚举</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">status</span> <span class="title">a</span> =</span> high;</span><br><span class="line">    <span class="keyword">if</span>(a == low) &#123;   <span class="comment">//判断起来就方便多了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;低档位&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == high)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;高档位&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中档位&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以直接加入到<code>switch</code>语句中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">status</span> <span class="title">a</span> =</span> high;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> low:</span><br><span class="line">        <span class="keyword">case</span> high:</span><br><span class="line">        <span class="keyword">case</span> middle:</span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在枚举变量定义时需要注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span>low, middle, high&#125;;   <span class="comment">//如果不给初始值的话，那么会从第一个枚举开始，默认值为0，后续依次+1</span></span><br></pre></td></tr></table></figure><p>所以这里的low就是0，middle就是1，high就是2了。</p><p>如果中途设定呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">status</span> &#123;</span>low, middle = <span class="number">6</span>, high&#125;;   <span class="comment">//这里我们给middle设定为6</span></span><br></pre></td></tr></table></figure><p>这时low由于是第一个，所以还是从0开始，不过middle这里已经指定为6了，所以紧跟着的high初始值就是middle的值+1了，因此low现在是0，middle就是6，high就是7了。</p><h3 id="typedef关键字">typedef关键字</h3><p>这里最后还要提一下typedef关键字，这个关键字用于给指定的类型起别名。怎么个玩法呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> lbwnb;   <span class="comment">//食用方式：typedef 类型名称 自定义类型别名</span></span><br></pre></td></tr></table></figure><p>比如这里我们给int起了一个别名，那么现在我们不仅可以使用int来表示一个int整数，而且也可以使用别名作为类型名称了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> lbwnb;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    lbwnb i = <span class="number">666</span>;   <span class="comment">//类型名称直接写成别名，实际上本质还是int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span> * String;   <span class="comment">//const char * 我们就起个名称为String表示字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    String str = <span class="string">&quot;Hello World!&quot;</span>;  <span class="comment">//是不是有Java那味了</span></span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了这种基本类型之外，包括指针、结构体、联合体、枚举等等都可以使用这个关键字来完全起别名操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125; Student;   <span class="comment">//为了方便可以直接写到后面，当然也可以像上面一样单独声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Student student = &#123;<span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;   <span class="comment">//直接使用别名，甚至struct关键字都不用加了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数据结构的学习总，typedef使用会更加地频繁。</p><hr><h2 id="预处理">预处理</h2><p>虽然我们的C语言学习已经快要接近尾声了，但是有一个东西迟迟还没有介绍，就是我们一直在写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这到底是个什么东西，为什么每次都要加上呢？这一部分，我们将详细讨论它缘由。</p><p><code>#include</code>实际上是一种预处理指令，在我们的程序运行之前，会有一个叫做&quot;C预处理器&quot;的东西，根据我们程序中的预处理指令，预处理器能把对应的指令替换为指令想要表示的内容。我们先来看看<code>#include</code>做了什么。</p><h3 id="文件包含">文件包含</h3><p>当预处理器发现<code>#include</code>指令时，会查看后面的文件名并把文件的内容包含到当前文件中，来替换掉<code>#include</code>指令。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//一个很普通的printf打印函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说了，这个函数是由系统为我们提供的函数，实际上这个函数实在其他源文件中定义好的，而定义这个函数的源文件，就是<code>stdio.h</code>，我们可以点进去看看：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/OCd6iGrXkuZslpQ.png" alt="image-20220626131600936"></p><p>除了<code>printf</code>之外，我们看到还有很多很多的函数原型定义，他们都写到这个源文件中，而这个文件并不是以<code>.c</code>结尾的，而是以<code>.h</code>结尾的，这种文件我们称为<strong>头文件</strong>。头文件一般仅包含定义一类的简单信息，只要能让编译器认识就行了。</p><p>而<code>#include</code>则是将这些头文件中提供的信息包含到我们的C语言源文件中，这样我们才能使用定义好的<code>printf</code>函数，如果我们不添加这个指令的话，那么会：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/injLFga1oDvurJG.png" alt="image-20220626132927056"></p><p>直接不认识了，<code>printf</code>是啥，好吃吗？说白了就是，我们如果不告诉编译器我们的这个函数是从哪来的，它怎么知道这个函数的具体定义什么是，程序又该怎么执行呢？</p><p><code>#include</code>的具体使用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名称&gt;</span></span></span><br></pre></td></tr></table></figure><p>当然也可以写成：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;文件名称&quot;</span></span></span><br></pre></td></tr></table></figure><p>这两种写法虽然都能引入头文件，但是区别还是有的：</p><ul><li>**尖括号：**引用的是编译器的库路径里面的头文件。</li><li>**双引号：**引用的是程序目录中相对路径中的头文件，如果找不到再去上面的库里面找。</li></ul><p><img src="https://image.itbaima.cn/markdown/2022/06/26/IDFk4TvXq62g7Y8.png" alt="image-20220626133419361"></p><p>可以看到系统已经为我们提供好了多种多样的头文件了，通过这些系统提供的库，我们就可以做很多的事情了。</p><p>当然我们也可以自己编写一个头文件，直接在项目根目录下创建一个新的C/C++头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Nago Coler on 2023/6/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNTITLED_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNTITLED_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNTITLED_TEST_H</span></span></span><br></pre></td></tr></table></figure><p>可以看到系统自动为我们生成好了这些内容，只不过现在还没学到（后面会介绍），现在直接删掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>我们直接在头文件中随便声明一个函数原型，接着我们就可以引入这个头文件了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span>   <span class="comment">//因为是我们自己项目目录中的，所以需要使用双引号</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = test(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//这样就可以使用头文件中声明的函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过导入头文件，我们就可以使用定义好的各种内容了，当然，不仅仅局限于函数。</p><p>不过现在还没办法执行，因为我们这里只是引入了头文件中定义的函数原型，具体的函数实现我们一般还是使用<code>.c</code>源代码文件去进行编写，这里我们创建一个同名的C源文件（不强制要求同名，但是这样看着整齐一点）去实现一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span>  <span class="comment">//这里也需要把定义引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;   <span class="comment">//编写函数具体实现</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们再次运行程序就可以正确得到结果了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/L1z3sAJxWNIcQ7m.png" alt="image-20220626135746834"></p><p>实际上预处理器正是通过头文件得到编译代码时所需的一些信息，然后才能把我们程序需要的内容（比如这里要用到的test函数）替换到我们的源文件中，最后才能正确编译为可执行程序。</p><p>比如现在我们要做一个学生管理库，这个库中提供了学生结构体的定义，以及对学生信息相关操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span>   <span class="comment">//学生结构体定义</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125; <span class="keyword">typedef</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Student * student)</span>;   <span class="comment">//打印学生信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyAge</span><span class="params">(Student * student, <span class="type">int</span> newAge)</span>;   <span class="comment">//修改年龄 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyId</span><span class="params">(Student * student, <span class="type">int</span> newId)</span>;   <span class="comment">//修改学号</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    <span class="comment">//函数具体实现源文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Student * student)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, 姓名: %s, 年龄: %d岁\n&quot;</span>, student-&gt;id, student-&gt;name, student-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyAge</span><span class="params">(Student * student, <span class="type">int</span> newAge)</span> &#123;</span><br><span class="line">    student-&gt;age = newAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyId</span><span class="params">(Student * student, <span class="type">int</span> newId)</span> &#123;</span><br><span class="line">    student-&gt;id = newId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们就可以愉快地使用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Student student = &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">    modifyAge(&amp;student, <span class="number">19</span>);</span><br><span class="line">    print(&amp;student);   <span class="comment">//打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>#include</code>我们就可以将我们的项目拆分成多个模块去进行编写了。</p><h3 id="系统库介绍">系统库介绍</h3><p>前面我们了解了如何使用<code>#include</code>引入其他文件，我们接着来了解一下系统为我们提供的一些常用库。实际上我们已经用过不少官方库提供的内容了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括前面我们在实战中用到了一次<code>string.h</code>中提供的计算字符串长度的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * c = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu&quot;</span>, <span class="built_in">strlen</span>(c));   <span class="comment">//使用strlen计算长度，注意返回值类型是size_t（别名而已，本质上就是unsigned long）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了这个函数之外，实际上还有很多实用的字符串处理函数，都在这里定义了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>,* b = <span class="string">&quot;World!&quot;</span>;   <span class="comment">//现在有两个字符串，但是我们希望把他们拼接到一起</span></span><br><span class="line">  <span class="comment">//注意不能这样写 char * a = &quot;Hello&quot;,* b = &quot;World!&quot;; 如果直接用指针指向字符串常量，是无法进行拼接的，因为大小已经固定了</span></span><br><span class="line">  <span class="comment">//这里需要两个参数，第一个是目标字符串，一会会将第二个参数的字符串拼接到第一个字符串中（注意要装得下才行）</span></span><br><span class="line">    <span class="built_in">strcat</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>], * c = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str, c);   <span class="comment">//使用cpy会直接将后面的字符串拷贝到前面的字符串数组中（同样需要前面装得下才行）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> * a = <span class="string">&quot;AAA&quot;</span>, * b = <span class="string">&quot;AAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">strcmp</span>(a, b);   <span class="comment">//strcmp会比较两个字符串，并返回结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说一下的比较规则：把字符串str1和str2从首字符开始逐个字符的进行比较，直到某个字符不相同或者其中一个字符串比较完毕才停止比较，字符的比较按照ASCII码的大小进行判断。</p><p>比较完成后，会返回不匹配的两个字符的ASCII码之差：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/3QXnw4jCflyziR5.png" alt="image-20220626151419133"></p><p>我们接着来看用于处理数学问题的相关库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里要用到<code>math.h</code>，它提供了我们场景的数学计算函数，比如求算术平方根、三角函数、对数等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">sqrt</span>(a);   <span class="comment">//使用sqrt可以求出非负数的算术平方根（底层采用牛顿逼近法计算）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/26/m6HWZqA4XCDvf3j.png" alt="image-20220626152208591"></p><p>当然能够开根，也可以做乘方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">pow</span>(a, <span class="number">3</span>);   <span class="comment">//使用pow可以快速计算乘方，这里求的是a的3次方</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个函数，写个水仙花数更简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a = i % <span class="number">10</span>, b = i / <span class="number">10</span> % <span class="number">10</span>, c = i / <span class="number">10</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(a, <span class="number">3</span>) + <span class="built_in">pow</span>(b, <span class="number">3</span>) + <span class="built_in">pow</span>(c, <span class="number">3</span>) == i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 是水仙花数！\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以计算三角函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, <span class="built_in">tan</span>(M_PI));   <span class="comment">//这里我们使用正切函数计算tan180度的值，注意要填入的是弧度值</span></span><br><span class="line">    <span class="comment">//M_PI也是预先定义好的π的值，非常精确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然某些没有不存在的数可能算出来会得到一个比较奇怪的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, <span class="built_in">tan</span>(M_PI / <span class="number">2</span>));   <span class="comment">//这里计算tan90°，我们知道tan90° = sin90°/cos90° = 1/0 不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有两个比较常用的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不小于x的最小整数：%f\n&quot;</span>, <span class="built_in">ceil</span>(x));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不大于x的最大整数：%f\n&quot;</span>, <span class="built_in">floor</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有快速求绝对值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">-3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x的绝对值是：%f&quot;</span>, <span class="built_in">fabs</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最后再来介绍一下通用工具库<code>stdlib</code>，这个库里面为我们提供了大量的工具函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//工具库已经为我们提供好了快速排序的实现函数，直接用就完事</span></span><br><span class="line">    <span class="comment">//参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现）</span></span><br><span class="line">    qsort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在开始使用之前我们还要先补充一点知识，我们发现<code>qsort</code>的原型定义，使用的是void类型的指针。</p><p>怎么void还有指针呢？void不是空吗？</p><blockquote><p>void 指针是一种特殊的指针，表示为“无类型指针”，由于 void 指针没有特定的类型，因此它可以指向任何类型的数据。也就是说，任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换。</p></blockquote><p>所以这里之所以需要void指针，其实就是为了可以填入任何类型的数组，而我们发现第三个参数实际上就是因为是void指针不知道具体给进来的类型是什么，所以需要我们来告诉函数我们使用的类型所占大小是多少。</p><p>而最后一个参数实际上就是我们前面介绍的函数回调了，因为函数不知道你的比较规则是什么，是从小到大还是从大到小呢？所以我们需要编写一个函数来对两个待比较的元素进行大小判断。</p><p>好了，现在了解了之后，我们就可以开始填入参数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span> &#123;  <span class="comment">//参数为两个待比较的元素，返回值负数表示a比b小，正数表示a比b大，0表示相等</span></span><br><span class="line">    <span class="type">int</span> * x = (<span class="type">int</span> *) a, * y = (<span class="type">int</span> *) b;   <span class="comment">//这里因为判断的是int所以需要先强制类型转换为int *指针</span></span><br><span class="line">    <span class="keyword">return</span> *x - *y;   <span class="comment">//其实直接返回a - b就完事了，因为如果a比b大的话算出来一定是正数，反之同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//工具库已经为我们提供好了快速排序的实现函数，直接用就完事</span></span><br><span class="line">    <span class="comment">//参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现）</span></span><br><span class="line">    qsort(arr, <span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以对数组进行快速排序了。</p><p>当然工具库中还提供了<code>exit</code>函数用于终止程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);   <span class="comment">//直接终止程序，其中参数是传递给父进程的（但是现在我们只是简单程序）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过乍一看，貌似和我直接在main里面return没啥区别，反正都会结束。</p><p>当然还有两个我们会在后续学习数据结构中用的较多的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> * p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">//我们可以使用malloc函数来动态申请一段内存空间</span></span><br><span class="line">    <span class="comment">//申请后会返回申请到的内存空间的首地址</span></span><br><span class="line">    *p = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>malloc用于向系统申请分配指定size个字节的内存空间，返回类型是 void * 类型，如果申请成功返回首地址，如果失败返回NULL空地址（比如系统内存不足了就可能会申请失败）</p></blockquote><p>申请到一段内存空间后，这段内存空间我们就可以往上面随便读写数据了，实际上就是和变量一样，只不过这个内存空间是我们自主申请的，并不是通过创建变量得到的，但是使用上其实没啥大的区别。</p><p>不过要注意，这段内存使用完之后记得清理，就像函数执行完会自动销毁其中的局部变量一样，如果不清理那么这段内存会被一直占用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> * p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">128</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);   <span class="comment">//使用free函数对内存空间进行释放，归还给系统，这样这段内存又可以被系统分配给别人用了</span></span><br><span class="line">  p = <span class="literal">NULL</span>;   <span class="comment">//指针也不能再指向那个地址了，因为它已经被释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存资源是很宝贵的（不像硬盘几个T随便用，我们的电脑可能32G的内存都算高配了），不能随便浪费，所以一般情况下malloc和free都是一一对应的，这样才能安全合理地使用内存。</p><h3 id="宏定义">宏定义</h3><p>我们前面认识了<code>#include</code>指令，我们接着来看<code>#define</code>指令，它可以实现宏定义。我语文不好，宏是啥意思？</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/3CHdqbsAji78KwN.png" alt="image-20220626164426525"></p><blockquote><p>把参数批量替换到文本中，这种实现通常称为宏（macro）或定义宏 (define macro)</p></blockquote><p>我们可以通过<code>#define</code>来定义宏，规则如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    宏名(记号)    内容</span></span><br></pre></td></tr></table></figure><p>比如现在我们想通过宏定义一个PI：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure><p>这样就可以了，那么怎么去使用它呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;π的值为：%f&quot;</span>, PI);   <span class="comment">//就像使用变量一样，我们可以直接将PI放到这个位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，预处理程序会进行宏替换操作，也就是将程序中所有的<code>PI</code>全部替换为<code>3.1415926</code>，注意这个跟类型无关，是赤裸裸的纯文本替换，也就是相当于把我们的代码修改了，PI那里直接变成<code>3.1415926</code>，当然如果你定义为其他任意的内容，同样会替换到那个位置，但是至于替换之后程序还正不正常就不知道了。</p><p>我们通过下面这个例子来加深对文本替换这句话的理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M a + b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, M * a);   <span class="comment">//各位觉得计算结果会是多少呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按照我们的正常思维，M是a+b，那么替换上去之后应该就是30了吧？然后30 x 10最后得到的应该是300才对。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/ZOwauBAUCTscXYK.png" alt="image-20220626165518162"></p><p>不过最后貌似并不是这样的，怎么会算出来是210的呢？</p><p>实际上还是那句话，在编译时仅仅是做了文本替换，相当于最后我们的代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b * a);</span><br></pre></td></tr></table></figure><p>所以先计算的是a x b然后再加a，最后结果就是210了。</p><p>当然任何地方都可以使用宏替换，包括类型，反正最后都会变成被替换的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lbwnb long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    lbwnb a = <span class="number">10L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了这种简单的替换之外我们还可以添加参数，就像函数那样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, MUL(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里搞得像函数一样，但是最后还是会被替换为x * x，而这个x就是我们填写的参数，所以最后会变成 9 * 9 替换上去，程序运行出来的结果就是81了。</p><p>直接调函数肯定也是没问题的，反正就纯替换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bb(i) printf(<span class="string">&quot;我是宏替换的：%d&quot;</span>, i);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bb(<span class="number">666</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那要是我想在字符串里面加一个宏定义中的参数呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bb(str) printf(<span class="string">&quot;我是宏替换的：&quot;</span>#str<span class="string">&quot; &lt;&quot;</span>);  <span class="comment">//使用#直接在字符串中进行宏替换，否则默认情况下会被当做一个字符</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    bb(<span class="string">&quot;你看这不就替换了吗&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以替换宏中的部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(n) x ##n   <span class="comment">//##会使用参数进行拼接</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">TEST</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">10</span>;   <span class="comment">//这里传入1，那么实际上就是被替换为x1</span></span><br><span class="line">    x1 = <span class="number">20</span>;   <span class="comment">//所以上面其实是int x1 = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏既然可以定义出来，那么也可以取消定义，我们可以使用<code>#undef</code>来取消已有的宏定义：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/26/ZA1j7dE2pKMXuVn.png" alt="image-20220626172208060"></p><p>可以看到在使用<code>#undef</code>之后，直接不认识了。</p><p>当然除了我们自己可以去定义之外，系统也为我们提供了一些预定义的宏：</p><table><thead><tr><th>宏名称</th><th>含义</th></tr></thead><tbody><tr><td>_ _ DATE _ _</td><td>当前的日期，格式为类似 Jun 27 2023 的字符串</td></tr><tr><td>_ _ TIME _ _</td><td>当前的时间，格式为类似 10:23:12 的字符串</td></tr><tr><td>_ _ FILE _ _</td><td>当前源代码文件的名称（含路径）的字符串</td></tr><tr><td>_ _ LINE _ _</td><td>当前所处的行号是多少就替换为多少，整数</td></tr></tbody></table><p>这里只列出了一部分。</p><h3 id="条件编译">条件编译</h3><p>我们来看看条件编译，我们还可以根据条件，选择性地对某些内容进行忽略。</p><p>收我们我们来认识一下<code>#ifdef</code>、<code>#else</code>、<code>#endif</code>这三种条件编译指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PI   <span class="comment">//ifdef用于判断是否定义了符号PI，如果没有的话则处理以下的指令</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 666</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">//如果定义了符号PI，那么就处理这个分支的语句</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 777</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   <span class="comment">//最后需要以endif指令结束整个判断</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, M);   <span class="comment">//最后打印M</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/26/U7r6g5pB21fISVh.png" alt="image-20220626184356031"></p><p>可以看到，在我们没有定义PI的情况下，执行的是<code>#define M 777</code>，那要是现在定义了呢？我们编写一个新的头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415</span></span><br></pre></td></tr></table></figure><p>现在我们引入这个头文件，那么对应的预编译指令也会跟着包含进来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PI</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 666</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 777</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/26/ojZNauDIb4ckylC.png" alt="image-20220626184248768"></p><p>可以看到此时得到的结果就是666了，因为现在PI在引入的头文件中已经定义了（当然直接在当前源文件中定义也是一样的）</p><p>那如果我现在希望判断某个符号没定义呢？没错，还有<code>#ifndef</code>表示判断是否未定义某个符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PI   <span class="comment">//ifndef 就是 if not define，跟ifdef反着的</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 666</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> M 777</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/26/br2lo1vj5GPIZig.png" alt="image-20220626184747886"></p><p>当然，除了判断某个符号是否存在之外，我们也可以像条件语句那样直接进行逻辑判断，这里需要使用到<code>#if</code>和<code>#elif</code>指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 666</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> M == 666   <span class="comment">//若M等于666那么定义K = 999</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> K 999</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> M == 777   <span class="comment">//等同于else if语句</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> K 888</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>    <span class="comment">//else语句</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> K 000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>并且这些分支还支持嵌套使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 666</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> M == 666</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> L</span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> M == 777</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> K = 888</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> K = 000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="文件输入-输出（选学）">文件输入/输出（选学）</h2><p>**注意：**本小节作为选学内容，不强制要求。</p><p>我们的电脑上其实存放了多种多样的文件，比如我们办公经常需要打交道的Word文档、PPT幻灯片、Excel表格等，包括我们的C程序源文件，图片、视频等等，这些都是文件，由于文件需要被长期保存，所以它们被统一存放到我们电脑上的硬盘中。硬盘不像内存，虽然它们都可以存放数据，但是内存中的数据断电即失（在学习完数字电路中的锁存器后，你就知道为什么了）而硬盘却支持长期保存数据，当然也是以二进制的形式进行保存的。</p><h3 id="文本读写操作">文本读写操作</h3><p>现代计算机使用的硬盘大致分为固态硬盘和机械硬盘两种，其中固态硬盘的读写速度远超机械硬盘，但是寿命（硬盘是有读写次数限制的，如果读写次数超标，那么就无法使用了）不如机械硬盘，所以一般重要数据都是在机械硬盘中存放，而系统文件一般是在固态硬盘中存放，这样电脑的启动速度会很快。</p><p>不过文件并不是随便在硬盘中进行保存的，而是根据不同的文件系统按规则进行存放的，比如Windows下采用的就是NTFS文件系统，而MacOS采用的是APFS文件系统。</p><blockquote><p>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。</p></blockquote><p>其中某些文件是以文本格式存储的，比如我们的C语言源文件、普通的文本文档等；而有些文件是二进制格式，比如图片、视频、应用程序等，但是他们最终都是以二进制的形式存储到硬盘上的。当然，普通的文本文件我们直接打开记事本都可以直接进行编辑，而图片这类二进制文件，需要使用专门读取图片的软件来查看，根据格式的不同（图片有png、jpg等格式）对文件的解读方式也不一样，但是最后都会被专门的图片查看软件展示出来。</p><p>通过使用C语言，我们也可以读取硬盘上的文件，这里我们先创建一个简单的文本文件：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/fcwle59DIBt1WUQ.png" alt="image-20220628112153835"></p><p>接着我们可以使用stdio.h中为我们提供的函数打开一个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  <span class="comment">//使用fopen函数来打开一个文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先来介绍一下参数：</p><ul><li>第一个参数：文件的名称，这里我填写的是相对路径，也可以写成绝对路径</li><li>第二个参数：打开文件的模式，其中模式有以下这些：</li></ul><table><thead><tr><th style="text-align:center">模式字符串</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">“r”</td><td style="text-align:center">以读模式打开文件</td></tr><tr><td style="text-align:center">“w”</td><td style="text-align:center">以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件</td></tr><tr><td style="text-align:center">“a”</td><td style="text-align:center">以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件</td></tr><tr><td style="text-align:center">“r+”</td><td style="text-align:center">以更新模式打开文件（即可以读写文件）该文件必须存在</td></tr><tr><td style="text-align:center">“w+”</td><td style="text-align:center">以更新模式打开文件（即可以读写文件），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件</td></tr><tr><td style="text-align:center">“a+”</td><td style="text-align:center">以更新模式打开文件（即，读写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容</td></tr><tr><td style="text-align:center">“rb”,“wb”,“ab”,“ab+”,“a+b”,“wb+”,“w+b”</td><td style="text-align:center">与“a+”模式类似，但是以二进制模式打开文件而不是以文本模式打开文件</td></tr></tbody></table><p>具体的不同打开模式会影响到后续的操作，我们后面再说。这里我们使用r表示可读。</p><p>然后这个函数返回的是一个FILE结构体指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">sFILE</span> &#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> *_p; <span class="comment">/* current position in (some) buffer */</span></span><br><span class="line">   <span class="type">int</span>    _r;       <span class="comment">/* read space left for getc() */</span></span><br><span class="line"> ...</span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure><p>定义非常复杂，这里我们就不详细介绍了，这样我们就成功打开了这个文件，那么如何对文件进行读取操作呢？</p><p>我们可以使用<code>getc</code>来快速读取文件中的字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(file)) != EOF) &#123;   <span class="comment">//通过一个while循环来不断读取文件，使用getc从文件中读取一个字符，如果到末尾了，那么会返回一个特殊值EOF</span></span><br><span class="line">        <span class="built_in">putchar</span>(c);   <span class="comment">//使用putchar来快速打印字符到控制台</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到成功输出：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/e1QFxCszVM4BX2f.png" alt="image-20220628135052152"></p><p>当然如果没有这个文件或是文件打开失败的话，可能会返回一个空指针，所以我们需要进一步判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;   <span class="comment">//如果打开失败会返回NULL</span></span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = getc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;文件打开失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们在使用完文件后，记得关闭文件来释放资源，不然一直会被占用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(file);   <span class="comment">//fclose用于关闭文件</span></span><br></pre></td></tr></table></figure><p>那么读取文件我们知道了，写入呢？写入我们同样可以使用<code>putc</code>来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);   <span class="comment">//注意这里需要修改为写模式</span></span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            putc(<span class="string">&#x27;A&#x27;</span> + i, file);   <span class="comment">//从A开始依次写入10个字符</span></span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;文件打开失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后我们的文件变成了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/e2qC9WvzMlIBubA.png" alt="image-20220628135806896"></p><p>原来的文本被覆盖为了我们输入的新文本，那要是我们现在不想覆盖原来的，而是希望在后面追加输入呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);   <span class="comment">//我们可以将其修改为a表示append追加输入</span></span><br></pre></td></tr></table></figure><p>这样就不会覆盖原有内容而是追加填写了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/hkQmsNJxgucpYfl.png" alt="image-20220628135946686"></p><p>不过这里要补充一下，文件的读写实际上并不是直接对文件进行操作的，在这之间还有一个缓冲区：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/jpu8XIhnsxQScAD.png" alt="image-20220628141209105"></p><p>我们所有的读操作，首先是从文件读取到缓冲区中，再从缓冲区中读取到程序中的；写操作就是先写入到缓冲区，然后再从缓冲区中写入到文件中。这样做的目的是，因为内存和硬盘的速度差距有点大，为了解决这种速度差异导致的性能问题，所以设定一个缓冲区，这样就算速度不一样，但是内容被放在缓冲区中慢慢消化就没问题了。</p><p>虽然缓冲区能够解决这些问题，但是也会带来一些不便之处，比如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);   <span class="comment">//注意这里需要修改为写模式</span></span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> c = getchar();   <span class="comment">//不断从控制台读取字符</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;q&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            putc(c, file);  <span class="comment">//写入到文件中</span></span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现当我们敲了一个字符之后，可能并不会马上更新到文件中，这就是由于缓冲区没有及时同步到文件中，所以我们需要调用一个函数来刷新缓冲区，将那些缓冲区的没有同步的数据全部同步到文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> c = getchar();</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;q&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            putc(c, file);</span><br><span class="line">            fflush(file);   <span class="comment">//使用fflush来刷新缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以看到输入一个字符马上就能同步更新了。当然我们也可以手动设定缓冲区的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">setvbuf(file, buf, _IOFBF, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>_IONBF：表示不使用缓冲区</li><li>_IOFBF：表示只有缓冲区填满了才会更新到文件</li><li>_IOLBF：表示遇到换行就更新到文件</li></ul><p>除了使用<code>getc</code>之外，标准库中还提供了<code>fprintf</code>和<code>fgets</code>系列函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;树脂%d&quot;</span>, <span class="number">666</span>);   <span class="comment">//fprintf就像普通的打印一样，但是它并不是打印到控制台，而是文件中</span></span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;小黑子苏珊&quot;</span>, file);   <span class="comment">//就像使用puts一样，同样是输出到文件中</span></span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，对于文本文件的基础读写操作就讲解到这里。</p><h3 id="随机访问">随机访问</h3><p>前面我们介绍了文本文件的基础读写操作，我们接着来看随机访问。首先什么是随机访问？</p><p>我们在前面读取文件时，实际上是按照顺序，每次读取都会往后移动一个字符继续读取，那么如果现在我希望直接跳到某个位置进行读取是否可以实现呢？</p><p>我们可以使用fseek来跳转到指定位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fseek(file, <span class="number">-2L</span>, SEEK_SET);   <span class="comment">//第二个参数为偏移量，根据后面的参数而定</span></span><br><span class="line">        <span class="built_in">putchar</span>(getc(file));</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍一下起始点：</p><ul><li>SEEK_SET：从文件开始处开始</li><li>SEEK_CUR：从当前位置开始（就是已经读到哪个位置就是哪个位置）</li><li>SEEK_END：从文件末尾开始</li></ul><p>而上面的使用的是SEEK_SET，那么就是从文件开始，往后偏移2个字符的位置，也就是字符<code>l</code>。</p><p>那么我们怎么知道当前已经读取到文件第几个字符了呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fseek(file, <span class="number">2L</span>, SEEK_SET);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, ftell(file));  <span class="comment">//可以使用ftell来直接返回当前位置，返回类型为long</span></span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了fseek和ftell之外，还有fgetpos和fsetpos这两个函数，它们也可以获取位置和设定位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">fpos_t</span> pos;   <span class="comment">//位置需要使用fpos_t进行存储（主要用于处理大文件）</span></span><br><span class="line">        fgetpos(file, &amp;pos);   <span class="comment">//获取位置，并设定给pos，此时位置为0</span></span><br><span class="line">        fseek(file, <span class="number">-2L</span>, SEEK_END);   <span class="comment">//通过fseek移动到倒数第二个位置</span></span><br><span class="line">        fsetpos(file, &amp;pos);   <span class="comment">//设定位置为pos位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, ftell(file));   <span class="comment">//最后得到的就是经过fsetpos设定的新位置了</span></span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了这些函数，这样我们就可以实现对文件的随机读写了。</p><p>前面我都是对文本文件进行操作，我们接着来看如何直接读写二进制文件，比如现在我们想要复制一个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE * target = fopen(<span class="string">&quot;hello2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];   <span class="comment">//这里我们使用char类型的数组作为暂存</span></span><br><span class="line">        <span class="type">size_t</span> s;</span><br><span class="line">        <span class="keyword">while</span> ((s = fread(buf, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1024</span>, file)) &gt; <span class="number">0</span>) &#123;  <span class="comment">//使用fread函数进行读取，每次都会从文件中读取指定大小的数据到暂存数组中，返回值为实际读取的值，如果读取的值小于0表示读完了</span></span><br><span class="line">            fwrite(buf, <span class="keyword">sizeof</span>(<span class="type">char</span>), s, target);  <span class="comment">//使用fwrite将数据写入到指定文件中</span></span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/28/sHcBxRUChQAVqL5.png" alt="image-20220628151553683"></p><p>可以看到我们成功将hello.txt中的内容复制到另一个文本文件中了。当然我们也可以用来拷贝大型文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE * file = fopen(<span class="string">&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn.iso&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE * target = fopen(<span class="string">&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn-2.iso&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//计算文件的大小</span></span><br><span class="line">        fseek(file, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">        <span class="type">long</span> size = ftell(file);</span><br><span class="line">        fseek(file, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">size_t</span> s, all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((s = fread(buf, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1024</span>, file)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fwrite(buf, <span class="keyword">sizeof</span>(<span class="type">char</span>), s, target);</span><br><span class="line">            all += s;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前进度 %.1f%%\n&quot;</span>, (<span class="type">double</span>) all / (<span class="type">double</span>) size * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉有内味了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/Ny4LqHeDlGOQiVd.png" alt="image-20220628152934462"></p><p>这样我们就实现了文件的拷贝。</p><hr><h2 id="程序编译和调试（选学）">程序编译和调试（选学）</h2><p>**注意：**本小节作为选学内容，不强制要求。</p><p>有关C语言语言层面的教学基本就结束了，最后让我们来了解一下如何不借助IDE，通过最原始的方式手动完成程序的编译。</p><h3 id="C语言程序的编译">C语言程序的编译</h3><p>在开始之前，我们需要介绍一个编译器：</p><blockquote><p>GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、<a href="https://baike.baidu.com/item/Pascal/241171">Pascal</a>、Objective -C、Java、Ada、Go以及各类处理器<a href="https://baike.baidu.com/item/%E6%9E%B6%E6%9E%84/13004195">架构</a>上的<a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/61826">汇编语言</a>等，所以改名GNU编译器套件（GNU Compiler Collection）</p></blockquote><p>那么gcc编译器是如何将我们的程序一步步编译为可执行文件的呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/rLjZ5RQtqEvSlXC.png" alt="image-20220627112630649"></p><ol><li>预处理（Pre-Processing）：首先会经过预处理器将程序中的预编译指令进行处理，然后把源文件中的注释这些没用的东西都给扬了。</li><li>编译（Compiling）：处理好之后，就可以正式开始编译，首先会编译为汇编代码。</li><li>汇编（Assembling）：接着就该将汇编代码编译为机器可以执行的二进制机器指令了，会得到一个二进制目标文件。</li><li>链接（Linking）：最后需要将这个二进制目标文件与系统库和其他库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件。</li></ol><p>比如在Windows操作系统下完成这四步，就会生成一个Windows的.exe可执行文件。</p><p>我们来一步一步尝试一下，首先我们把CLion自带的GCC工具目录配置到环境变量中（Mac系统直接自带，不需要任何配置）：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/uAR3aQhylOGjBf8.png" alt="image-20220627120949262"></p><p>位置在你的<code>CLion安装目录/bin/mingw/bin</code>，打开高级系统设置，添加环境变量：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/qKQgJy1C5uetj3N.png" alt="image-20220627121332125"></p><p>配置完成后，打开CLion，我们随便编写一点内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们点击IDE下方的终端面板：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/rhbZTmKvqzYtPgo.png" alt="image-20220627130234208"></p><p>可以看到这里打开的是Windows自带的PowerShell终端，如果不是的可以在设置中修改：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/5clxwIeSszoUpZ9.png" alt="image-20220627130343946"></p><p>现在我们就可以手动开始对我们的C源文件进行编译了，首先是第一步，我们需要对源文件进行预处理：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure><p>其中 <code>-E</code> 后面的是我们的源文件名称，<code>-o</code> 是我们预处理后生成的文件名称：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/pEC9mZwql5X1JMj.png" alt="image-20220627130740318"></p><p>生成后，我们可以直接查看这个文件（因为此时依然是普通文本）可以看到，我们的代码在经过预处理之后，<code>#include &lt;stdio.h&gt;</code>中的内容都替换过来了。最下面大约1000行左右的位置就是我们的代码了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/8vk3rEjcy4XK1tO.png" alt="image-20220627131124121"></p><p>现在我们已经完成了预处理，接着就可以将其编译为汇编程序了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.i -o main.s</span><br></pre></td></tr></table></figure><p>这里的<code>-S</code>就是预处理之后的文件，我们可以直接将其编译为汇编代码：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/Y4a6LUSwjKl8IBJ.png" alt="image-20220627131513884"></p><p>可以看到这里都是汇编代码，各种各样的汇编指令。接着我们就可以将这个汇编代码继续编译为二进制文件了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.s -o main.o</span><br></pre></td></tr></table></figure><p>这里<code>-c</code>后的就是我们的汇编程序，直接生成为二进制文件：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/vR8NOKBfrPoCjbp.png" alt="image-20220627131829386"></p><p>不过现在我们还没办法直接运行它，因为还需要进一步链接，变成Windows操作系统可以执行的程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure><p>这里直接将刚刚生成的目标文件编译为可执行文件，我们就可以直接运行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/GqwY5r7s6b8pvHd.png" alt="image-20220627132110465"></p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/Yne5hmAvOQkTBMF.png" alt="image-20220627132259302"></p><p>成功生成.exe文件，我们直接在控制台输入它的名字就可以运行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/YU8k3wyMg2WF9VO.png" alt="image-20220627132221190"></p><p>这样我们就实现了手动编译一个C语言程序。当然如果我们要更快速一点地完成编译，可以直接将源文件进行编译：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure><p>当然这种只是简单的单源文件下的编译，要是遇到多文件的情况下呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/acsCO9gFyNUXh4S.png" alt="image-20220627133429263"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> * b)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> * b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是按照刚刚的方式直接进行编译：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/jlK9tZRFgxIw4Qr.png" alt="image-20220627133646126"></p><p>可以看到，编译错误，无法识别到<code>swap</code>这个函数，说明肯定还需要把引入的其他文件也给一起带上，所以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c test.c -o main</span><br></pre></td></tr></table></figure><p>或是将两个文件单独编译为对应的二进制文件，最后再放到一起编译也是可以的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o test.o -o main</span><br></pre></td></tr></table></figure><p>OK，现在多个文件就可以在一起编译了，最后同样生成了一个可执行文件：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/bQOiG2US6wFDnxy.png" alt="image-20220627134010138"></p><h3 id="使用Make和CMake进行构建">使用Make和CMake进行构建</h3><p>我们的项目可能会有很多很多的内容需要去进行编译，如何去进行组织成了一个大问题，比如让谁先编译，谁后编译，这时，我们就需要一个构建工具来帮助我们对程序的构建流程进行组织。</p><blockquote><p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p></blockquote><p>要使用Make对我们的项目进行构建，我们需要先告诉Make我们的程序应该如何去进行构建，这时我们就要编写一下Makefile了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/3bRneOcMtfZyPw7.png" alt="image-20220627135232863"></p><p>我们只需要把需要执行的命令按照我们想要的顺序全部写到里面就可以了，但是需要遵循以下格式：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">  command</span><br></pre></td></tr></table></figure><p>一个Makefile中可以有很多个目标，比如我们现在要分别编译main.c和test.c，那么就需要创建两个目标：</p><ul><li>targets：构建的目标，可以是一个普通的标签、文件名称等</li><li>prerequisites：前置条件，可以设定要求完成其他目标才能开始构建当前目标</li><li>command：构建需要执行的命令</li></ul><p>比如现在我们想要分别先编译test.c和main.c，最后将他们变成一个可执行文件，那么makefile可以这样编写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.exe: test.o main.o  #目标1：构建最终的程序，要求完成下面两个目标（注意最终目标需要写在第一个）</span></span><br><span class="line">gcc test.o main.o -o main</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c  #目标2：构建目标为main.o，前置要求必须有main.c文件</span></span><br><span class="line">gcc -E main.c -o main.i</span><br><span class="line">gcc -S main.i -o main.s</span><br><span class="line">gcc -c main.s -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.c  #目标3：同样的，要求必须有test.c文件才能开始</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line">gcc -S test.i -o test.s</span><br><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure><p>接着我们只需要在控制台输入make命令（CLion自带环境需要输入mingw32-make命令，Mac下直接输入make）就可以进行编译了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/9nGRvqp8SjUXhN7.png" alt="image-20220627212727506"></p><p>命令执行的每一步都会详细打印出来，我们可以看到构建确实是按照我们的顺序在进行，并且成功编译出最终目标：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/FTILC5evZ67rEXo.png" alt="image-20220627212822806"></p><p>当然，如果我们没有做任何的修改，那么再次执行make命令不会做任何事情：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/BQSIXTpvOc9Jukh.png" alt="image-20220627212951245"></p><p>但是如果我们修改一下源文件的话，执行make将会重新构建目标：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/sfQgxm34vlw8TKi.png" alt="image-20220627213029819"></p><p>再次执行：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/SrE9FcADYWaywRN.png" alt="image-20220627213051247"></p><p>通过使用Make，即使没有如此高级的IDE，哪怕我们纯靠记事本写C代码，都可以很方便地完成对一个项目的构建了。当然这只是Make的简单使用，它还支持使用变量、逻辑判断等高级玩法，这里我们就不多做介绍了。</p><p>虽然使用Make可以很方便地对项目构建流程进行配置，但是貌似CLion并没有采用这种方式来组织我们的项目进行构建，而是使用了CMake，我们来看看它又是做什么的。</p><blockquote><p>CMake是一个跨平台的安装（<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343">编译</a>）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067">编译器</a>所支持的C++特性,类似<a href="https://baike.baidu.com/item/UNIX/219943">UNIX</a>下的automake。</p></blockquote><p>简而言之， CMake是一个跨平台的Makefile生成工具!</p><p>实际上当我们创建一个项目后，CLion会自动为我们配置CMake，而具体的配置都是写在CMakeList.txt中的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">project</span>(untitled C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(untitled main.c <span class="keyword">test</span>.c <span class="keyword">test</span>.h)</span><br></pre></td></tr></table></figure><p>我们逐行来进行解读：</p><ul><li>第一行使用cmake_minimum_required来指定当前项目使用的CMake最低版本，如果使用的CMake程序低于此版本是无法构建的。</li><li>第二行project指定项目名称，名称随意，后面的是项目使用的语言，这里是C。</li><li>第三行set用于设定一些环境变量等，这里设定的是C 99标准。</li><li>第四行add_executable用于指定一个编译出来的可执行文件，这里名称为untitled，后面的都是需要编译的源文件（头文件可以不写）</li></ul><p>当然除了这些语法之外，还有各种各样的设定，比如设定库目录或是外部动态连接库等，这里就不多说了，感兴趣的可以自行了解。</p><p>这里我们来手动执行一下cmake：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/XFpHB1aPbRCA4kL.png" alt="image-20220627215908039"></p><p>首先还是添加环境变量，添加完成后重启CLion，我们输入cmake命令进行生成：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B <span class="built_in">test</span> -G <span class="string">&quot;MinGW Makefiles&quot;</span></span><br></pre></td></tr></table></figure><p>其中<code>-S</code>后面的是源文件目录，这里<code>.</code>表示当前目录，<code>-B</code>后面是构建目录，一会构建的文件都在这里面存放，最后<code>-G</code>是选择生成器（生成器有很多，甚至可以直接生成一个VS项目，我们可以直接使用Visual Studio打开），这里我们需要生成Makefile，所以填写&quot;MinGW Makefiles&quot;：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/MUgkvuARteyS2wQ.png" alt="image-20220627221226478"></p><p>可以看到已经成功在我们的构建目录中生成了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/uMtaVgILmjFhiR9.png" alt="image-20220627221335557"></p><p>只不过它这个自动生成的Makefile写的就比较复杂了，我们也不需要去关心，接着我们像之前一样直接使用make就可以编译了：</p><p>这里要先进入一下test目录，使用<code>cd test</code>命令修改当前工作目录：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/DNnROjG1eh8V7kA.png" alt="image-20220627221459717"></p><p>可以看到它生成的Makefile还是挺高级的，还能输出进度，现在我们的程序就构建好了，直接启动把：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/27/IWPbV8nJ3XFLfEz.png" alt="image-20220627221546242"></p><p>当然CLion并没有使用Makefile的编译方式，而是Ninja，并且生成的构建文件默认存放在<code>cmake-build-debug</code>中，跟make比较类似，但是速度会更快一些，不过最后都会成功构建出我们的可执行程序。</p><p>这下，我们就清楚整个项目中个个文件是干嘛的了。</p><h3 id="使用LLDB调试工具">使用LLDB调试工具</h3><p>最后我们来说一下LLDB调试工具（与之类似的还有GDB），首先还是配置一下环境变量：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/OGg9fnXztEl7Ick.png" alt="image-20220628002518087"></p><p>LLDB调试工具用于对我们的程序进行逐步调试使用，实际上我们之前也使用调试，只不过是在IDE中的图形化界面中操作的，那么如果没有IDE呢，我们可以使用LLDB调试工具来进行调试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb .\untitled.exe</span><br></pre></td></tr></table></figure><p>注意在编译时需要需要添加-g参数来附带调试信息，这样才可以使用gdb进行调试，否则不能（CLion默认生成的是可以调试的程序，所以直接使用就行了）</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/RdNOVElm5G12q8y.png" alt="image-20220628002734741"></p><p>进入后，可以看到是这样的一个界面，我们需要输入命令来进行逐步调试，输入r就可以开始运行了：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/kQodUtfj7JXZ4B5.png" alt="image-20220628001554755"></p><p>成功运行出结果，那么具体怎么进行断点调试呢？我们可以使用<code>b 行号</code>的形式在对应的行号打上断点，比如这里对第9行进行断点：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/pRuoPKOL4FYgsj8.png" alt="image-20220628002035160"></p><p>接着我们再输入r之后，程序会暂时卡在断点位置，此时我们可以通过输入v来查看当前所有的局部变量信息：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/96qVCgjebBWph5w.png" alt="image-20220628003001093"></p><p>可以看到现在是冒泡排序的第一轮，所以<code>i</code>和<code>j</code>都还是0，并且数组是乱序的，我们输入c可以继续运行：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/JND3ix4vuoEjAaG.png" alt="image-20220628003056092"></p><p>继续运行一轮后，此时<code>j</code>就变成1了，因为内层循环执行了一次，我们可以通过p来打印变量的值：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/7EvSVtXyLcJikHd.png" alt="image-20220628003230535"></p><p>当我们不需要再调试时，可以直接结束掉程序：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/28/z7RlaybGsLV4Bqu.png" alt="image-20220628003631329"></p><p>当然这仅仅是展示lldb的简单使用，通过使用lldb我们就可以很轻松地在控制台进行调试了。</p><p>至此，包括编译、构建、调试的所有操作，我们完全可以脱离IDE纯靠命令行进行操作了（其实在没有图形化界面的年代基本上都是这样写代码的）</p><hr><h2 id="结束语">结束语</h2><p>到这里，我们C语言的学习就结束了，感谢各位小伙伴一直以来的支持，希望在下一期视频中，还能见到各位的身影。</p><p>之后我们还会开放C语言系列数据结构篇教程，敬请期待。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基础语法-C语言程序设计（二）</title>
    <link href="https://blog.yuncan.xyz/posts/c2.html"/>
    <id>https://blog.yuncan.xyz/posts/c2.html</id>
    <published>2023-06-21T13:55:43.000Z</published>
    <updated>2023-06-21T13:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/c_cover.jpg" alt="cover"></p><h1>C语言基础</h1><p>前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！</p><p>C语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。</p><p>学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。</p><h2 id="C程序基本格式">C程序基本格式</h2><p>前面我们在创建项目之后自动生成了一个<code>.c</code>文件，这个就是我们编写的程序代码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是<code>main</code>函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  <span class="comment">//所有的符号一律采用英文的，别用中文</span></span><br><span class="line">    程序代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意是<code>int</code>后面空格跟上<code>main()</code>，我们的程序代码使用花括号<code>&#123;&#125;</code>进行囊括（有的人为了方便查阅，会把前半个花括号写在下面）</p><p>然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用<code>printf(内容)</code>来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！</span></span><br></pre></td></tr></table></figure><p>我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入<code>printf</code>即可。我们会在后续的学习中逐渐认识<code>printf</code>函数。</p><p>最顶上还有一句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个是引入系统库为我们提供的函数，包括<code>printf</code>在内，所以我们以后编写一个C语言程序，就按照固定模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。</p><p>我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   <span class="comment">//引入标准库头文件</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   <span class="comment">//主函数，程序的入口点</span></span><br><span class="line">    printf(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//向控制台打印字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以添加多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是由IDE自动生成的测试代码</span></span><br><span class="line"><span class="comment"> * 还是可以的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  <span class="comment">//最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，基本的一些内容就讲解完毕了。</p><h2 id="基本数据类型">基本数据类型</h2><p>我们的程序离不开数据，比如我们需要保存一个数字或是字母，这时候这些东西就是作为数据进行保存，不过不同的数据他们的类型可能不同，比如1就是一个整数，0.5就是一个小数，A就是一个字符，C语言提供了多种数据类型供我们使用，我们就可以很轻松的使用这些数据了。</p><p>不同的数据类型占据的空间也会不同，这里我们需要先提一个概念，就是字、字节是什么？</p><p>我们知道，计算机底层实际上只有0和1能够表示，这时如果我们要存储一个数据，比如十进制的3，那么就需要使用2个二进制位来保存，二进制格式为<code>11</code>，占用两个位置，再比如我们要表示十进制的15，这时转换为二进制就是<code>1111</code>占用四个位置（4个bit位）来保存。一般占用8个bit位表示一个字节（B），2个字节等于1个字，所以一个字表示16个bit位，它们是计量单位。</p><p>我们常说的内存大小1G、2G等，实际上就是按照下面的进制进行计算的：</p><p>8 bit = 1 B ，1024 B = 1KB，1024 KB = 1 MB，1024 MB = 1GB，1024 GB = 1TB，1024TB = 1PB（基本上是1024一个大进位，但是有些硬盘生产厂商是按照1000来计算的，所以我们买电脑的硬盘容量可能是512G的但是实际容量可能会缩水）</p><p>在不同位数的系统下基本数据类型的大小可能会不同，因为现在主流已经是64位系统，本教程统一按照64位系统进行讲解。</p><h3 id="原码、反码和补码">原码、反码和补码</h3><h4 id="原码">原码</h4><p>上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？</p><p>比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是：</p><ul><li>最小：1111 =&gt; - (2^2+2^1+2^0) =&gt; -7</li><li>最大：0111 =&gt; + (2^2+2^1+2^0) =&gt; +7 =&gt; 7</li></ul><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！）</p><p>我们得创造一种更好的表示方式！于是我们引入了反码：</p><h4 id="反码">反码</h4><p>正数的反码是其本身<br>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反<br>经过上面的定义，我们再来进行加减法：</p><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p><p>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</p><h4 id="补码">补码</h4><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p><p>正数的补码就是其本身 （不变！）<br>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p><p>所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！）</p><h3 id="整数类型">整数类型</h3><p>我们首先来看看整数类型，整数就是不包含小数点的数据，比如<code>1</code>，<code>99</code>，<code>666</code>等数字，整数包含以下几种类型：</p><ul><li>int   -    占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型</li><li>long   -   占用 8 个字节，64个bit位。</li><li>short   -    占用2个字节，16个bit位。</li></ul><h3 id="浮点类型">浮点类型</h3><p>浮点类一般用于保存小数，不过为啥不叫小数类型而是浮点类型呢？因为我们的一个小数分为整数部分和小数部分，我们需要用一部分的bit位去表示整数部分，而另一部分去表示小数部分，至于整数部分和小数部分各自占多少并不是固定的，而是浮动决定的（在计算机组成原理中会深入学习，这里就不多介绍了）</p><ul><li>float   -   单精度浮点，占用4个字节，32个bit位。</li><li>double    -    双精度浮点，占用8个字节，64个bit位。</li></ul><h3 id="字符类型">字符类型</h3><p>除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存：</p><ul><li>char   -    占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符：</li></ul><p><img src="https://image.itbaima.cn/markdown/2022/06/17/BoaWb5EHOM7wJVy.jpg" alt="image-20220603114358826"></p><p>编码表中包含了所有我们常见的字符，包括运算符号、数字、大小写字母等（注意只有英文相关的，没有中文和其他语言字符，包括中文的标点符号也没有）</p><p>某些无法直接显示的字符（比如换行，换行也算一个字符）需要使用转义字符来进行表示：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/fqnzER2AS4YleTG.jpg" alt="img"></p><p>有关基本类型的具体使用我们放到下一节进行讲解。</p><hr><h2 id="变量">变量</h2><p>前面我们了解了C语言中的基本类型，那么我们如何使用呢？这时我们就可以创建不同类型的变量了。</p><h3 id="变量的使用">变量的使用</h3><p>变量就像我们在数学中学习的<code>x</code>，<code>y</code>一样，我们可以直接声明一个变量，并利用这些变量进行基本的运算，声明变量的格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称 = 初始值;    <span class="comment">//其中初始值可以不用在定义变量时设定</span></span><br><span class="line"><span class="comment">// = 是赋值操作，可以将等号后面的值赋值给前面的变量，等号后面可以直接写一个数字（常量）、变量名称、算式</span></span><br></pre></td></tr></table></figure><p>比如我们现在想要声明一个整数类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//变量类型为int（常用），变量名称为a，变量的初始值为10</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;   <span class="comment">//多个变量可以另起一行编写，也可以像这样用逗号隔开，注意类型必须是一样的</span></span><br></pre></td></tr></table></figure><p>其中，变量的名称并不是随便什么都可以的，它有以下规则：</p><ul><li>不能重复使用其他变量使用过的名字。</li><li>只能包含英文字母或是下划线、数字，并且严格区分大小写，比如<code>a</code>和<code>A</code>不算同一个变量。</li><li>虽然可以包含数字，但是不能以数字开头。</li><li>不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识）</li><li>（建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。</li></ul><p>初始值可以是一个常量数据（比如直接写10、0.5这样的数字）也可以是其他变量，或是运算表达式的结果，这样会将其他变量的值作为初始值。</p><p>我们可以使用变量来做一些基本的运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//将10作为a的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   <span class="comment">//注意变量一定要先声明再使用，这里是计算a + b的结果（算式），并作为c的初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用到了<code>+</code>运算符（之后我们还会介绍其他类型的运算符）这个运算符其实就是我们数学中学习的加法运算，会将左右两边的变量值加起来，得到结果，我们可以将运算结果作为其他变量的初始值，还是很好理解的。</p><p>但是现在虽然做了运算，我们还不知道运算的具体结果是什么，所以这里我们通过前面认识的<code>printf</code>函数来将结果打印到控制台：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(c);   <span class="comment">//直接打印变量c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现这样似乎运行不出来结果，不对啊，前面你不是说把要打印到控制台的内容写到<code>printf</code>中吗，怎么这里不行呢？实际上<code>printf</code>是用于格式化打印的，我们来看看如何进行格式化打印，输出我们的变量值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c的结果是：%d&quot;</span>, );   <span class="comment">//使用%d来代表一个整数类型的数据（占位符），在打印时会自动将c的值替换上去</span></span><br></pre></td></tr></table></figure><p>我们来看看效果：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/lb4T2HEXP7jCWIx.jpg" alt="image-20220603131740600"></p><p>这样，我们就知道该如何打印我们变量的值了，当然，除了使用<code>%d</code>打印有符号整数之外，还有其他的：</p><table><thead><tr><th>格式控制符</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>输出一个单一的字符</td></tr><tr><td>%hd、%d、%ld</td><td>以十进制、有符号的形式输出 short、int、long 类型的整数</td></tr><tr><td>%hu、%u、%lu</td><td>以十进制、无符号的形式输出 short、int、long 类型的整数</td></tr><tr><td>%ho、%o、%lo</td><td>以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数</td></tr><tr><td>%#ho、%#o、%#lo</td><td>以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数</td></tr><tr><td>%hx、%x、%lx %hX、%X、%lX</td><td>以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。</td></tr><tr><td>%#hx、%#x、%#lx %#hX、%#X、%#lX</td><td>以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。</td></tr><tr><td>%f、%lf</td><td>以十进制的形式输出 float、double 类型的小数</td></tr><tr><td>%e、%le %E、%lE</td><td>以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。</td></tr><tr><td>%g、%lg %G、%lG</td><td>以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr></tbody></table><p>比如现在我们要进行小数的运算，还记得我们前面介绍的小数类型有哪些吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">2.5f</span>;   <span class="comment">//注意直接写2.5默认表示的是一个double类型的值，我们需要再后面加一个f或是F表示是flaot类型值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b的结果是：%f&quot;</span>, a + b);   <span class="comment">//根据上表得到，小数类型需要使用%f表示，这里我们可以直接将a + b放入其中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果也是正确的：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/M8ia6jKlW7epwXg.jpg" alt="image-20220603132459810"></p><p>当然，我们也可以一次性打印多个，只需要填写多个占位符表示即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">2.5f</span>;   <span class="comment">//整数类型默认是int，如果要表示为long类型的值，也是需要在最后添加一个l或L</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f, b = %f&quot;</span>, a, b);   <span class="comment">//后面可以一直添加（逗号隔开），但是注意要和前面的占位符对应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果也是正常的：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/2n6GfkdlFPX4Bv1.jpg" alt="image-20220603132713970"></p><p>我们再来看看字符类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;   <span class="comment">//字符需要使用单引号囊括，且只能有一个字符，不能写成&#x27;AA&#x27;，这就不是单个字符了</span></span><br><span class="line"><span class="comment">//注意这里的A代表的是A这个字符，对应的ASCII码是65，实际上c存储的是65这个数字</span></span><br></pre></td></tr></table></figure><p>我们也可以通过格式化打印来查看它的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;</span>, c, c);   <span class="comment">//这里我们使用%c来以字符形式输出，%d输出的是变量数据的整数形式，其实就是对应的ASCII码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/VsMorWTd13YLp8Q.jpg" alt="image-20220603133727498"></p><p>当然，我们也可以直接让char存储一个数字（ASCII码），同样也可以打印出对应的字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">66</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;</span>, c, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/shjrQKayID9YwVc.jpg" alt="image-20220603133858133"></p><p>那么现在请各位小伙伴看看下面这段代码会输出什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;变量c的ASCII码为：%d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这里得到的结果就是字符<code>a</code>的ASCII码值，注意千万不要认为c得到的是变量a的值，这里使用的是字符<code>a</code>，跟上面的变量a半毛钱关系都没有：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/X1f6SzW7aBoFnJh.jpg" alt="image-20220603134234040"></p><p>但是如果我们去掉引号，就相当于把变量a的值给了c，c现在的ASCII码就是10了，所以这里一定要分清楚。</p><p>对于某些无法表示的字符，比如换行这类字符，我们没办法直接敲出来，只能使用转义字符进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>详细的转义字符表参见前面的基本数据类型章节。</p><p>变量除了有初始值之外，也可以在后续的过程中得到新的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;</span><br><span class="line">    s = <span class="number">20</span>;    <span class="comment">//重新赋值为20，注意这里就不要再指定类型了，指定类型只有在声明变量时才需要</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, s);   <span class="comment">//打印结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，得到的是我们最后一次对变量修改的结果：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/mIXbe91qu7B5ZKU.jpg" alt="image-20220603135152184"></p><p>那要是我们不对变量设定初始值呢？那么变量会不会有默认值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,%d&quot;</span>, a, b, c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虽然定义变量但是我们没有为其设定初始值，那么它的值就是不确定的了（千万注意并不是不设定值默认就是0）：</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/WJQC6oLemItpBVH.png" alt="image-20230814161423039"></p><p>所以各位小伙伴以后在使用时一定要注意这个问题，至于为什么不是0，这是因为内存分配机制，我们在下一章高级篇再进行讲解。</p><p>我们再来看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">127</span>;    <span class="comment">//已经到达c的最大值了</span></span><br><span class="line">    c = c + <span class="number">1</span>;   <span class="comment">//我不管，我就要再加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);    <span class="comment">//这时会得到什么结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/N7lGU4n2OkxjLcF.jpg" alt="image-20220603143909688"></p><p>怎么127加上1还变成-128了呢？这是由于位数不够，导致运算结果值溢出：</p><ul><li>127  +   1= 01111111   +    1</li><li>由于现在是二进制，满2进1，所以最后变成</li><li>10000000   =   补码形式的 -128</li></ul><p>所以，了解上面这些计算机底层原理是很重要的，我们能够很轻松地知道为什么会这样。</p><p>在我们的运算中，可能也会存在一些一成不变的值，比如<code>π</code>的值永远都是<code>3.1415....</code>，在我们的程序中，也可以使用这样不可变的变量，我们成为常量。</p><p>定义常量和变量比较类似，但是需要在前面添加一个<code>const</code>关键字，表示这是一个常量：</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/12GicHh5IRTFKyM.png" alt="image-20230814161342923"></p><p>可以看到，常量在一开始设定初始值后，后续是不允许进行修改的。</p><h3 id="无符号数">无符号数</h3><p>我们知道，所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的<code>char</code>类型：</p><ul><li>考虑符号表示范围：-128~127</li><li>不考虑符号：0~255</li></ul><p>我们也可以直接使用这些不带符号位的数据类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-65</span>;   <span class="comment">//数据类型前面添加unsigned关键字表示采用无符号形式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, c);    <span class="comment">//%u以无符号形式输出十进制数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/Hkg4MIFcXzKwClp.jpg" alt="image-20220603142210120"></p><p>结合我们前面学习的基础知识，我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位：</p><ul><li>00000000   -&gt;    现在赋值-65    -&gt;    -65的补码形式   -&gt;     10111111</li><li>由于现在没有符号位，一律都是正数，所以，10111111  =  128 + 32 + 16 + 8 + 4 + 2 + 1 = 191</li></ul><p>我们也可以直接以无符号数形式打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, i);    <span class="comment">//%u以无符号形式输出十进制数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/PYNZLCWc6OFVui8.jpg" alt="image-20220603143441616"></p><p>得到无符号int的最大值。</p><h3 id="类型转换">类型转换</h3><p>一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为<strong>自动类型转换</strong>和<strong>强制类型转换</strong>，比如我们现在希望将一个short类型的数据转换为int类型的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s;   <span class="comment">//直接将s的值传递给i即可，但是注意此时s和i的类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是一种自动类型转换，自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">3</span>;    <span class="comment">//包括这里我们给的明明是一个int整数3但是却可以赋值给float类型，说明也是进行了自动类型转换</span></span><br></pre></td></tr></table></figure><p>如果我们使用一个比转换的类型最大值都还要大的值进行类型转换，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">511</span>;</span><br><span class="line">    <span class="type">char</span> b = a;   <span class="comment">//最大127</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/U9rxV53lCzB4ARm.jpg" alt="image-20220606180919318"></p><p>很明显char类型是无法容纳大于127的数据的，因为只占一个字节，而int占4个字节，如果需要进行转换，那么就只能丢掉前面的就只保留char所需要的那几位了，所以这里得到的就是-1：</p><ul><li>511 = int  -&gt;  00000000 00000000 00000001 11111111</li><li>char   -&gt;   11111111   -&gt;    -1</li></ul><p>我们也可以将整数和小数类型的数据进行互相转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">99</span>;</span><br><span class="line">    <span class="type">double</span> d = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2023/08/14/EbORSnvuFXrJBz6.png" alt="image-20230814161659373"></p><p>不过这里需要注意的是，小数类型在转换回整数类型时，会丢失小数部分（注意，不是四舍五入，是直接丢失小数！）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">int</span> b = a;    <span class="comment">//这里编译器还提示了黄标，我们可以通过之后讲到的强制类型转换来处理</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2023/08/14/KvXkWxcCMZ6btE3.png" alt="image-20230814161647388"></p><p>除了赋值操作可以进行自动类型转换之外，在运算中也会进行自动类型转换，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> c = b / a;   <span class="comment">//  &quot;/&quot; 是除以的意思，也就是我们数学中的除法运算，这里表示a除以b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/FQpoer6ANgjsIlY.jpg" alt="image-20220606191838425"></p><p>可以看到，这里得到的结果是小数1.5，但是参与运算的既有整数类型，又有浮点类型，结果为什么就确定为浮点类型了呢？这显然是由于类型转换导致的。那么规则是什么呢？</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/39b2LouK8dfnNhv.jpg" alt="image-20220606191412418"></p><ul><li>不同的类型优先级不同（根据长度而定）</li><li>char和short类型在参与运算时一律转换为int再进行运算。</li><li>浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。</li><li>当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算，比如int和long参与运算，那么int转换为long再算，所以结果也是long类型，int和double参与运算，那么先把int转换为double再算。</li></ul><p>我们接着来看看强制类型转换，我们可以为手动去指定类型，强制类型转换格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(强制转换类型) 变量、常量或表达式;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = (<span class="type">int</span>) <span class="number">2.5</span>;   <span class="comment">//2.5是一个double类型的值，但是我们可以强制转换为int类型赋值给a，强制转换之后小数部分丢失</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以对一个算式的结果进行类型转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">int</span> b = (<span class="type">int</span>) (a + <span class="number">2.8</span>);   <span class="comment">//注意得括起来表示对整个算式的结果进行类型转换（括号跟数学中的挺像，也是提升优先级使用的，我们会在运算符部分详细讲解），不然强制类型转换只对其之后紧跟着的变量生效</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们需要得到两个int相除之后带小数的结果时，强制类型转换就显得很有用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a / b;    <span class="comment">//不进行任何的类型转换，int除以int结果仍然是int，导致小数丢失</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">double</span>) a / b;   <span class="comment">//对a进行强制类型转换，现在是double和int计算，根据上面自动类型转换规则，后面的int自动转换为double，结果也是double了，这样就是正确的结果了</span></span><br><span class="line">    printf(<span class="string">&quot;不进行类型转换: %f, 进行类型转换: %f&quot;</span>, c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合理地使用强制类型转换，能够解决我们很多情况下的计算问题。</p><hr><h2 id="运算符">运算符</h2><p>前面我们了解了如何声明变量以及变量的类型转换，那么我们如何去使用这些变量来参与计算呢？这是我们本小节的重点。</p><h3 id="基本运算符">基本运算符</h3><p>基本运算符包含我们在数学中常用的一些操作，比如加减乘除，分别对应：</p><ul><li>加法运算符：+</li><li>减法运算符：-</li><li>乘法运算符：*</li><li>除法运算符：/（注意不是“\”，看清楚一点）</li></ul><p>当然，还有我们之前使用的赋值运算符<code>=</code>，我们先来看看赋值运算符的使用，其实在之前我们已经学习过了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 = 值   <span class="comment">//其中，值可以直接是一个数字、一个变量、表达式的结果等</span></span><br></pre></td></tr></table></figure><p>实际上等号左边的内容准确的说应该是一个左值，不过大部分情况下都是变量，这里就不展开左值和右值的话题了（感兴趣的小伙伴可以去详细了解，有助于后面学习C++理解右值引用）</p><p>最简单的用法就是我们前面所说的，对一个变量进行赋值操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>也可以连续地使用赋值操作，让一连串的变量都等于后面的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = b = <span class="number">20</span>;   <span class="comment">//从右往左依次给b和a赋值20</span></span><br></pre></td></tr></table></figure><p>可以看出，实际上<code>=</code>运算除了赋值之外，和加减乘除运算一样也是有结果的，比如上面的 a = 就是b = 20 运算的结果（可以看着一个整体），只不过运算的结果就是b被赋值的值，也就是20。</p><p>我们接着来看加减法，这个就和我们数学中的是一样的了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + b);   <span class="comment">//打印 a + b 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以像数学中那样写在一个数或是变量的最前面，表示是正数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = +<span class="number">10</span>, b = +<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>不过默认情况下就是正数，所以没必要去写一个+号。减法运算符其实也是一样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a - b);   <span class="comment">//打印 a - b 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-10</span>;   <span class="comment">//等于 -10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, -a);   <span class="comment">//输出 -a 的值，就反着来嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看看乘法和除法运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d&quot;</span>, a * b, a / b);   <span class="comment">//使用方式和上面的加减法是差不多的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个比较有意思的取模运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>, b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a % b);   <span class="comment">//取模运算实际上就是计算a除以b的余数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过很遗憾，在C中没有指数相关的运算符（比如要计算5的10次方），在后面学习了循环语句之后，我们可以尝试来自己实现一个指数运算。</p><h3 id="运算符优先级">运算符优先级</h3><p>和数学中一样，运算符是有优先级的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d&quot;</span>, a + a * b);   <span class="comment">//如果没有优先级，那么结果应该是400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这里的结果是考虑了优先级的：</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/7URbsgALGmzxKDM.png" alt="image-20230814161757064"></p><p>在数学中，加减运算的优先级是没有乘除运算优先级高的，所以我们需要先计算那些乘除法，最后再来进行加减法的计算，而C语言中也是这样，运算符之间存在优先级概念。我们在数学中，如果需要优先计算加减法再计算乘除法，那么就需要使用括号来提升加减法的优先级，C语言也可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a + a) * b);   <span class="comment">//优先计算 a + a 的结果，再乘以 b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那要是遇到多重的呢？类似于下面的这种：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数学上的写法：[<span class="number">1</span> - <span class="comment">(3 + 4)</span>] x <span class="comment">(-2 ÷ 1)</span> = ?</span><br></pre></td></tr></table></figure><p>那么我们在C中就可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;%d&quot;</span>, (<span class="number">1</span> - (<span class="number">3</span> + <span class="number">4</span>)) * (-<span class="number">2</span> / <span class="number">1</span>));   <span class="comment">//其实写法基本差不多，只需要一律使用小括号即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过<code>()</code>运算符，来提升运算优先级了。</p><p>我们来总结一下，上面运算符优先级如下，从左往右依次递减：</p><ul><li><code>()</code>  &gt;   <code>+ - (做符号表示，比如-9)</code>  &gt;  <code>* / %</code>  &gt;  <code>+ - (做加减运算)</code>  &gt;  <code>=</code></li></ul><p>根据上面的优先级，我们来看看下面<code>a</code>的结果是什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> a = (<span class="number">3</span> + (c = <span class="number">2</span>)) * <span class="number">6</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b, c;</span><br><span class="line"><span class="type">int</span> a = (b = <span class="number">5</span>, c = b + <span class="number">8</span>);  <span class="comment">//逗号运算符从前往后依次执行，赋值结果是最后边的结果</span></span><br></pre></td></tr></table></figure><h3 id="自增自减运算符">自增自减运算符</h3><p>我们可以快速使用自增运算符来将变量的值<code>+1</code>，正常情况下我们想要让一个变量值自增需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>现在我们只需要替换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">++a;   <span class="comment">//使用自增运算符，效果等价于 a = a + 1</span></span><br></pre></td></tr></table></figure><p>并且它也是有结果的，除了做自增运算之外，它的结果是自增之后的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int b = a = a + 1;  下面效果完全一致</span></span><br><span class="line">    <span class="type">int</span> b = ++a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以将自增运算符写到后面，和写在前面的区别是，它是先返回当前变量的结果，再进行自增的，顺序是完全相反的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = a++;   <span class="comment">//写在后面和写在前面是有区别的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点内容：自增运算符<code>++</code>在前，那么先自增再出结果；自增运算符<code>++</code>在后，那么先出结果再自增。各位小伙伴可以直接记运算符的位置，来方便记忆。</p></blockquote><p>那要是现在我们不想自增1而是自增2或是其他的数字呢？我们可以使用复合赋值运算符，正常情况下依然是使用普通的赋值运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是现在我们可以简写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>效果和上面是完全一样的，并且得到的结果也是在自增之后的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = a += <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复合赋值运算符不仅仅支持加法，还支持各种各样的运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a %= <span class="number">3</span>;   <span class="comment">//可以复合各种运算，比如加减乘除、模运算、包括我们我们还要讲到的位运算等</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除了自增操作之外，还有自减操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a--;   <span class="comment">//--是自减操作，相当于a = a - 1，也可以在前后写，规则和上面的自增是一样的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意自增自减运算符和<code>+</code>、<code>-</code>做符号是的优先级一样，仅次于<code>()</code>运算符，所以在编写时一定要注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span> * --a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符">位运算符</h3><p>前面我们学习了乘法运算符<code>*</code>，当我们想要让一个变量的值变成2倍，只需要做一次乘法运算即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">2</span>;  <span class="comment">//很明显算完之后a就是20了</span></span><br></pre></td></tr></table></figure><p>但是我们现在可以利用位运算来快速进行计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a &lt;&lt; <span class="number">1</span>;   <span class="comment">//也可以写成复合形式 a &lt;&lt;= 1</span></span><br></pre></td></tr></table></figure><p>我们会发现这样运算之后得到的结果居然也是20，这是咋算出来的呢？实际上<code>&lt;&lt;</code>是让所有的bit位进行左移操作，上面就是左移1位，我们可以来看看：</p><ul><li>10  =  00001010     现在所以bit位上的数据左移一位    00010100   =   20</li></ul><p>是不是感觉特别神奇？就像我们在十进制中，做乘以10的操作一样：22乘以10那么就直接左移了一位变成220，而二进制也是一样的，如果让这些二进制数据左移的话，那么相当于在进行乘2的操作。</p><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a = a &lt;&lt; <span class="number">2</span>;   <span class="comment">//让a左移2位，实际上就是 a * 2 * 2，a * 2的平方（类比十进制，其实还是很好理解的）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然能左移那肯定也可以右移：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a = a &gt;&gt; <span class="number">1</span>;   <span class="comment">//右移其实就是除以2的操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了移动操作之外，我们也可以进行按位比较操作，先来看看按位与操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> c = a &amp; b;   <span class="comment">//按位与操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按位与实际上也是根据每个bit位来进行计算的：</p><ul><li>4  =  00000100</li><li>6  =  00000110</li><li>按位与实际上就是让两个数的每一位都进行比较，如果两个数对应的bit位都是1，那么结果的对应bit位上就是1，其他情况一律为0</li><li>所以计算结果为：00000100    =    4</li></ul><p>除了按位与之外，还有按位或运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> c = a | b;</span><br></pre></td></tr></table></figure><ul><li>4  =  00000100</li><li>6  =  00000110</li><li>按位与实际上也是让两个数的每一位都进行比较，如果两个数对应bit位上其中一个是1，那么结果的对应bit位上就是1，其他情况为0。</li><li>所以计算结果为：00000110  =  6</li></ul><p>还有异或和按位非（按位否定）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> c = a ^ b;    <span class="comment">//注意^不是指数运算，表示按位异或运算，让两个数的每一位都进行比较，如果两个数对应bit位上不同时为1或是同时为0，那么结果就是1，否则结果就是0，所以这里的结果就是2</span></span><br><span class="line">a = ~a;   <span class="comment">//按位否定针对某个数进行操作，它会将这个数的每一个bit位都置反，0变成1，1变成0，猜猜会变成几</span></span><br></pre></td></tr></table></figure><p>按位运算都是操作数据底层的二进制位来进行的。</p><h3 id="逻辑运算符">逻辑运算符</h3><p>最后我们来看一下逻辑运算符，逻辑运算符主要用到下一节的流程控制语句中。</p><p>逻辑运算符用于计算真和假，比如今天要么下雨要么不下雨，现在我们想要在程序中判断一下是否下雨了，这时就需要用到逻辑运算符，我们来举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">_Bool</span> c = a &lt; <span class="number">0</span>;    <span class="comment">//我们现在想要判断a的值是否小于0，我们可以直接使用小于符号进行判断，最后得到的结果只能是1或0</span></span><br><span class="line">  <span class="comment">//虽然结果是一个整数，但是这里推荐使用_Bool类型进行接收，它只能表示0和1（更加专业一些）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d&quot;</span>, c);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在C语言中，0一般都表示为假，而非0的所有值（包括正数和负数）都表示为真，上面得到1表示真，0表示假。</p><p>除了小于符号可以判断大小之外，还有：<code>&lt;</code>、<code> &lt;=</code>、<code>&gt;=</code>、<code>&gt;</code></p><p>比如我们现在想要判断字符C是否为大写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c是否为大写字母：%d&quot;</span>, c &gt;= <span class="string">&#x27;A&#x27;</span>);    <span class="comment">//由于底层存储的就是ASCII码，这里可以比较ASCII码，也可以写成字符的形式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现，现在我们的判断只能判断一个条件，也就是说只能判断c是否是大于等于’A’的，但是不能同时判断c的值是否是小于等于’Z’的，所以这时，我们就需要利用逻辑与和逻辑或来连接两个条件了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c是否为大写字母：%d&quot;</span>, c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>);   <span class="comment">//使用&amp;&amp;表示逻辑与，逻辑与要求两边都是真，结果才是真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又比如现在我们希望判断c是否不是大写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c是否不为大写字母：%d&quot;</span>, c &lt; <span class="string">&#x27;A&#x27;</span> || c &gt; <span class="string">&#x27;Z&#x27;</span>);   <span class="comment">//使用||表示逻辑或，只要两边其中一个为真或是都为真，结果就是真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以判断c是否为某个字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c是否为字母A：%d&quot;</span>, c == <span class="string">&#x27;A&#x27;</span>);    <span class="comment">//注意判断相等时使用==双等号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断不相等也可以使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c是否不为字母A：%d&quot;</span>, c != <span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们也可以对某个结果取反：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i是否不小于20：%d&quot;</span>, !(i &lt; <span class="number">20</span>));   <span class="comment">//使用!来对结果取反，注意!优先级很高，一定要括起来，不然会直接对i生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意一下<code>!</code>如果直接作用于某个变量或是常量，那么会直接按照上面的规则（0表示假，非0表示真）非0一律转换为0，0一律转换为1。</p><p>这里我们可以结合三目运算符来使用这些逻辑运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = i &gt; <span class="number">10</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;    <span class="comment">//三目运算符格式为：expression ? 值1 : 值2，返回的结果会根据前面判断的结果来的</span></span><br><span class="line">    <span class="comment">//这里是判断i是否大于10，如果大于那么c的值就是A，否则就是B</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来总结一下前面认识的所有运算符的优先级，从上往下依次降低：</p><table><thead><tr><th>运算符</th><th>解释</th><th>结合方式</th></tr></thead><tbody><tr><td>()</td><td>同数学中的括号，直接提升到最高优先级</td><td>由左向右</td></tr><tr><td>! ~ ++ – + -</td><td>否定，按位否定，增量，减量，正负号</td><td>由右向左</td></tr><tr><td>* / %</td><td>乘，除，取模</td><td>由左向右</td></tr><tr><td>+ -</td><td>加，减</td><td>由左向右</td></tr><tr><td>&lt;&lt; &gt;&gt;</td><td>左移，右移</td><td>由左向右</td></tr><tr><td>&lt; &lt;= &gt;= &gt;</td><td>小于，小于等于，大于等于，大于</td><td>由左向右</td></tr><tr><td>== !=</td><td>等于，不等于</td><td>由左向右</td></tr><tr><td>&amp;</td><td>按位与</td><td>由左向右</td></tr><tr><td>^</td><td>按位异或</td><td>由左向右</td></tr><tr><td>|</td><td>按位或</td><td>由左向右</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>由左向右</td></tr><tr><td>||</td><td>逻辑或</td><td>由左向右</td></tr><tr><td>? :</td><td>条件</td><td>由右向左</td></tr><tr><td>= += -= *= /= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</td><td>各种赋值</td><td>由右向左</td></tr><tr><td>,</td><td>逗号（顺序）</td><td>由左向右</td></tr></tbody></table><hr><h2 id="流程控制">流程控制</h2><p>前面我们学习了运算符，知道该如何使用运算符来计算我们想要的内容，但是仅仅依靠计算我们的程序还没办法实现丰富多样的功能，我们还得加点额外的控制操作。</p><h3 id="分支语句-if">分支语句 - if</h3><p>我们可能会有这样的一个需求，就是判断某个条件，当满足此条件时，才执行某些代码，那这个时候该怎么办呢？我们可以使用<code>if</code>语句来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">20</span>) &#123;    <span class="comment">//我们只希望i大于20的时候才执行下面的打印语句</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World?&quot;</span>);   <span class="comment">//后面的代码在if之外，无论是否满足if条件，都跟后面的代码无关，所以这里的代码任何情况下都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句的标准格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件) &#123;</span><br><span class="line">    执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果只需要执行一行代码的话，可以省略花括号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)</span><br><span class="line">  一行执行的代码   <span class="comment">//注意这样只有后一行代码生效，其他的算作if之外的代码了</span></span><br></pre></td></tr></table></figure><p>现在我们需求升级了，我们需要判断某个条件，当满足此条件时，执行某些代码，而不满足时，我们想要执行另一段代码，我们就可以结合else语句来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//满足if条件才执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LBWNB&quot;</span>);   <span class="comment">//不满足if条件才执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样可能还是不够用，比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score =  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>这类的语句（包括我们下面还要介绍的三种）都是支持嵌套使用的，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score =  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &lt; <span class="number">60</span>) &#123;   <span class="comment">//先判断不及格</span></span><br><span class="line">        <span class="keyword">if</span>(score &gt; <span class="number">30</span>) &#123;   <span class="comment">//在内层再嵌套一个if语句进行进一步的判断</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学习C++&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学习Java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分支语句-switch">分支语句 - switch</h3><p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;   <span class="comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span></span><br><span class="line">  <span class="keyword">case</span> 匹配值:    <span class="comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span></span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">break</span>;    <span class="comment">//代码执行结束后需要使用break来结束，否则会继续溜到下一个case继续执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;  <span class="comment">//这里目标就是变量c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:    <span class="comment">//分别指定ABC三个匹配值，并且执行不同的代码</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去尖子班！准备冲刺985大学！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去平行班！准备冲刺一本！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去职高深造。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p><p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;</span><br><span class="line">    <span class="keyword">case</span>: ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    其他情况下执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去尖子班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去平行班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去差生班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:   <span class="comment">//其他情况一律就是下面的代码了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去读职高，分流&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;A&#x27;</span>) &#123;    <span class="comment">//嵌套一个if语句</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;去尖子班！&quot;</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;去平行班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句-for">循环语句 - for</h3><p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句，循环语句。</p><p>我们在某些时候，可能需要批量执行某些代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="comment">//把这句话给我打印三遍</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。现在我们可以使用for循环语句来多次执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>表达式<span class="number">2</span>;表达式<span class="number">3</span>) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来介绍一下：</p><ul><li>表达式1：在循环开始时仅执行一次。</li><li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li><li>表达式3：每次循环完成后会执行一次。</li><li>循环体：每次循环都会执行循环体里面的内容，直到循环结束。</li></ul><p>一个标准的for循环语句写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如现在我们希望循环4次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">//首先定义一个变量i用于控制循环结束</span></span><br><span class="line">  <span class="comment">//表达式2在循环开始之前判断是否小于4</span></span><br><span class="line">  <span class="comment">//表达式3每次循环结束都让i自增一次，这样当自增4次之后不再满足条件，循环就会结束，正好4次循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看按顺序打印的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//比如现在我们希望循环4次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2023/08/14/d1twDPaBfKFYO6G.png" alt="image-20230814161836243"></p><p>这样，利用循环我们就可以批量执行各种操作了。</p><p>注意，如果表达式2我们什么都不写，那么会默认判定为真：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; ++i) &#123;   <span class="comment">//表达式2不编写任何内容，默认为真，这样的话循环永远都不会结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/AHoTpOIEYu8Jc7R.jpg" alt="image-20220612164349847"></p><p>所以，如果我们想要编写一个无限循环，其实什么都不用写就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;   <span class="comment">//什么都不写直接无限循环，但是注意，两个分号还是要写的</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);   <span class="comment">//这里用到了\n表示换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>) <span class="keyword">break</span>;   <span class="comment">//比如现在我们希望在满足某个条件下提前终止循环，可以使用break关键字来跳出循环</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/vW37gTywX92AI1r.jpg" alt="image-20220613101128788"></p><p>可以看到，当满足条件时，会直接通过break跳出循环，循环不再继续下去，直接结束掉。</p><p>我们也可以加速循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>) <span class="keyword">continue</span>;   <span class="comment">//使用continue关键字会加速循环，无论后面有没有未执行完的代码，都会直接开启下一轮循环</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/WeHJkqmEfGcn53r.jpg" alt="image-20220613101847762"></p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;    <span class="comment">//当i == j时加速循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/Kh9U3l7rEqtGuQ1.jpg" alt="image-20220613102100374"></p><p>可以看到，continue仅仅加速的是内层循环，而对外层循环没有任何效果，同样的，break也只会终结离它最近的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span>;    <span class="comment">//当i == j时终止循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/6TaNChfX9tI351r.jpg" alt="image-20220613102347086"></p><h3 id="循环语句-while">循环语句 - while</h3><p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;   <span class="comment">//每次循环开始之前都会判断括号内的内容是否为真，如果是就继续循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);   <span class="comment">//这里会无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">100</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;   <span class="comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, i);</span><br><span class="line">        i /= <span class="number">2</span>;   <span class="comment">//每次循环都除以2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/xBE3NKZipVqJwjP.jpg" alt="image-20220612170911315"></p><p>while也支持使用break和continue来进行循环的控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">30</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, i);</span><br><span class="line">    i /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2023/08/14/CNuWrmvlg9qcjeQ.png" alt="image-20230814161909429"></p><p>我们可以反转循环判断的位置，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">//无论满不满足循环条件，先执行循环体里面的内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);   <span class="comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/clJF7jrBqWAtbZ4.jpg" alt="image-20220613103504978"></p><h3 id="实战：寻找水仙花数">实战：寻找水仙花数</h3><blockquote><p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指**一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。**例如：1^3 + 5^3+ 3^3 = 153。”</p></blockquote><p>现在请你设计一个C语言程序，打印出所有1000以内的水仙花数。</p><h3 id="实战：打印九九乘法表">实战：打印九九乘法表</h3><p><img src="https://image.itbaima.cn/markdown/2023/08/14/HQw5769egkmDOM8.png" alt="image-20230814161933955"></p><p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个C语言程序来实现它。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/BW7lvFXy4GRb1P5.jpg" alt="image-20220613105519595"></p><h3 id="实战：斐波那契数列解法其一">实战：斐波那契数列解法其一</h3><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：**1、1、2、3、5、8、13、21、34、……*<em>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N</em>）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">7</span>, result;  <span class="comment">//target是要获取的数，result是结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请在这里实现算法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="数组">数组</h2><p>现在我们有一个新的需求，我们需要存储2022年每个月都天数，那么此时，为了保存这12个月的天数，我们就得创建12个变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> january = <span class="number">31</span>, february = <span class="number">28</span>, march = <span class="number">31</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是不是太累了点？万一我们想保存100个商品的售价，那岂不是得创建100个变量？这肯定不行啊。</p><h3 id="数组的创建和使用">数组的创建和使用</h3><p>为了解决这种问题，我们可以使用数组，什么是数组呢？简单来说，就是存放数据的一个组，所有的数据都统一存放在这一个组中，一个数组可以同时存放多个数据。比如现在我们想保存12个月的天数，那么我们只需要创建一个int类型的数组就可以了，它可以保存很多个int类型的数据，这些保存在数组中的数据，称为“元素”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;  <span class="comment">//12个月的数据全部保存在了一起</span></span><br></pre></td></tr></table></figure><p>可以看到，数组的定义方式也比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 数组名称[数组大小] = &#123;数据<span class="number">1</span>, 数据<span class="number">2.</span>..&#125;;  <span class="comment">//后面的数据可以在一开始的时候不赋值，并且数组大小必须是整数</span></span><br></pre></td></tr></table></figure><p>注意数组只能存放指定类型的数据，一旦确定是不能更改的，因为数组声明后，会在内存中开辟一块连续的区域，来存放这些数据，所以类型和长度必须在一开始就明确。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/ESJ5WmydXrxfwsU.jpg" alt="image-20220613113423268"></p><p>创建数组的方式有很多种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];   <span class="comment">//直接声明int类型数组，容量为10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;   <span class="comment">//声明后，可以赋值初始值，使用&#123;&#125;囊括，不一定需要让10个位置都有初始值，比如这里仅仅是为前三个设定了初始值，注意，跟变量一样，如果不设定初始值，数组内的数据并不一定都是0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">777</span>, [<span class="number">9</span>] = <span class="number">666</span>&#125;; <span class="comment">//我们也可以通过 [下标] = 的形式来指定某一位的初始值，注意下标是从0开始的，第一个元素就是第0个下标位置，比如这里数组容量为10，那么最多到9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">//也可以根据后面的赋值来决定数组长度</span></span><br></pre></td></tr></table></figure><p>基本类型都可以声明数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;   <span class="comment">//多个字符</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;ABC&quot;</span>;  <span class="comment">//实际上字符串就是多个字符的数组形式，有关字符串我们会在下一节进行讲解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么数组定义好了，如何去使用它呢？比如我们现在需要打印12个月的天数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> days = arr[i];   <span class="comment">//直接通过数组 名称[下标] 来访问对应的元素值，再次提醒，下标是从0开始的，不是1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2022年 %d 月的天数是：%d 天\n&quot;</span>, (i + <span class="number">1</span>), days);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2023/08/14/l6EynrbTipMkfDh.png" alt="image-20230814162007287"></p><p>当然我们也可以对数组中的值进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">666</span>, <span class="number">777</span>, <span class="number">888</span>&#125;;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">999</span>;   <span class="comment">//比如我们现在想要让第二个元素的值变成999</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">1</span>]);   <span class="comment">//打印一下看看是不是变成了999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/Q4bnsaIyz7NXReF.jpg" alt="image-20220613114928435"></p><p>注意，和变量一样，如果只是创建数组但是不赋初始值的话，因为是在内存中随机申请的一块空间，有可能之前其他地方使用过，保存了一些数据，所以数组内部的元素值并不一定都是0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/63BLiUNexSjJgym.jpg" alt="image-20220613115108971"></p><p>不要尝试去访问超出数组长度位置的数据，虽然可以编译通过，但是会给警告，这些数据是毫无意义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">3</span>]);  <span class="comment">//不能去访问超出数组长度的元素，很明显这里根本就没有第四个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组">多维数组</h3><p>数组不仅仅只可以有一个维度，我们可以创建二维甚至多维的数组，简单来说就是，存放数组的数组（套娃了属于是）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][<span class="number">2</span>] = &#123;&#123;<span class="number">20</span>, <span class="number">10</span>&#125;, &#123;<span class="number">18</span>, <span class="number">9</span>&#125;&#125;;   <span class="comment">//可以看到，数组里面存放的居然是数组</span></span><br><span class="line"><span class="comment">//存放的内层数组的长度是需要确定的，存放数组的数组和之前一样，可以根据后面的值决定</span></span><br></pre></td></tr></table></figure><p>比如现在我们要存放2020-2022年每个月的天数，那么此时用一维数组肯定是不方便了，我们就可以使用二维数组来处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">12</span>] = &#123;&#123;<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, <span class="comment">//2020年是闰年，2月有29天</span></span><br><span class="line">                  &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;,</span><br><span class="line">                  &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>这样，我们就通过二维数组将这三年每个月的天数都保存下来了。</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/IHdxlec4SXKZtyi.png" alt="image-20230814162042949"></p><p>那么二维数组又该如何去访问呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">12</span>] = &#123;&#123;<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;, <span class="comment">//2020年是闰年，2月有29天</span></span><br><span class="line">                      &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;,</span><br><span class="line">                      &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>][<span class="number">1</span>]);   <span class="comment">//比如现在我们想要获取2020年2月的天数，首先第一个是[0]表示存放的第一个数组，第二个[1]表示数组中的第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了二维还可以上升到三维、四维：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;, &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>有关多维数组，暂时先介绍到这里。</p><h3 id="实战：冒泡排序算法">实战：冒泡排序算法</h3><p>现在有一个int数组，但是数组内的数据是打乱的，现在请你通过C语言，实现将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;  <span class="comment">//乱序的</span></span><br><span class="line">    <span class="comment">//请编写代码对以上数组进行排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用冒泡排序算法来实现，此算法的核心思想是：</p><ul><li>假设数组长度为N</li><li>进行N轮循环，每轮循环都选出一个最大的数放到后面。</li><li>每次循环中，从第一个数开始，让其与后面的数两两比较，如果更大，就交换位置，如果更小，就不动。</li></ul><p>动画演示：<a href="https://visualgo.net/zh/sorting?slide=2-2">https://visualgo.net/zh/sorting?slide=2-2</a></p><h3 id="实战：斐波那契数列解法其二">实战：斐波那契数列解法其二</h3><p>学习了数组，我们来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。</p><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/%E6%9C%80%E4%BC%98%E5%80%BC">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/%E8%BF%99%E4%BA%9B%E5%AD%90">这些子</a>问题的解得到原问题的解。</p></blockquote><p>我们可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律我们可以得知：</p><ul><li><code>fib[i] = fib[i - 1] + fib[i - 2]</code>（这里<code>fib</code>代表斐波那契数列）</li></ul><p>得到这样的一个关系（递推方程）就好办了，我们要求解数列第<code>i</code>个位置上的数，只需要知道<code>i - 1</code>和<code>i - 2</code>的值即可，这样，一个大问题，就分成了两个小问题，比如现在我们要求解斐波那契数列的第5个元素：</p><ul><li><code>fib[4] = fib[3] + fib[2]</code>现在我们只需要知道<code>fib[3]</code>和<code>fib[2]</code>即可，那么我们接着来看：</li><li><code>fib[3] = fib[2] + fib[1]</code>以及<code>fib[2] = fib[1] + fib[0]</code></li><li>由于<code>fib[0]</code>和<code>fib[1]</code>我们已经明确知道是<code>1</code>了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来不就能得到原来大问题的结果了吗？</li></ul><p>现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。</p><h3 id="实战：打家劫舍">实战：打家劫舍</h3><p>我们继续通过一道简单的算法题来强化动态规划思想。</p><p><strong>来源：力扣（LeetCode）No.198 打家劫舍</strong>：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p></blockquote><p><strong>示例 1：</strong></p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><p><img src="https://image.itbaima.cn/markdown/2022/06/17/WvZltqPwyUEhkJY.jpg" alt="image-20220613124415156"></p><p>这道题我们也可以很轻松地按照上面的动态规划思路来处理，首先我们可以将问题分为子问题，比如现在有<code>[2,7,9,3,1]</code>五个房屋，这个问题看起来比较复杂，我们不妨先将大问题先简化成小问题，我们来看看只有N个房屋的情况：</p><ul><li>假设现在只有<code>[2]</code>这一个房屋，那么很明显，我可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。</li><li>假设现在有<code>[2, 7]</code>这两个房屋，那么很明显，我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。</li><li>假设现在只有<code>[2, 7, 9]</code>这三个房屋，我们就要来看看了，是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果我们偷了一号房，那么就可以继续偷三号房，并且得到的钱就是从一号房过来的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是我们求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）：<ul><li><code>dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</code>  -&gt; <strong>递推方程已得到</strong></li></ul></li><li>这样就不难求出：<code>dp[2] = max(dp[1], dp[0] + value[i])</code> = <code>dp[2] = max(7, 2 + 9)</code> = <code>dp[2] = 11</code>，所以有三个房屋时最大的金额是11块钱。</li><li>所以，实际上我们只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。</li><li>我们以同样的方式来计算四个房屋<code>[2, 7, 9, 3]</code>的情况：<ul><li><code>dp[3] = max(dp[2], dp[1] + value[3])</code> = <code>dp[3] = max(11, 7 + 3)</code> = <code>dp[3] = 11</code></li></ul></li><li>所以，当有四个房屋时，我们依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。</li></ul><p>好了，现在思路已经出来了，我们直接上算法吧，现在请你实现下面的C语言程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>&#125;, size = <span class="number">5</span>, result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请补充程序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>力扣提交，建议各位小伙伴学习了函数和指针之后再回来看看，这里暂时可以跳过。</p><p><img src="https://image.itbaima.cn/markdown/2023/08/14/cm8AhzBNfJ4r3sX.png" alt="image-20230814162152413"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">2</span>) <span class="keyword">return</span> max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[numsSize];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[numsSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串">字符串</h2><p>前面我们学习了数组，而对于字符类型的数组，比较特殊，它实际上可以作为一个字符串（String）表示，字符串就是一个或多个字符的序列，比如我们在一开始认识的<code>&quot;Hello World!&quot;</code>，像这样的多个字符形成的一连串数据，就是一个字符串，而<code>printf</code>函数接受的第一个参数也是字符串。</p><p>那么，我们就来认识一下字符串。</p><h3 id="字符串的创建和使用">字符串的创建和使用</h3><p>在C语言中并没有直接提供存储字符串的类型，我们熟知的能够存储字符的只有char类型，但是它只能存储单个字符，而一连串的字符想要通过变量进行保存，那么就只能依靠数组了，char类型的数组允许我们存放多个字符，这样的话就可以表示字符串了。</p><p>比如我们现在想要存储<code>Hello</code>这一连串字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">//直接保存单个字符，但是注意，无论内容是什么，字符串末尾必须添加一个‘\0’字符（ASCII码为0）表示结束。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);   <span class="comment">//用%s来作为一个字符串输出</span></span><br></pre></td></tr></table></figure><p>不过这样写起来实在是太麻烦了，我们可以使用更加简便的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;   <span class="comment">//直接使用双引号将所有的内容囊括起来，并且也不需要补充\0（但是本质上是和上面一样的字符数组）</span></span><br><span class="line"><span class="comment">//也可以添加 const char str[] = &quot;Hello World!&quot;; 双引号囊括的字符串实际上就是一个const char数组类型的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure><p>这下终于明白了，原来我们一直在写的双引号，其实表示的就是一个字符串。</p><p>那么现在请各位小伙伴看看下面的写法有什么不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>我们发现一个问题，char类型只能保存ASCII编码表中的字符，但是我们发现实际上中文也是可以正常打印的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你这瓜保熟吗&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://image.itbaima.cn/markdown/2022/06/17/jC9Vn4MbgOzt7LB.jpg" alt="image-20220616114344138"></p><p>这是什么情况？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p><blockquote><p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000011</span> <span class="number">10000110</span>   <span class="comment">//这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的）</span></span><br></pre></td></tr></table></figure><p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p><p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode，规定每个字符必须使用俩个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p><p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，但是又得这样去表示，这就导致某些字符浪费了很多空间。所以最后就有了UTF-8编码格式，区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000 ~ 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 ~ 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 ~ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 ~ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式。</p></blockquote><p>简而言之，我们的中文实际上是依靠多个char来进行表示的。</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/yJjkVABhZCa5Dx2.jpg" alt="image-20220616134302528"></p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/ckD2LWU7MlfSTtb.jpg" alt="image-20220616134330805"></p><p>这样，我们就了解了字符串的使用。</p><h3 id="scanf、gets、puts函数">scanf、gets、puts函数</h3><p>函数我们会在下一章详细介绍，不过这里还是要再提到一个比较重要的函数。</p><p>前面我们认识了<code>printf</code>函数，实际上这个函数就是用于打印字符串到控制台，我们只需要填入一个字符串和后续的参数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//注意printf需要填写一个const char数组进去，也就是字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道该如何输出，那么输入该如何实现呢，比如我们现在希望将我们想要说的话告诉程序，让程序从控制台读取我们输入的内容，这时我们就需要使用到<code>scanf</code>函数了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);   <span class="comment">//使用scanf函数来接受控制台输入，并将输入的结果按照格式，分配给后续的变量</span></span><br><span class="line">  <span class="comment">//比如这里我们想要输入一个字符串，那么依然是使用%s（和输出是一样的占位符），后面跟上我们要赋值的数组（存放输入的内容）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的内容为：%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，成功接收到用户输入：</p><p><img src="https://image.itbaima.cn/markdown/2022/06/17/RoEjaFVL4P9fWil.jpg" alt="image-20220616141313060"></p><p>当然除了能够扫描成字符串之外，我们也可以直接扫描为一个数字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);   <span class="comment">//连续扫描两个int数字</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);   <span class="comment">//注意，如果不是数组类型，那么这里在填写变量时一定要在前面添加一个&amp;符号（至于为什么，下一章在指针小节中会详细介绍）这里的&amp;不是做与运算，而是取地址操作。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d&quot;</span>, a + b);   <span class="comment">//扫描成功后，我们来计算a + b的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用<code>scanf</code>之外，我们也可以使用字符串专用的函数来接受字符串类型的输入和输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">    gets(str);   <span class="comment">//gets也是接收控制台输入，然后将结果丢给str数组中</span></span><br><span class="line">    <span class="built_in">puts</span>(str);   <span class="comment">//puts其实就是直接打印字符串到控制台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有专门用于字符输入输出的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = getchar();</span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们目前还没有学习函数，所以这里稍微提及一下即可。</p><h3 id="实战：回文串判断">实战：回文串判断</h3><p>“回文串”是一个正读和反读都一样的字符串，请你实现一个C语言程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p><blockquote><p>ABCBA    就是一个回文串，因为正读反读都是一样的</p><p>ABCA    就不是一个回文串，因为反着读不一样</p></blockquote><h3 id="实战：字符串匹配KMP算法">实战：字符串匹配KMP算法</h3><p>现在有两个字符串：</p><blockquote><p>str1 = “abcdabbc”</p><p>str2 = “cda”</p></blockquote><p>现在请你设计一个C语言程序，判断第一个字符串中是否包含了第二个字符串，比如上面的例子中，很明显第一个字符串包含了第二个字符串。</p><ul><li>暴力解法</li><li>KMP算法</li></ul><p>有关C语言的基础部分内容，我们就讲解到这里，从下一章开始，难度将会有一定的提升，所以请各位小伙伴务必将本章知识点梳理清楚，牢记心中。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机思维导论-C语言程序设计（一）</title>
    <link href="https://blog.yuncan.xyz/posts/c1.html"/>
    <id>https://blog.yuncan.xyz/posts/c1.html</id>
    <published>2023-06-16T03:35:34.000Z</published>
    <updated>2023-06-16T03:35:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://papi.yuncan.xyz/cover/c_cover.jpg" alt="cover"></p><h1>计算机思维导论</h1><p>计算机自1946年问世以来，几乎改变了整个世界。</p><p>现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。</p><p>也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。</p><h2 id="计算机的世界">计算机的世界</h2><p>计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/7FLkyEadxlKHDBo.png" alt="image-20230228214034266"></p><p>这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。</p><p>很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。</p><blockquote><p>用数字信号完成对数字量进行<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/3118202">算术运算</a>和<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/5246264">基本单元</a>。</p><p>计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。</p></blockquote><p>数字电路引入了逻辑判断，我们来看看简单的数字电路：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/OwqL2RlPQWKsI5z.png" alt="image-20230228214109516"></p><p>数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。</p><blockquote><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457">二进制</a>是计算技术中广泛采用的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113">数制</a>。二进制数据是用0和1两个数码来表示的数。它的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0/4260">基数</a>为2，进位规则是“逢二进一”，借位规则是“借一当二”。</p><p>比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）</p></blockquote><p>当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是<a href="https://baike.baidu.com/item/%E4%B8%8E%E9%97%A8">与门</a>、<a href="https://baike.baidu.com/item/%E6%88%96%E9%97%A8">或门</a>和<a href="https://baike.baidu.com/item/%E9%9D%9E%E9%97%A8">非门</a>，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）</p><p>比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如：</p><ul><li>1 &amp; 1 = 1    必须两边都是真，结果才为真。</li><li>1 &amp; 0 = 0    两边任意一个或者都不是真，结果为假。</li></ul><p>或运算（用 | 表示）：</p><ul><li>1 | 0 = 1    两边只要有一个为真，结果就为真</li><li>0 | 0 = 0    两边同时为假，结果才是假</li></ul><p>非运算实际上就是取反操作（可以是 ! 表示）</p><ul><li>!1 = 0</li><li>!0 = 1     非运算会将真变成假，假变成真</li></ul><p>有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。</p><p>前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/61PX5Rlw3ecEGiJ.png" alt="image-20230228214242283"></p><p>相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/Y2tyMd6mSVgro9N.png" alt="image-20230228214255379"></p><p>我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。</p><p>当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/8OdrGLplIVs5ZE2.png" alt="image-20230228214446410"></p><p>计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。</p><p>**问题：**我们上面提到的这些硬件设备哪些是属于外设？</p><h2 id="操作系统概述">操作系统概述</h2><p>前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。</p><blockquote><p>操作系统（operating system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE/2394679">配置</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215">文件系统</a>等基本事务。操作系统也提供一个让用户与系统<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>操作的界面。</p><p>一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。</p></blockquote><p>一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/WcDxHTraFAK6t9p.png" alt="image-20230228214559098"></p><p>有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。</p><p>不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/OlQp9n6ZY3qts1M.png" alt="image-20230228214618172"></p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/ilDr1HwXomgBYSx.png" alt="image-20230228214721666"></p><p>没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。</p><blockquote><p>中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。</p></blockquote><p>当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/uYX84BNzl9FV1Mr.png" alt="image-20230228214754274"></p><p>这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。</p><p>不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。</p><p>正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。</p><h2 id="计算机编程语言">计算机编程语言</h2><p>现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/cu8GVYZB24PvzIR.png" alt="image-20230228214817739"></p><p>那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。</p><blockquote><p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p></blockquote><p>我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。</p><p>我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：</p><ul><li>000001  -  代表开机</li><li>000010  -  代表关机</li><li>000011  -  代表进行加法运算</li></ul><p>当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。</p><p>不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：</p><ul><li>MOV   传送字或字节。</li><li>MOVSX  先符号扩展,再传送。</li><li>MOVZX  先零扩展,再传送。</li><li>PUSH  把字压入堆栈。</li></ul><p>把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/ypHDg3XRNFuVtrc.png" alt="image-20230228214843558"></p><p>不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。</p><blockquote><p>C语言诞生于美国的<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4/686816">贝尔实验室</a>，由<a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87/7267171">丹尼斯·里奇</a>（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的<a href="https://baike.baidu.com/item/B%E8%AF%AD%E8%A8%80/1845842">B语言</a>为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。</p></blockquote><p>高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">//定义一个a等于10</span></span><br><span class="line">  <span class="type">int</span> b = <span class="number">10</span>;   <span class="comment">//定义一个b等于10</span></span><br><span class="line">  <span class="type">int</span> c = a + b;   <span class="comment">//语义非常明确，c就是a加上b计算出来的结果。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在看不懂没关系，我们后面慢慢学。</p><p>C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/H8ZXlCwO3gyxTpz.png" alt="image-20230228214904604"></p><p>当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/73aeAcv2EOUqzHY.png" alt="image-20230228214946883"></p><p>可以看到在2021年9月，依然排在编程语言排行榜的<strong>第一名</strong>（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。</p><p>那么从下节课开始，我们就先做好一些环境上的准备。</p><h2 id="C语言开发环境部署">C语言开发环境部署</h2><p>完成开发环境部署之后，我们就可以使用C语言来将一句话输出到控制台了，成功编译运行下面的简单程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们既然要将我们编写的C语言代码进行编译，那么肯定得找到一个合适的编译器才行，现代的集成开发环境IDE一般都包含了这些编译器，所以我们不需要进行单独的安装。</p><p>我们只需要找一个集成开发环境去安装就行了，目前功能比较完善的集成开发环境有：</p><ul><li>Codeblocks（支持Windows、Linux、MacOS操作系统）</li><li>Visual Studio（支持Windows、MacOS操作系统）</li><li>CLion（支持Windows、Linux、MacOS操作系统）</li></ul><p>这里我们就使用CLion作为我们的开发工具使用（这个IDE是收费的，但是学生可以申请免费使用，别担心，大学四年肯定是够你用了，选这个是考虑到后面同学们可能会继续学习Java，Java语言的推荐IDE也是同一个公司的产品，界面都长得差不多）当然如果你想要使用其他的开发工具，也可以，但是这里我们就不演示了。</p><p>首先前往官网下载：<a href="https://www.jetbrains.com/clion/">CLion: A Cross-Platform IDE for C and C++ by JetBrains</a></p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/7GMygwFJlQp9ZP8.png" alt="image-20230228215009796"></p><p>下载完成后我们直接点击安装：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/4I7Ei1TsDfb9qxn.png" alt="image-20230228215151889"></p><p>如果你不是很熟悉，建议直接点Next安装到C盘默认路径，不要去修改，当然如果确实C盘没有空间，那可以自行修改为其他路径，但是注意最好路径中不要出现中文。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/RTQlsGAtc89qOyX.png" alt="image-20230228215202467"></p><p>勾选一下创建快捷方式，然后继续点Next等待安装就行了：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/hz7r6lTNHP9pJoM.png" alt="image-20230228215212439"></p><p>安装完成后，我们可以直接打开：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/2eVK1DiEJST5PGx.png" alt="image-20230228215225580"></p><p>这里会提示我们激活，点击按钮去官网注册一个账号。注册完成后，推荐去申请一下学生授权，因为试用只有30天：<a href="https://zhuanlan.zhihu.com/p/378185042">Jetbrains学生授权获取指南 - 知乎 (zhihu.com)</a></p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/pdFNa7TyJWHre3U.png" alt="image-20230228215236815"></p><p>这里我们点击开始试用，然后就可以点击Continue了，现在成功来到主界面：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/buIM8HX1QY6qTvk.png" alt="image-20230228215248832"></p><p>由于是英文，使用不太方便，所以我们安装一下中文插件：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/o7SXRVt35GWk6CO.png" alt="image-20230228215259946"></p><p>现在我们就成功安装好CLion集成开发环境了。</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/iElSmtv1aM6B2q9.png" alt="image-20230228215313007"></p><p>现在我们来创建我们的第一个C语言项目（我们的程序是以一个项目的形式进行管理的，这里知道怎么创建就行了）：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/Ojk9IrAcGMXPvFn.png" alt="image-20230228215325386"></p><p>这里选择C可执行文件，然后项目的保存位置可以自行修改，配置完成后点击创建：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/VGChXBaFYokxrQd.png" alt="image-20230228215336557"></p><p>可以看到，在创建之后，会自动为我们生成一段示例代码，而之后我们要编写的代码，都在生成的main.c中进行编写，除了这个文件，其他的全部不要去修改，也不用管是什么意思，后面我们会慢慢介绍。</p><p>接着我们需要配置一下工具链，选择捆绑的MinGW（如果已经有了就不需要配置了）</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/AFTY7rUW1glZqk3.png" alt="image-20230228215350815"></p><p>那么这段示例代码有了，我们如何编译运行呢？</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/GxcwNidTHjVt1zo.png" alt="image-20230228215407064"></p><p>我们可以点击代码旁边的绿色三角形符号或是右上角的绿色三角形，就可以直接编译运行我们的代码了。运行的结果是在控制台输出一个“HelloWorld！”，当然我们也可以直接运行编译出来的可执行文件：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/uLVbBOUsf1aYEWi.png" alt="image-20230228215418617"></p><p>我们可以看到，这里生成了一个<code>项目名称.exe</code>文件，这种就是Windows环境下可以直接运行的应用程序，我们可以打开这个文件夹，直接使用cmd来运行：</p><p><img src="https://image.itbaima.cn/markdown/2023/02/28/GvFUNbVnLIwqyuK.png" alt="image-20230228215428496"></p><p>运行出来的效果是一样的，这种程序实际上就是最原始的命令行程序，输入和输出都是在这种黑框框中进行的，而我们的主要学习目标也是这种命令行程序。</p><p>这样我们就配置好了开发环境，然后就不要去动其他的东西了，一般新手最容易遇到一些奇奇怪怪的问题。</p>]]></content>
    
    
    <summary type="html">🎨计算机基础部分</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.yuncan.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Clion" scheme="https://blog.yuncan.xyz/tags/Clion/"/>
    
    <category term="C" scheme="https://blog.yuncan.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://blog.yuncan.xyz/posts/markdown.html"/>
    <id>https://blog.yuncan.xyz/posts/markdown.html</id>
    <published>2023-06-08T14:00:00.000Z</published>
    <updated>2023-06-08T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    
    <category term="Markdown" scheme="https://blog.yuncan.xyz/tags/Markdown/"/>
    
  </entry>
  
</feed>
